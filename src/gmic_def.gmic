#@gmic
#
#  File        : gmic_def.gmic
#                ( G'MIC commands file )
#
#  Description : Define the set of standard G'MIC commands, as well as
#                the filters for the G'MIC plug-in for GIMP, and for the
#                web service G'MIC Online.
#                ( http://gmic.sourceforge.net )
#                This file is also a part of the CImg Library project.
#                ( http://cimg.sourceforge.net )
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#------ Syntax rules for a G'MIC command file :
#
#*** General syntax :
#
# - Each line starting with 'command_name :' starts a new definition of the G'MIC custom command '-command_name'.
# - Each line starting with '#' is a comment line.
# - Any other line is considered as the continuation of a previously started G'MIC custom command.
#
#*** Specific rules for 'gmic' (command-line interpreter) :
#
# - A comment line starting with '#@gmic' will be parsed by 'gmic' in order to display help for
#    G'MIC custom commands (when invoked with option '-h'). More precisely :
#
#      _ '#@gmic :: subsection' defines a new command subsection in the displayed help.
#      _ '#@gmic command_name : arguments_format1 : arguments_format2 : ... : (qualifier)' starts a new command description.
#      _ '#@gmic : description' add a new description line to the current command description.
#
#*** Specific rules for 'gmic_gimp' (plug-in for GIMP) :
#
# - A comment line starting with '#@gimp' will be parsed by the GIMP plug-in to define the filters tree.
# - A comment line starting with '#@gimp_xx' will define a filter only for a specific language 'xx'
#    (e.g. 'en','fr'...).
# - More precisely, the syntax of a '#@gimp' comment line is :
#
#    '#@gimp Folder name'
#
# or
#
#    '#@gimp Command name : command, preview_command, parameter = typedef, parameter2 = typedef'
#    '#@gimp : parameter3 = typedef, parameter4 = typedef ...., parameterN = typedef'
#
#   where :
#
#      'command' is the G'MIC command name called to process the image.
#
#      'preview_command' is the G'MIC command name called to process the preview.
#
#           Note that you can optionally specify a float-valued factor>=0 between parentheses at the end of
#           the 'preview_command' to force the default zoom factor used by the GIMP preview for this filter.
#           Use (0) for a 1:1 preview, (1) for previewing the whole image, (2) for 1/2 image and so on...
#
#      'parameter = typedef' tells about the names, types and default values of the filter parameters.
#
#           'typedef' can be :
#
#      _ 'float(default_value,min_value,max_value)'       : Add a float-valued parameter (as a GUI float slider).
#      _ 'int(default_value,min_value,max_value)'         : Add a integer parameter (as a GUI integer slider).
#      _ 'bool(default_value={ 0 | 1 | false | true })'   : Add a boolean parameter (0 or 1) (as a GUI checkbutton).
#      _ 'choice(_default_indice,Choice0,..,ChoiceN)'     : Add a integer parameter (as a GUI combobox).
#      _ 'text(_is_multiline={ 0 | 1 },_default text)'    : Add a single or multi-line text parameter (as a GUI text entry).
#      _ 'file(_default_filename)'                        : Add a filename parameter (as a GUI filechooser).
#      _ 'folder(_default_foldername)'                    : Add a foldername parameter (as a GUI folderchooser).
#      _ 'color(defaultR,defaultG,defaultB,_defaultA)'    : Add R,G,B[,A] parameters (as a GUI colorchooser).
#      _ 'note(_label)'                                   : Display a label, but do not add a new parameter.
#      _ 'link(_alignement,_label,URL)'                   : Display a label that link to a specified URL.
#      _ 'separator()'                                    : Display an horizontal separator.
#
#   Type separators '()' can be replaced by '[]' or '{}' if necessary (for instance if parentheses are required in
#   an argument of the typedef, e.g in a text). You can also replace 'typedef' by '_typedef' to tell the plug-in not
#   to update the image preview when the corresponding parameter is modified.
#
#   Use '_none_' as a special command or preview_command to tell the plug-in that the entry requires no G'MIC call.
#
#*** Specific rules for 'gmicol' (G'MIC web service) :
#
# - Same rules as for 'gmic_gimp', except that comment lines start with '#@gmicol'.
#
#-----------------------------------------------------------------------------------------------------------------------

#---------------------------------
#
#@gmic :: Global options
#
#---------------------------------

#@gmic debug : (*)
#@gmic : Activate debug mode.
#@gmic : When activated, the G'MIC interpreter becomes very verbose and outputs additionnal log
#@gmic : messages about its internal state on the standard output (stdout).
#@gmic : This option can be useful when debugging the execution of a custom command.

#@gmic h : eq. to '-help'. : (*)
h :
  -help $*

#@gmic help : _command : (no args) : (*)
#@gmic : Display help (optionally for specified command only) and exit.
#@gmic : (eq. to '-h').
help : -skip ${1=""},${2=1}
  -if {!@#} -return -endif
  -y -a y
  --_help $1,$2 -k[0]
  -if {narg(@{})} -_help[0] @{},0 -endif
  -rm

_help : -skip ${1=""}
  -v -1
  -if {!narg("$1")} _is_example=0 -__help ascii -v + -e[] "" -v - -rm -u "" -return -endif # Global help.
  ({'"$1"'}) -autocrop[-1] {'-'}
  -if {@{-1,100%}=={']'}" && "i!={'['}} -l[-1] -s -,{'['} -k[0] -endl -endif
  command=@{-1,t} -rm[-1]

  # Help requested for a specific command.
  ks0="0" ks1="-k[0]"
  -if $2 -__help_header_ascii[] -endif
  -r 1,{h+1},1,1,0,0,0,1
  -s +,{'"#@gmic "$command" :"'}
  -if {@#==1} -s +,{'"#@gmic "$command":"'} -endif
  -if {@#==1} -s +,{'"#@gmic "$command"\n"'} -endif
  -if {@#==1} -v + -e[] "\n[gmic] Command '"$command"' has no description. Try 'gmic -h' for global help.\n\n" -v - -rm -u "" -return -endif
  -rm[0] -a y -s -,10
  stopflag=0
  _is_example=0
  -_document_gmic_header_ascii[] 0
  -repeat @# -l[$>] -if {h>7" && "{@{-1,0-5}'=='{'"#@gmic"'}}}
    -rows 7,100% -autocrop {'" "'}  # Discard '#@gmic'.
    -if {i!={':'}} # Command declaration.
      -s -,{'": "'} -autocrop {'" "'}
      -if {@{0,t}'=='$command}
        -_document_gmic_declaration_ascii
        -if $_shortcut  # Found shortcut command.
          -v + -e[] "\n    -"$command": Equivalent to '"$_shortcutlink0"'." -v -
          -u $_shortcutlink0 -return
        -endif
        -else stopflag=1
      -endif
    -else
      -rows 1,100% # Discard ':' char.
      -if {i=={':'}} stopflag=1 # Subsection
      -else
        -autocrop {'" "'}
        -if {i=={'$'}} # Example of use.
          -rows 1,100% -autocrop {'" "'} # Discard '$' character.
          -if $_is_example -i[0] ({'"            "'})
          -else -i[0] ({'"\n        Example(s): "'}) _is_example=1 -endif
          -y[0] -a y
        -endif
        -_document_gmic_description_ascii 0
      -endif
    -endif
  -else stopflag=1 -endif ${ks{@#!=0}} -endl -if $stopflag -break -endif -done
  -v + -e[] "\n" -v - -rm
  -u ""

__help :
  -m "_help_section : -_help_section_$1 \"$""1\""
  -m "_help_paragraph : -_help_paragraph_$1 \"$""1\""
  -_help_header_$1[]
  -_help_usage[]
  -document_gmic $1,"img/",0
  -_help_examples[]
  -_help_footer_$1[]

# Commands to output help in latex format.
_help_header_latex :
  -if {narg($_gmic_is_beta)} strbeta=" (beta)" -else strbeta="" -endif
  -if {narg($_gmic_version)} strver=$_gmic_version -else strver=@{-strver} -endif
  -v + -e[] "\\documentclass[a4paper,11pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx,listings}
\n\\graphicspath{{img/}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\hoffset}{-0.8cm}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\title{\\fbox{\\parbox{\\textwidth}{\\begin{center}\\vspace*{2cm}\\includegraphics[width=12cm]{logo3.jpg}\\\\\\vspace*{1cm}{\\Huge \\textbf{The Handbook}\\\\{\\small Version "$strver$strbeta"}\\\\\\vspace*{1cm}}\\end{center}}}}
\n\\author{\\Large \\bf David Tschumperl\\'e}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\lstset{columns=fullflexible,basicstyle=\\normalfont}
\n\\begin{document}
\n\\maketitle
\n\\tableofcontents
\n\\chapter*{Preamble}
\n\\section*{License}
\nThis document is distributed under the \\textbf{GNU Free Documentation License}, version 1.3.\\\\
\nRead the full license terms at \\texttt{http://www.gnu.org/licenses/fdl-1.3.txt}.\\\\~\\\\
\nAn online version of this documentation is available at:\\\\\\texttt{http://gmic.sourceforge.net/reference.shtml}.
\n\\section*{Motivations}
\nG'MIC is an open and full-featured framework for image processing, providing several different user interfaces to
\nconvert/manipulate/filter/visualize generic image datasets, from 1d scalar signales to 3d+t sequences of multi-spectral volumetric images.
\nTechnically speaking, what it does is:
\n\\begin{itemize}
\n\\item Define a lightweight but powerful script language (the G'MIC language) dedicated to the design of image processing pipelines.
\n\\item Provide several user interfaces embedding the corresponding interpreter:
\n\\begin{itemize}
\n\\item A command-line executable 'gmic', to use the G'MIC framework from a shell.
\nIn this setting, G'MIC may be seen as a direct (and friendly) competitor of the ImageMagick or GraphicsMagick software suites.
\n\\item A plug-in 'gmic\\_gimp', to bring G'MIC capabilities to the GIMP image retouching software.
\n\\item A web-service 'G'MIC Online', to allow users applying image processing algorithms directly in a web brower.
\n\\item A Qt-based interface 'ZArt', for real-time manipulation of webcam images.
\n\\item A C++ library 'libgmic', to be linked with third-party applications.
\n\\end{itemize}
\n\\end{itemize}
\nG'MIC is focused on the design of possibly complex pipelines for converting, manipulating, filtering and visualizing generic 1d/2d/3d multi-spectral image datasets. This includes of course color images, but also more complex data as image sequences or 3d(+t) volumetric float-valued datasets.\\\\
\n
\nG'MIC is an open framework: the default language can be extended with custom G'MIC-written commands, defining thus new available image filters or effects. By the way, G'MIC already contains a substantial set of pre-defined image processing algorithms and pipelines (more than 1000).\\\\
\n
\nG'MIC has been designed with portability in mind and runs on different platforms (Windows, Unix, MacOSX). It is distributed under the CeCILL license (GPL-compatible). Since 2008, it is developed in the Image Team of the GREYC laboratory, in Caen/France, by permanent researchers working in the field of image processing on a daily basis.
\n\\section*{Version}
\n
\n gmic: GREYC's Magic for Image Computing.
\n
\n        Version "$strver$strbeta", Copyright (c) 2008-2014, David Tschumperl\\'e
\n        (http://gmic.sourceforge.net)
\n\\chapter{Usage}
"
  -v -

_help_section_latex : -skip "$1"
  -v +
  -e[] "\\section{$1}"
  -v -

_help_paragraph_latex : -skip "$1"
  -v +
  -e[] "\\small"
  -e[] "\\begin{lstlisting}"
  -e[] "$1"
  -e[] "\\end{lstlisting}"
  -e[] "\\normalsize"
  -v -

_help_footer_latex :
  -v +
  -e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
  -v -

# Commands to output help in html format.
_help_header_html :
  _section=0
  -if {narg($_gmic_is_beta)} strbeta=" (beta)" -else strbeta="" -endif
  -if {narg($_gmic_version)} strver=$_gmic_version -else strver=@{-strver} -endif
  -v +
-e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<!--#include file=\"header.html\" -->
\n<link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\">
\n<div id=\"bloc_option\">
\n<div id=\"top_rouge\"><div id=\"text_top\">Reference</div></div>
\n<div id=\"center\"><div id=\"text_centre_intro\">
\n<h2><font color=\"brown\"><u>Preamble</u></font></h2>
\n<ul>
\n<li>This document is distributed under the <a href=\"http://www.gnu.org/licenses/fdl-1.3.txt\">GNU Free Documentation License</a>, version 1.3.</li>
\n<li>A <a href=\"gmic_reference.pdf\">.pdf version</a> of this document is available.</li>
\n</ul>
\n<h2><a id=\"toc\"><font color=\"brown\"><u>Table of contents</u></font></a></h2>
\n<ul>
\n<li><a href=\"#section0\">Version</a></li>
\n<li><a href=\"#section1\">Usage</a></li>
\n<ul>
\n<li><a href=\"#section2\">Overall context</a></li>
\n<li><a href=\"#section3\">Image definition and terminology</a></li>
\n<li><a href=\"#section4\">Items of a processing pipeline</a></li>
\n<li><a href=\"#section5\">Input data items</a></li>
\n<li><a href=\"#section6\">Command items and selections</a></li>
\n<li><a href=\"#section7\">Input/output properties</a></li>
\n<li><a href=\"#section8\">Substitution rules</a></li>
\n<li><a href=\"#section9\">Mathematical expressions</a></li>
\n<li><a href=\"#section10\">Image and data viewers</a></li>
\n<li><a href=\"#section11\">Adding custom commands</a></li>
\n</ul>
\n<li><a href=\"#section12\">List of commands</a></li>
\n<ul>
\n<li><a href=\"#subsection1\">Global options</a></li>
\n<li><a href=\"#subsection2\">Inputs/outputs</a></li>
\n<li><a href=\"#subsection3\">List manipulation</a></li>
\n<li><a href=\"#subsection4\">Mathematical operators</a></li>
\n<li><a href=\"#subsection5\">Values manipulation</a></li>
\n<li><a href=\"#subsection6\">Colors manipulation</a></li>
\n<li><a href=\"#subsection7\">Geometry manipulation</a></li>
\n<li><a href=\"#subsection8\">Filtering</a></li>
\n<li><a href=\"#subsection9\">Features extraction</a></li>
\n<li><a href=\"#subsection10\">Image drawing</a></li>
\n<li><a href=\"#subsection11\">Matrix computation</a></li>
\n<li><a href=\"#subsection12\">3d rendering</a></li>
\n<li><a href=\"#subsection13\">Program controls</a></li>
\n<li><a href=\"#subsection14\">Arrays,tiles and frames</a></li>
\n<li><a href=\"#subsection15\">Artistic</a></li>
\n<li><a href=\"#subsection16\">Warpings</a></li>
\n<li><a href=\"#subsection17\">Degradations</a></li>
\n<li><a href=\"#subsection18\">Blending and fading</a></li>
\n<li><a href=\"#subsection19\">Image sequences</a></li>
\n<li><a href=\"#subsection20\">Interactive demos</a></li>
\n<li><a href=\"#subsection21\">PINK-library operators</a></li>
\n<li><a href=\"#subsection22\">Convenience functions</a></li>
\n<li><a href=\"#subsection23\">Others</a></li>
\n<li><a href=\"#subsection24\">Commands shortcuts</a></li>
\n</ul>
\n<li><a href=\"#section13\">Examples of use</a></li>
\n</ul>
\n<a id=\"section0\"><h2><font color=\"brown\"><u>Version</u></font></h2></a>
\n<pre><font color=\"blue\">gmic</font>: GREYC's Magic for Image Computing.
\n
\n       Version "$strver$strbeta", Copyright (c) 2008-2014, David Tschumperle
\n       (<a href=\"http://gmic.sourceforge.net\">http://gmic.sourceforge.net</a>)
\n</pre>
"
-v -
-_help_section "Usage"

_help_section_html :
  _section={$_section+1}
  -v +
  -e[] "<h2><a id=\"section"$_section"\"><font color=\"brown\"><u>$1</u></font></a>"\
       "&nbsp;&nbsp;<a href=\"#toc\"><img src=\"img/back_top.png\"></img></a></h2>"
  -v -

_help_paragraph_html :
  -v +
  -e[] "<pre>$*</pre>"
  -v -

_help_footer_html :
  -v +
  -e[] "
\n<br/><b><font color=\"brown\">** G'MIC comes with ABSOLUTELY NO WARRANTY; for details visit <a href=\"http://gmic.sourceforge.net\">http://gmic.sourceforge.net **</a></font></b>
\n</tt>
\n</div>
\n</div>
\n<div id=\"footer\"><img src=\"images/footer.jpg\" /></div>
\n</div>
\n<!--#include file=\"copyright.html\" -->
\n<!--#include file=\"footer.html\" -->
"
  -v -

# Commands to output help in ascii format.
_help_header_ascii :
  -__help_header_ascii
  _section=0 _space1="" _space2=" "
  -_help_section "Usage"

__help_header_ascii :
  -if {narg($_gmic_is_beta)} strbeta=" (beta)" -else strbeta="" -endif
  -if {narg($_gmic_version)} strver=$_gmic_version -else strver=@{-strver} -endif
  -v +
  -e[] "
\n gmic: GREYC's Magic for Image Computing.
\n
\n        Version "$strver$strbeta", Copyright (c) 2008-2014, David Tschumperle.
\n        (http://gmic.sourceforge.net)"
  -v -

_help_section_ascii :
  _section={$_section+1}
  {narg({'"$1"'})},1,1,1,{'-'}
  -v +
  -e[] "\n "$_section". $1"
  -e[] "    "${_space{narg({'$_section'})}}@{-1,t}"\n"
  -v -
  -rm[-1]

_help_paragraph_ascii :
  -v +
  -e[] "$*"
  -v -

_help_footer_ascii :
  -v +
  -e[] " ** G'MIC comes with ABSOLUTELY NO WARRANTY; for details visit http://gmic.sourceforge.net **"
  -v -

# Command to write general usage (used by all types of output).
_help_usage :

  -_help_paragraph " gmic [command1 [arg1_1,arg1_2,..]] .. [commandN [argN_1,argN_2,..]]
\n
\n 'gmic' is an open-source interpreter of the G'MIC language, a script-based programming
\n  language dedicated to design image processing pipelines. It can be used to convert,
\n  manipulate, filter and visualize datasets made of one or several 1d/2d or 3d multi-
\n  spectral images.
\n
\n This documentation proposes a complete description of the G'MIC language basics and rules."

  -_help_section "Overall context"

  -_help_paragraph "  - At any time, G'MIC manages one list of numbered (and optionally named) pixel-based
\n     images, entirely stored in computer memory.
\n  - The first image of the list has indice '0' and is denoted by '[0]'. The second image of
\n     the list is denoted by '[1]', the third by '[2]' and so on.
\n  - Negative indices are treated in a cyclic way: '[-1]' refers to the last image of the
\n     list, '[-2]' to the penultimate one, etc. Thus, if the list has 4 images, '[1]' and '[-3]'
\n     both designate the second image of the list.
\n  - A named image may be denoted by '[name]' if 'name' uses characters set [a-zA-Z0-9_] and
\n     does not start with a number. Image names can be set or reassigned at any moment during
\n     the processing pipeline (see commands '-name' and '-input').
\n  - G'MIC defines a set of various commands and substitution mechanisms to allow the design
\n     of complex pipelines managing this list of images, in a very flexible way:
\n     You can insert or remove images in the list, rearrange image indices, process images
\n     (individually or as a group), merge image data together and output image files.
\n  - Such a pipeline can be written itself as a custom G'MIC command storable in a custom
\n     commands file, which can be re-used afterwards in another bigger pipeline if necessary."

  -_help_section "Image definition and terminology"

  -_help_paragraph "  - In G'MIC, an image is modeled as a 1d, 2d, 3d or 4d array of scalar values, uniformly
\n     discretized on a rectangular/parallelepipedic domain.
\n  - The four dimensions of these arrays are respectively denoted by:
\n    . 'width', the number of image columns (size along the 'x'-axis).
\n    . 'height', the number of image rows (size along the 'y'-axis).
\n    . 'depth', the number of image slices (size along the 'z'-axis).
\n        The depth is equal to 1 for usual 2d color or grayscale images.
\n    . 'spectrum', the number of image channels (size along the 'c'-axis).
\n        The spectrum is respectively equal to 3 and 4 for usual RGB and RGBA color images.
\n  - There are no size limitations on each image dimensions. Particularly, the number of image
\n     slices or channels can be of arbitrary size within the limits of available memory.
\n  - The width, height and depth of an image are considered as 'spatial' dimensions, while the
\n     spectrum has a 'multi-spectral' meaning. Thus, a 4d image in G'MIC should be most often
\n     regarded as a 3d dataset of multi-spectral voxels. Most of the G'MIC commands will stick
\n     with this idea (e.g. command '-blur' will blur images only along the 'xyz' axes).
\n  - All pixel values of all images of the list have the same datatype. It can be one among:
\n    . 'bool': Stands for 'boolean'. Value range is { 0=false | 1=true }.
\n    . 'uchar': Stands for 'unsigned char'. Value range is [0,255] (8bits).
\n        This type of pixel coding is commonly used to store 8bits/channels RGB[A] images.
\n    . 'char': Value range is [-128,127] (8bits).
\n    . 'ushort': Stands for 'unsigned short'. Value range is [0,65535] (16bits).
\n        This type of pixel coding is commonly used to store 16bits/channels RGB[A] images.
\n    . 'short': Value range is [-32768,32767] (16bits).
\n    . 'uint': Stands for 'unsigned int'. Value range is [0,2^32-1] (32bits).
\n    . 'int': Value range is [-2^31,2^31-1] (32 bits).
\n    . 'float': Value range is [-3.4E38,+3.4E38] (32bits).
\n        This type of coding is able to store pixels as 32 bits float-valued numbers. This is
\n        the default datatype used by G'MIC image processing operations.
\n    . 'double': Value range is [-1.7E308,1.7E308] (64bits).
\n        This type of coding is able to store pixels as 64 bits float-valued numbers.
\n  - Considering pixel datatypes different than 'float' is generally useless, except to force
\n     the input/output of image data to a prescribed binary format. Hence, most G'MIC image
\n     image processing commands are available only for the default 'float' pixel datatype
\n     (see command '-type' if you need to switch to another pixel datatype)."

  -_help_section "Items of a processing pipeline"

  -_help_paragraph "  - In G'MIC, an image processing pipeline is described as a sequence of items separated by
\n     the space character ' '. Such items are interpreted and executed from the left to the
\n     right. For instance, the expression:
\n       'input.jpg -blur 3,0 -sharpen 10 -resize 200%,200% -output output.jpg'
\n     defines a valid pipeline composed of nine G'MIC items.
\n  - A G'MIC item is a string which represents either a command, a set of command arguments,
\n     a filename, or a special input string.
\n  - Escape characters '\\' and double quotes '\"' can be used (as usual) to define items
\n     containing spaces, or any other character sequences. For instance, the strings
\n     'single\\ item' and '\"single item\"' define the same string item, with a space in it."

  -_help_section "Input data items"

  -_help_paragraph "  - If a specified G'MIC item appears to be an existing filename, the corresponding image
\n     data are loaded and inserted at the end of the image list.
\n  - Special filenames '-' and '-.ext' stand for the standard input/output streams, optionally
\n     forced to be in a specific 'ext' file format (e.g. '-.jpg' or '-.png').
\n  - The following special input strings may be used as G'MIC items to create and insert new
\n     images with prescribed values, at the end of the image list:
\n    . '[selection]' or '[selection]xN': Insert 1 or N copies of selected existing images.
\n       'selection' may contain one or several images (see next section for details).
\n    . 'width[%],_height[%],_depth[%],_spectrum[%],_values': Insert a new image with
\n       specified size and values (adding '%' to a dimension means 'percentage of the size
\n       along the same axis, taken from the last image '[-1]''). Any specified dimension
\n       can be also written as '[image]', and is then set to the size (along the same axis)
\n       of the existing specified image [image]. 'values' can be either a sequence of numbers
\n       separated by commas ',', or a mathematical expression, as e.g. in input item
\n       '256,256,1,3,if(c==0,x,if(c==1,y,0))' which creates a 256x256 RGB color image with a
\n       spatial shading on the red and green channels.
\n    . '(v1,v2,..)': Insert a new image from specified prescribed values.
\n       Value separator inside parentheses can be ',' (column separator.), ';' (row sep.),
\n       '/' (slice sep.) or '^' (channel sep.). For instance, expression
\n       '(1,2,3;4,5,6;7,8,9)' creates a 3x3 matrix (scalar image), with values from 1 to 9.
\n    . '0': Insert a new 'empty' image, containing no pixel data. Empty images are used only
\n       in rare occasions.
\n  - Input item 'name=value' declares a new local or global variable 'name', or assign a new
\n     value to an existing variable. Variable names use characters set [a-zA-Z0-9_] and cannot
\n     start with a number. A variable definition is always local to the current command except
\n     when it starts by the underscore character '_'. In that case, it becomes also accessible
\n     by any command invoked outside the current command scope."

  -_help_section "Command items and selections"

  -_help_paragraph "  - A G'MIC item starting by '-' designates a command, most of the time. Generally, commands
\n     perform image processing operations on one or several available images of the list.
\n  - Common commands have two equivalent names (regular and short). For instance, command
\n     names '-resize' and '-r' refer to the same image resizing action.
\n  - A G'MIC command may have mandatory or optional arguments. Command arguments must be
\n     specified in the next item on the command line. Commas ',' are used to separate multiple
\n     arguments, if any required.
\n  - The execution of a G'MIC command may be restricted only to a subset of the image list, by
\n     appending '[subset]' to the command name. Examples of valid syntaxes for 'subset' are:
\n    . '-com[0,1,3]': Apply command only on images [0],[1] and [3].
\n    . '-com[3-5]': Apply command only on images [3] to [5] (i.e, [3],[4] and [5]).
\n    . '-com[50%-100%]': Apply command only on the second half of the image list.
\n    . '-com[0,-4--1]': Apply command only on the first and the four latest images.
\n    . '-com[0-9:3]': Apply command only on images [0] to [9], with a step of 3
\n                      (i.e. on images [0], [3], [6] and [9]).
\n    . '-com[0--1:2]': Apply command only on images of the list with even indices.
\n    . '-com[0,2-4,50%--1]': Apply command on images [0],[2],[3],[4] and on the second half
\n                             of the image list.
\n    . '-com[^0,1]': Apply command on all images except the first two.
\n    . '-com[name1,name2]': Apply command on named images 'name1' and 'name2'.
\n  - Indices in selections are always sorted in increasing order, and duplicate indices are
\n     discarded. For instance, selections '[3-1,1-3]' and '[1,1,1,3,2]' are both equivalent to
\n     '[1-3]'. If you want to repeat a single command multiple times on an image, use a
\n     '-repeat..-done' loop. Inverting the order of images in a selection can be achieved by
\n     inverting first the order of the images in the list, with command '-reverse[selection]'.
\n  - G'MIC commands invoked without '[subset]' are applied on all images of the list.
\n  - A G'MIC command starting with '--' instead of '-' does not act 'in-place' but inserts its
\n     result as one or several new images at the end of the image list.
\n  - There are two different types of commands that can be run by the G'MIC interpreter:
\n    . Native commands, are hard-coded functionalities in the interpreter core.
\n       They are thus compiled as machine code and run quickly, most of the time.
\n       Omitting an argument when invoking a native command is not permitted, except if all
\n       following arguments are also omitted. For instance, call to '-plasma 10,,5' is invalid
\n       but '-plasma 10' is correct.
\n    . Custom commands, are defined as G'MIC pipelines of native or custom commands.
\n       They are interpreted by the G'MIC interpreter, and run slower than native commands.
\n       But omitting arguments when invoking a custom command is permitted. For instance,
\n       expressions '-flower ,,,100,,2' or '-flower ,' are correct.
\n  - A user may easily add its own custom commands to the G'MIC interpreter (see section
\n     'Adding custom commands'). Native commands cannot be added unless you modify the G'MIC
\n     interpreter source code."

  -_help_section "Inputs/outputs properties"

  -_help_paragraph "  - G'MIC is able to read/write most of the classical image file formats, including:
\n    . 2d grayscale/color files: .png, .jpeg, .gif, .pnm, .tif, .bmp, ..
\n    . 3d volumetric files: .dcm, .hdr, .nii, .pan, .inr, .pnk, ..
\n    . Image sequences: .mpeg, .avi, .mov, .ogg, .flv, ..
\n    . Generic ascii or binary data files: .cimg, .cimgz, .dlm, .asc, .pfm, .raw, .txt, .h.
\n    . 3d object files: .off.
\n  - When dealing with color images, G'MIC generally reads, writes and displays data using the
\n     usual RGB color space.
\n  - G'MIC is able to manage 3d objects that may be read from files or generated by G'MIC
\n     commands. They are stored as one-column scalar images containing the object data, in the
\n     following order: { magic_number; sizes; vertices; primitives; colors; opacities }.
\n     These 3d representations can be processed as regular float-valued images.
\n     (see command '-split3d' for accessing each of these 3d object data separately).
\n  - Be aware that usual file formats may be sometimes not adapted to store all the available
\n     image data, since G'MIC uses float-valued coding of image pixels. For instance, saving
\n     an image that was initially loaded as a 16bits/channel image, as a .jpg file will result
\n     in loss of information. Use the .cimg file extension (or .cimgz, its compressed
\n     version) to ensure that all data precision will be preserved when saving images.
\n  - File options can/must be set for these specific file formats:
\n    . Video files: Only sub-frames of an image sequence may be loaded, using the input
\n       expression 'filename.ext,[first_frame[%][,last_frame[%][,step]]]'.
\n       Output framerate and bitrate (in Kb/s) can be also set by using the output expression
\n       'file.mpg,_fps,_bitrate'.
\n    . .cimg files : Only crops and sub-images of .cimg files can be loaded, using the input
\n      expressions 'filename.cimg,N0,N1', 'filename.cimg,N0,N1,x0,x1',
\n      'filename.cimg,N0,N1,x0,y0,x1,y1', 'filename.cimg,N0,N1,x0,y0,z0,x1,y1,z1',
\n      'filename.cimg,N0,N1,x0,y0,z0,c0,x1,y1,z1,c1'.
\n      Specifying '-1' for one coordinates stands for the maximum possible value.
\n    . .raw binary files: Image dimensions and input pixel type may be specified when loading
\n       .raw files with input expresssion 'filename.raw[,type][,width][,height[,depth[,dim]]]]'.
\n       If no dimensions are specified, the resulting image is a one-column vector with
\n       maximum possible height. Pixel type can also be specified with the output
\n       expression 'file.raw[,type]'.
\n       'type' can be { bool | uchar | char | ushort | short | uint | int | float | double }.
\n    . .yuv files: Image dimensions must be specified, and only sub-frames of an image
\n       sequence may be loaded, using the input expression
\n      'filename.yuv,width,height[,first_frame[,last_frame[,step]]]'.
\n    . .tiff files: Only sub-images of multi-pages tiff files can be loaded, using the input
\n       expression 'filename.tif,[first_frame,[last_frame,[step]]]'.
\n    . .gif files: Animated gif files can be saved, using the input expression
\n      'filename.gif,fps,nb_loops'.
\n      Specify 'nb_loops=0' to get an infinite number of animation loops.
\n    . .jpeg files: The output quality may be specified (in %), using the output expression
\n       'filename.jpg,30' (here, to get a 30% quality output).
\n    . .mnc files: The output header can set from another file, using the output expression
\n       'filename.mnc,header_template.mnc'.
\n    . .gmic files: These filenames are assumed to be G'MIC custom commands files. Loading
\n       such a file will add the commands it defines to the interpreter. Debug infos can be
\n       enabled/disabled by the input expression 'filename.gmic,add_debug_infos={ 0 | 1 }'.
\n    . Inserting 'ext:' on the beginning of a filename (e.g. 'jpg:filename') forces G'MIC to
\n       read/write the file as it would have been done if it had the specified extension.
\n  - Some input/output formats and options may not be supported by your current version of
\n     'gmic', depending on the configuration flags set for the build of the 'gmic' binaries."

  -_help_section "Substitution rules"

  -_help_paragraph "  - G'MIC items containing '@', '$' or '{}' may be substituted before being interpreted. Use
\n     the substituting expressions below to access data from the interpreter environment:
\n    . '@#' is substituted by the current number of images in the list.
\n    . '@*' is substituted by the number of available cpus.
\n    . '@.' is substituted by the current version number of the G'MIC interpreter
\n    . '@^' is substituted by the current verbosity level.
\n    . '@%' is substituted by the pid of the current process.
\n    . '@|' is substituted by the current value (expressed in seconds) of a millisecond
\n       precision timer.
\n    . '@?' is substituted by the current data type of image pixels.
\n    . '@/' is substituted by the current number of levels in the command scope.
\n    . '@{/}' or '@{/,subset}' are substituted by the content of the global scope, or a
\n       subset of it. If specified subset refers to multiple scope items, they are separated
\n       by slashes '/'.
\n    . '@>' and '@<' are equivalent. They are both substituted by the number of nested
\n       'repeat-done' loops that are currently running.
\n    . '@{>}' or '@{>,subset}' are substituted by the indice values (or a subset of them) of
\n       the running 'repeat-done' loops, expressed in the ascending order, starting from 0.
\n       If specified subset refers to multiple indices, they are separated by commas ','.
\n    . '@{<}' or '@{<,subset}' do the same but in descending order.
\n    . '@indice' or '@{indice,feature}' are substituted by the list of pixel values of the
\n       image [indice] (separated by commas), or by a specific feature (or subset) of it.
\n       'indice' can be an indice or an image name. Requested 'featured' can be one of:
\n         . 'w': image width (number of image columns).
\n         . 'h': image height (number of image rows).
\n         . 'd': image depth (number of image slices).
\n         . 's': image spectrum (number of image channels).
\n         . 'wh': image width x image height.
\n         . 'whd': image width x image height x image depth.
\n         . 'whds': image width x image height x image depth x image spectrum.
\n                   (i.e. number of values in the specified image, eq. to '#').
\n         . 'r': image shared state (1, if the pixel buffer is shared, 0 otherwise).
\n         . 'n': image name or filename (if the image has been read from a file).
\n         . 'b': image basename (i.e. filename without the folder path nor extension).
\n         . 'x': image extension (i.e last characters after the last '.' in the filename).
\n         . 'f': image folder name.
\n         . '#': number of image values (i.e. width x height x depth x spectrum).
\n         . '+': sum of all pixel values.
\n         . '-': difference of all pixel values.
\n         . '*': product of all pixel values.
\n         . '/': quotient of all pixel values.
\n         . 'm': minimum pixel value.
\n         . 'M': maximum pixel value.
\n         . 'a': average pixel value.
\n         . 'v': variance of pixel values.
\n         . 't': text string built from the image values, regarded as ascii codes.
\n         . 'c': (x,y,z,c) coordinates of the minimum value, separated by commas ','.
\n         . 'C': (x,y,z,c) coordinates of the maximum value, separated by commas ','.
\n         . '(x[%],_y[%],_z[%],_c[%],_boundary)': pixel value at (x[%],y[%],z[%],c[%]), with
\n            specified boundary conditions { 0=dirichlet | 1=neumann | 2=cyclic }.
\n         . Any other 'feature' is considered either as a specified subset of image values, or
\n            as a mathematical expression to evaluate (associated to selected image).
\n            For instance, '@{-1,0-50%}' is substituted by the sequence of numerical values
\n            coming from the first half data of the last image, separated by commas ','.
\n            Expression '@{0,w+h}' is substituted by the sum of the width and height of the
\n            first image.
\n    . '@!' is substituted by the visibility state of the instant display window [0]
\n       (can be { 0=closed | 1=visible }).
\n    . '@{!,feature}' or '@{!indice,feature}' is substituted by a specific feature of the
\n       instant display window [0] (or [indice], if specified). Requested 'feature' can be:
\n         . 'w': display width (i.e. width of the display area managed by the window).
\n         . 'h': display height (i.e. height of the display area managed by the window).
\n         . 'wh': display width x display height.
\n         . 'd': window width (i.e. width of the window widget).
\n         . 'e': window height (i.e. height of the window widget).
\n         . 'de': window width x window height.
\n         . 'u': screen width (actually independent on the window size).
\n         .' v': screen height (actually independent on the window size).
\n         . 'uv': screen width x screen height.
\n         . 'x': X-coordinate of the mouse position (or -1, if outside the display area).
\n         . 'y': Y-coordinate of the mouse position (or -1, if outside the display area).
\n         . 'b': state of the mouse buttons { 1=left-but. | 2=right-but. | 4=middle-but. }.
\n         . 'o': state of the mouse wheel.
\n         . 'k': decimal code of the pressed key if any, 0 otherwise.
\n         . 'n': current normalization type of the instant display.
\n         . 'c': boolean (0 or 1) telling if the instant display has been closed recently.
\n         . 'r': boolean telling if the instant display has been resized recently.
\n         . 'm': boolean telling if the instant display has been moved recently.
\n         . Any other 'feature' stands for a keycode name in capital letters, and is substi-
\n            tuted by a boolean describing the current key state { 0=pressed | 1=released }.
\n    . '@{\"command line\"}' is substituted by the status value set by the execution of the
\n       specified command line (see command '-status').
\n    . Expression '@{}' stands thus for the current status value.
\n  - '$name' and '${name}' are both substituted by the value of the specified named variable
\n     (set previously by item 'name=value'), or by the current positive indice of the named
\n     image '[name]', or by the value of the named OS environment variable (in this order).
\n  - '$>' and '$<' (resp. '${>}' and '${<}') are shortcuts respectively for '@{>,-1}' and
\n     '@{<,-1}'. They refer to the increasing/decreasing indice of the latest (currently
\n     running) 'repeat..done' loop.
\n  - Any other expression inside braces (as in '{expression}') is considered as a mathematical
\n     expression, and is evaluated, except for the three following cases:
\n    . If expression starts and ends by single quotes, it is substituted by the sequence of
\n       ascii codes that composes the specified string, separated by commas ','. For instance,
\n       item '{'foo'}' is substituted by '102,111,111'.
\n    . If expression starts and ends with backquotes '`', it is substituted by the string
\n       whose ascii codes are given by the list of values in between the backquotes.
\n       For instance, item '{`102,111,111`}' is substituted by 'foo'.
\n    . If expression contains operator ''=='' or ''!='', it is substituted by 0 or 1, whether
\n       the strings beside the operator are the same or not (case-sensitive). For instance,
\n       both items '{foo'=='foo}' and '{foo'!='FOO}' are substituted by '1'.
\n    . If expression starts with an underscore '_', it is substituted by the mathematical
\n       evaluation of the expression, truncated to a readable format.
\n  - Item substitution is never done in items between double quotes. One must break the quotes
\n    to enable substitution if needed, as in \"3+8 kg = \"{3+8}\" kg\". Using double quotes
\n    is then a convenient way to disable the substitutions mechanism in items, when necessary.
\n  - One can also disable the substitution mechanism on items outside double quotes, by
\n     escaping the '@','{','}' or '$' characters, as in '\\{3+4\\}\\ doesn't\\ evaluate'."

  -_help_section "Mathematical expressions"

  -_help_paragraph "  - G'MIC has an embedded mathematical parser. It is used to evaluate expressions inside
\n     braces '{}', or formulas in commands that may take one as an argument (e.g. '-fill').
\n  - When used in commands, a formula is evaluated for each pixel of the selected images.
\n  - The mathematical parser understands the following set of functions, operators and variables:
\n    _ Usual operators: || (logical or), && (logical and), | (bitwise or), & (bitwise and),
\n       !=, ==, <=, >=, <, >, << (left bitwise shift), >> (right bitwise shift), -, +, *, /,
\n       % (modulo), ^ (power), ! (logical not), ~ (bitwise not).
\n    _ Usual functions: sin(), cos(), tan(), asin(), acos(), atan(), sinh(), cosh(), tanh(),
\n       log(), log2(), log10(), exp(), sign(), abs(), atan2(), round(), narg(), arg(),
\n       isval(), isnan(), isinf(), isint(), isbool(), rol() (left bit rotation),
\n       ror() (right bit rotation), min(), max(), sinc(), int().
\n       Function 'atan2()' is the version of atan() with two arguments 'y,x' (as in C/C++).
\n       Function 'narg()' returns the number of specified arguments.
\n       Function 'arg(i,a_1,..,a_n)' returns the ith argument a_i.
\n       Functions 'min()' and 'max()' can be called with an arbitrary number of arguments.
\n       Functions 'isval()', 'isnan()', 'isinf()', 'isbool()' can be used to test the type of
\n       a given number or expression.
\n    _ The variable names below are pre-defined. They can be overloaded if necessary.
\n         . 'w': width of the associated image, if any (0 otherwise).
\n         . 'h': height of the associated image, if any (0 otherwise).
\n         . 'd': depth of the associated image, if any (0 otherwise).
\n         . 's': spectrum of the associated image, if any (0 otherwise).
\n         . 'x': current processed column of the associated image, if any (0 otherwise).
\n         . 'y': current processed row of the associated image, if any (0 otherwise).
\n         . 'z': current processed slice of the associated image, if any (0 otherwise).
\n         . 'c': current processed channel of the associated image, if any (0 otherwise).
\n         . 'e': value of e, i.e. 2.71828..
\n         . 'pi': value of pi, i.e. 3.1415926..
\n         . '?' or 'u': a random value between [0,1], following a uniform distribution.
\n         . 'g': a random value, following a gaussian distribution of variance 1
\n            (roughly in [-5,5]).
\n         . 'i': current processed pixel value (i.e. value located at (x,y,z,c)) of the
\n            associated image, if any (0 otherwise).
\n         . 'im','iM','ia','iv': Respectively the minimum, maximum, average values and
\n            variance of the associated image, if any (0 otherwise).
\n         . 'xm','ym','zm','cm': The pixel coordinates of the minimum value in the associated
\n            image, if any (0 otherwise).
\n         . 'xM','yM','zM','cM': The pixel coordinates of the maximum value in the
\n            associated image, if any (0 otherwise).
\n    _ These special operators can be used:
\n         . ';': expression separator. The returned value is always the last encountered
\n            expression. For instance expression '1;2;pi' is evaluated as 'pi'.
\n         . '=': variable assignment. Variables in mathematical parser can only refer to.
\n            numerical values. Variable names are case-sensitive. Use this operator in
\n            conjunction with ';' to define complex evaluable expressions, such as
\n             't=cos(x);3*t^2+2*t+1'.
\n            These variables remain local to the mathematical parser and cannot be accessed
\n            outside the evaluated expression.
\n    _ The following specific functions are also defined:
\n         . 'if(expr_cond,expr_then,expr_else)': return value of 'expr_then' or 'expr_else',
\n            depending on the value of 'expr_cond' (0=false, other=true). For instance,
\n            G'MIC command '-fill if(x%10==0,255,i)' will draw blank vertical lines on every
\n            10th column of an image.
\n         . '?(max)' or '?(min,max)': return a random value between [0,max] or [min,max],
\n            following a uniform distribution. 'u(max)' and 'u(0,max)' mean the same.
\n         . 'i(_a,_b,_c,_d,_interpolation,_boundary)': return the value of the pixel located
\n            at position (a,b,c,d) in the associated image, if any (0 otherwise).
\n            Interpolation parameter can be { 0=nearest neighbor | other=linear }.
\n            Boundary conditions can be { 0=dirichlet | 1=neumann | 2=cyclic }.
\n            Omitted coordinates are replaced by their default values which are respectively
\n            x, y, z, c and 0.
\n         . 'j(_dx,_dy,_dz,_dc,_interpolation,_boundary)': does the same for the pixel located
\n            at position (x+dx,y+dy,z+dz,c+dc).
\n         . 'i[offset]': return the value of the pixel located at specified offset in the associated
\n            image buffer.
\n         . 'j[offset]': does the same for an offset relative to the current pixel (x,y,z,c).
\n            For instance command '-fill 0.5*(i(x+1)-i(x-1))' will estimate the X-derivative
\n            of an image with a classical finite difference scheme.
\n         . If specified formula starts with '>' or '<', the operators 'i(..)' and 'j(..)' will return
\n            values of the image currently being modified, in forward ('>') or backward ('<') order.
\n  - The last image of the list is always associated to the evaluations of '{expressions}',
\n     e.g. G'MIC sequence '256,128 -f {w}' will create a 256x128 image filled with value 256."

  -_help_section "Image and data viewers"

  -_help_paragraph "  - G'MIC has some very handy embedded visualization modules, for 1d signals
\n     (command '-plot'), 1d/2d/3d images (command '-display') and 3d objects
\n     (command '-display3d'). It enables an interactive view of the selected image data.
\n  - The following keyboard shortcuts are available in the interactive viewers:
\n    . CTRL+D: Increase window size.
\n    . CTRL+C: Decrease window size.
\n    . CTRL+R: Reset window size.
\n    . CTRL+F: Toggle fullscreen mode.
\n    . CTRL+S: Save current window snapshot as numbered file 'gmic_xxxx.bmp'.
\n    . CTRL+O: Save current instance of the viewed data, as numbered file 'gmic_xxxx.cimgz'.
\n  - Shortcuts specific to the 1d/2d/3d image viewer are:
\n    . CTRL+A: Switch cursor mode.
\n    . CTRL+P: Play z-stack of frames as a movie (for volumetric 3d images).
\n    . CTRL+V: Show/hide 3D view (for volumetric 3d images).
\n    . CTRL+(mousewheel): Zoom in/out.
\n    . SHIFT+(mousewheel): Go left/right.
\n    . ALT+(mousewheel): Go up/down.
\n    . Numeric PAD: Zoom in/out (+/-) and move through zoomed image (digits).
\n    . BACKSPACE: Reset zoom scale.
\n  - Shortcuts specific to the 3d object viewer are:
\n    . (mouse)+(left mouse button): Rotate 3d object.
\n    . (mouse)+(right mouse button): Zoom 3d object.
\n    . (mouse)+(middle mouse button): Shift 3d object.
\n    . (mousewheel): Zoom in/out.
\n    . CTRL+F1 .. CTRL+F6: Switch between different 3d rendering modes.
\n    . CTRL+Z: Enable/disable z-buffered rendering.
\n    . CTRL+A: Show/hide 3d axes.
\n    . CTRL+G: Save 3d object, as numbered file 'gmic_xxxx.off'.
\n    . CTRL+T: Switch between single/double-sided 3d modes."

  -_help_section "Adding custom commands"

  -_help_paragraph "  - Custom commands can be defined by a user, through the use of G'MIC custom commands files.
\n  - A command file is a simple ascii text file, where each line starts either by
\n     'command_name: command_definition' or 'command_definition (continuation)'.
\n  - Custom command names must use characters [a-zA-Z0-9_] and cannot start with a number.
\n  - Any ' \# comment' expression found in a custom commands file is discarded by the G'MIC
\n     interpreter, wherever it is located in a line.
\n  - In custom commands, the following $-expressions are substituted:
\n    . '$""*' is substituted by a copy of the specified string of arguments.
\n    . '$\"*\"' is substituted by a copy of the specified string of arguments, each being around double quotes.
\n    . '$""#' is substituted by the maximum indice of known arguments (either specified by the
\n       user or set to a default value in the custom command).
\n    . '$""?' is substituted by a string telling about the command subset restriction (only
\n       useful when custom commands need to output descriptive messages).
\n    . '$i' and '${i}' are both substituted by the i-th specified argument. Negative indices
\n       such as '${-j}' are allowed and refer to the j^th latest argument. '$""0' is substituted
\n       by the custom command name.
\n    . '${i=default}' is substituted by the value of $i (if defined) or by its new value set
\n        to 'default' otherwise ('default' may be a $-expression as well).
\n    . '${subset}' is substituted by the arguments values (separated by commas ',') of a
\n       specified argument subset. For instance expression '$""{2--2}' is substitued by all
\n       specified arguments except the first and the last one. Expression '$""{^0}' is then
\n       substituted by all arguments of the invoked command (eq. to '$""*' if all specified
\n       arguments have indeed a value).
\n    . '$""=var' is substituted by the set of instructions that will assign each argument $i
\n       to the named variable 'var$i' (for i in [0..$""#]). This is particularly useful when a
\n       custom command want to manage variable numbers of arguments. Variables names must
\n       use characters [a-zA-Z0-9_] and cannot start with a number.
\n  - These particular $-expressions are always substituted, even in double quoted items or
\n     when the dollar sign '$' is escaped with a backslash '\\'. To avoid substitution, place
\n     an empty double quoted string just after the '$' (as in '$\"\"1').
\n  - Specifying arguments may be skipped when invoking a custom command, by replacing them by
\n     commas ',' as in expression '-flower ,,3'. Omitted arguments are set to their default
\n     values, which must be thus explicitly defined in the code of the corresponding custom
\n     command (using default argument expressions as '$""{1=default}').
\n  - If one numbered argument requested in a custom command has no value, an error is thrown
\n     by the interpreter."

  -_help_section "List of commands"

  -_help_paragraph " All available G'MIC commands are listed below, classified by themes.
\n When several choices of command arguments are possible, they appear separated by '|'.
\n An argument specified inside '[]' or starting by '_' is optional except when standing for an
\n existing image [image], where 'image' can be either an indice number or an image name.
\n In this case, the '[]' characters are mandatory when writing the item. A command marked with
\n '(*)' or '(+)' is a native command. '(*)' means the command is available for all pixel types,
\n otherwise only for the default 'float' pixel type.
\n Remember that native commands run faster than custom commands, so use then when possible.
\n Note also that all images in this reference documentation are normalized in [0,255] before
\n being displayed. You may need to do this manually (command '-normalize 0,255') if you want
\n save image files having the same aspect than those displayed."

_help_examples :
  -_help_section "Examples of use"

  -_help_paragraph " 'gmic' is a generic image processing tool which can be used in a wide variety of situations.
\n The few examples below illustrate possible uses of this tool:
\n
\n  - View a list of images:
\n     gmic file1.bmp file2.jpeg
\n
\n  - Convert an image file:
\n     gmic input.bmp -o output.jpg
\n
\n  - Create a volumetric image from a movie sequence:
\n     gmic input.mpg -a z -o output.hdr
\n
\n  - Compute image gradient norm:
\n     gmic input.bmp -gradient_norm
\n
\n  - Denoise a color image:
\n     gmic image.jpg -denoise 30,10 -o denoised.jpg
\n
\n  - Compose two images using overlay layer blending:
\n     gmic image1.jpg image2.jpg -blend overlay -o blended.jpg
\n
\n  - Evaluate a mathematical expression:
\n     gmic -e \"cos(pi/4)^2+sin(pi/4)^2={cos(pi/4)^2+sin(pi/4)^2}\"
\n
\n  - Plot a 2d function:
\n     gmic 1000,1,1,2 -f \"X=3*(x-500)/500;X^2*sin(3*X^2)+if(c==0,u(0,-1),cos(X*10))\" -plot
\n
\n  - Plot a 3d elevated function in random colors:
\n     gmic 128,128,1,3,\"?(0,255)\" -plasma 10,3 -blur 4 -sharpen 10000 \\
\n      -elevation3d[-1] \"'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'\"
\n
\n  - Plot the isosurface of a 3d volume:
\n     gmic -m3d 5 -md3d 5 -db3d 0 -isosurface3d \"'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))'\",3
\n
\n  - Render a G'MIC 3d logo:
\n     gmic 1 -text G\\'MIC,0,0,57,1,1,1,1 -expand_xy 10,0 -blur 2 -n 0,100 --plasma 0.4 -+ \\
\n      -blur 1 -elevation3d -0.1 -md3d 4
\n
\n  - Generate a 3d ring of torii:
\n     gmic -repeat 20 -torus3d 15,2 -col3d[-1] \"{?(60,255)},{?(60,255)},{?(60,255)}\" \\
\n      -*3d[-1] 0.5,1 -if \"{$>%2}\" -r3d[-1] 0,1,0,90 -endif -+3d[-1] 70 -+3d \\
\n      -r3d 0,0,1,18 -done -md3d 3 -m3d 5 -db3d 0
\n
\n  - Create a vase from a 3d isosurface:
\n     gmic -md3d 4 -isosurface3d \"'x^2+2*abs(y/2)*sin(2*y)^2+z^2-3',0\" -sphere3d 1.5 \\
\n      --3d[-1] 0,5 -plane3d 15,15 -r3d[-1] 1,0,0,90 -c3d[-1] -+3d[-1] 0,3.2 \\
\n      -col3d[-1] 180,150,255 -col3d[-2] 128,255,0 -col3d[-3] 255,128,0 -+3d
\n
\n  - Display filtered webcam stream:
\n     gmic -apply_camera \\\"--mirror x --mirror y -+ -/ 4\\\"
\n
\n  - Launch a set of G'MIC interactive demos:
\n     gmic -demo
\n"

#@gmic version
#@gmic : Display current version number and exit.
version :
  -v - -__help_header_ascii[] -v +
  -e[] ""

#-------------------------------
#
#@gmic :: Inputs/outputs
#
#-------------------------------

#@gmic apply_camera : _command,_camera_index>=0,_skip_frames>=0,_output_filename
#@gmic : Apply specified command on live camera stream, and display it on display window [0].
#@gmic : Default values: 'command=""', 'camera_index=0' (default camera), 'skip_frames=0' and 'filename=""'.
apply_camera : -skip "${1=},${4=}" -check "${2=0}>=0 && ${3=0}>=0"
  -e[^-1] "Apply command '$1' on camera stream \#$2, with $3 frames skip and filename '$4'." -v -
  -l[] frame=0 -do
    -camera $2,1,$3 $1 -w[-1] -1,-1,"(Camera "$stream", "{w}x{h}")"
    -if {narg("$4")} -o[-1] @{-filename\ "$4",$frame} frame={$frame+1} -endif
    -if @{!,S} -o[-1] gmic_camera.png -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif # Increase window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif # Decrease window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif             # Reset window size.
    -rm[-1]
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}} -endl -v +

#@gmic apply_files : "command",list_of_filenames,_output_prefix,_view_window={ 0 | 1 }
#@gmic : Apply specified command on all specified image files, by reading them one by one,
#@gmic : and save result by appending 'output_prefix' to each original filename.
#@gmic : 'list_of_filenames' must be the list of filenames, separated by space.
#@gmic : Thus, a specified filename cannot contain a spaces.
#@gmic : Default value: 'output_prefix=gmic_' and 'view_window=0'.
apply_files : -skip "${3=gmic_}",${4=0}
  -v -
  ({'"$2"'}) -autocrop[-1] 32 -replace[-1] 32,{','} files=@{-1,t}
  -if {w>128} -z[-1] 0,127 s_files=@{-1,t}... -else s_files=$files -endif
  -rm[-1]
  -m "_apply_files : $""=_file _nb_files=$""#" -_apply_files $files -uncommand _apply_files
  -m "_apply_files : $1"
  -v + -e[^-1] "Apply command '$1' on files '"$s_files"' and save result with prefix '$3'.\n" -v -
  -repeat $_nb_files -l[]
    file=${_file{$>+1}}
    _file=@{-basename\ $file}
    -v + -e[] "\r - Image "{1+$>}/$_nb_files" ["$_file"]        " -v -
    $file -_apply_files
    -o "$3"$_file
    -if $4 -w[-1] @{-fitscreen\ {w},{h},{d}},1,0,-1,-1,$_file -endif
    -rm
  -onfail -v + -e[] "\n - Error occured on file '"$file"'.\n" -v -
  -endl -done -uncommand _apply_files -v +

#@gmic camera : _camera_index>=0,_nb_frames>0,_skip_frames>=0,release_camera={ 0 | 1 },_capture_width>=0,_capture_height>=0 : (*)
#@gmic : Insert one or several frames from specified camera, with custom delay between frames (in ms).
#@gmic : When 'release_camera==1', the camera stream is released instead of capturing new images.
#@gmic : Default values: 'camera_index=0' (default camera), 'nb_frames=1', 'skip_frames=0', 'release_camera=0' and 'capture_width=capture_height=0' (default size).

#@gmic m : eq. to '-command'. : (*)

#@gmic command : _add_debug_info={ 0 | 1 },{ filename | http[s]://URL | "string" } : (*)
#@gmic : Import G'MIC custom commands from specified file, URL or string.
#@gmic : (eq. to '-m').
#@gmic : Imported commands are available directly after the '-command' invocation.
#@gmic : Default value: 'add_debug_info=1'.
#@gmic : $ image.jpg -command "foo : -mirror y -deform $""1" --foo[0] 5 --foo[0] 15

#@gmic cupid : _size>0
#@gmic : Input cupid binary mask with specified size.
#@gmic : $ -cupid ,
cupid : -check "${1=480}>=1"
  -e[^-1] "Input $1x$1 cupid binary mask." -v -
  -l[]
    (480,480,1,1,0,-4640,-8,1,-7,-9,1,-455,-11,1,-3,-12,1,-453,-13,1,0,-14,1,-452,-28,1,-452,-29,1,-450,-30,1,-450,-30,1,-450,-30,1,-450,-30,1,-450,-30,1,-450,-30,1,-450,-30,1,-451,-29,1,-451,-28,1,-452,-28,1,-453,-26,1,-454,-26,1,-455,-24,1,-456,-24,1,-457,-22,1,-459,-20,1,-461,-18,1,-462,-17,1,-464,-15,1,-466,-13,1,-469,-10,1,-471,-8,1,-473,-6,1,-476,-2,1,-10126,-3,1,-17,-11,1,-445,-11,1,-11,-15,1,-305,-5,1,-131,-15,1,-8,-17,1,-303,-9,1,-15,-2,1,-110,-17,1,-6,-19,1,-302,-11,1,-12,-4,1,-108,-20,1,-2,-22,1,-302,-12,1,-9,-5,1,-14,-2,1,-92,-44,1,-302,-13,1,-8,-5,1,-13,-4,1,-90,-46,1,-302,-13,1,-5,-7,1,-13,-4,1,-90,-46,1,-302,-14,1,-3,-8,1,-13,-5,1,-89,-46,1,-302,-25,1,-13,-7,1,-86,-48,1,-302,-24,1,-13,-9,1,0,-5,1,-78,-48,1,-302,-25,1,-12,-15,1,-78,-48,1,-290,-2,1,-10,-25,1,-12,-15,1,-78,-48,1,-286,-11,1,-4,-33,1,-4,-16,1,-78,-48,1,-284,-52,1,-2,-16,1,-78,-48,1,-282,-72,1,-78,-48,1,-281,-73,1,-78,-48,1,-280,-74,1,-78,-48,1,-279,-75,1,-78,-47,1,-279,-77,1,-77,-47,1,-278,-78,1,-78,-46,1,-277,-79,1,-78,-45,1,-277,-81,1,-77,-45,1,-276,-82,1,-78,-44,1,-275,-84,1,-77,-43,1,-274,-87,1,-77,-42,1,-272,-90,1,-76,-41,1,-271,-92,1,-76,-40,1,-271,-94,1,-76,-39,1,-270,-95,1,-77,-37,1,-270,-107,1,-66,-37,1,-269,-110,1,-65,-35,1,-269,-111,1,-66,-33,1,-268,-115,1,-65,-31,1,-267,-117,1,-65,-30,1,-266,-120,1,-65,-29,1,-266,-120,1,-66,-27,1,-266,-121,1,-67,-25,1,-266,-121,1,-69,-23,1,-267,-112,1,-79,-21,1,-267,-112,1,-81,-19,1,-168,-6,1,-94,-111,1,-84,-16,1,-169,-7,1,-93,-110,1,-86,-13,1,-170,-9,1,-92,-109,1,-88,-11,1,-171,-11,1,-90,-109,1,-89,-9,1,-172,-12,1,-89,-109,1,-91,-6,1,-173,-13,1,-88,-109,1,-270,-14,1,-87,-109,1,-270,-15,1,-86,-110,1,-269,-16,1,-85,-110,1,-269,-17,1,-84,-110,1,-269,-18,1,-83,-111,1,-269,-18,1,-82,-111,1,-269,-20,1,-80,-112,1,-269,-20,1,-79,-112,1,-269,-21,1,-78,-112,1,-270,-22,1,-76,-113,1,-269,-23,1,-75,-113,1,-270,-23,1,-74,-113,1,-271,-23,1,-73,-113,1,-271,-25,1,-70,-114,1,-272,-26,1,-67,-115,1,-272,-28,1,-65,-115,1,-273,-29,1,-62,-116,1,-273,-32,1,-58,-117,1,-274,-33,1,-56,-117,1,-275,-34,1,-53,-118,1,-276,-35,1,-51,-118,1,-277,-37,1,-48,-118,1,-277,-40,1,-45,-118,1,-278,-41,1,-43,-118,1,-268,-6,1,-5,-43,1,-40,-117,1,-268,-10,1,-3,-45,1,-37,-117,1,-51,0,1,-216,-11,1,-3,-47,1,-34,-117,1,-50,-3,1,-214,-66,1,-30,-117,1,-49,-4,1,-214,-69,1,-27,-117,1,-49,-3,1,-215,-71,1,-26,-115,1,-49,-4,1,-215,-73,1,-23,-116,1,-49,-4,1,-216,-74,1,-21,-116,1,-49,-4,1,-216,-75,1,-20,-115,1,-50,-4,1,-216,-76,1,-19,-115,1,-50,-4,1,-217,-76,1,-18,-114,1,-51,-4,1,-218,-76,1,-17,-114,1,-50,-6,1,-217,-77,1,-16,-113,1,-51,-6,1,-219,-75,1,-16,-113,1,-51,-7,1,-219,-75,1,-15,-113,1,-51,-9,1,-217,-76,1,-15,-111,1,-51,-11,1,-217,-75,1,-15,-111,1,-51,-12,1,-218,-74,1,-15,-110,1,-50,-5,1,-4,-6,1,-170,-6,1,-41,-73,1,-16,-108,1,-50,-4,1,-7,-6,1,-168,-9,1,-40,-73,1,-15,-108,1,-49,-5,1,-8,-5,1,-167,-12,1,-40,-71,1,-15,-107,1,-49,-5,1,-10,-5,1,-166,-13,1,-40,-70,1,-16,-106,1,-49,-4,1,-12,-5,1,-165,-14,1,-41,-69,1,-15,-105,1,-49,-5,1,-12,-6,1,-164,-16,1,-30,-7,1,-3,-68,1,-14,-105,1,-49,-5,1,-14,-6,1,-163,-18,1,-26,-80,1,-14,-105,1,-48,-6,1,-15,-5,1,-163,-20,1,-24,-80,1,-14,-104,1,-49,-5,1,-17,-6,1,-162,-21,1,-21,-81,1,-13,-104,1,-50,-4,1,-18,-7,1,-161,-23,1,-19,-82,1,-12,-104,1,-49,-5,1,-19,-7,1,-160,-25,1,-17,-82,1,-12,-104,1,-48,-5,1,-21,-7,1,-160,-26,1,-15,-82,1,-12,-104,1,-47,-6,1,-22,-7,1,-159,-27,1,-15,-81,1,-12,-104,1,-47,-5,1,-23,-8,1,-159,-28,1,-13,-81,1,-12,-105,1,-45,-5,1,-25,-7,1,-160,-31,1,-11,-79,1,-13,-104,1,-45,-5,1,-26,-7,1,-159,-34,1,-9,-79,1,-14,-103,1,-43,-5,1,-28,-6,1,-160,-36,1,-7,-78,1,-18,-99,1,-42,-5,1,-30,-6,1,-161,-39,1,-4,-76,1,-21,-97,1,-40,-5,1,-32,-6,1,-160,-119,1,-22,-96,1,-39,-6,1,-33,-6,1,-160,-118,1,-23,-95,1,-39,-5,1,-34,-7,1,-160,-118,1,-23,-95,1,-37,-5,1,-36,-6,1,-161,-117,1,-23,-95,1,-36,-6,1,-37,-6,1,-161,-116,1,-24,-94,1,-36,-5,1,-39,-5,1,-161,-116,1,-25,-92,1,-36,-5,1,-40,-6,1,-162,-115,1,-24,-92,1,-36,-5,1,-41,-6,1,-162,-114,1,-24,-92,1,-35,-5,1,-42,-7,1,-161,-114,1,-25,-91,1,-35,-4,1,-44,-6,1,-163,-113,1,-24,-90,1,-34,-6,1,-44,-7,1,-163,-112,1,-24,-90,1,-34,-5,1,-46,-6,1,-165,-110,1,-24,-89,1,-34,-6,1,-47,-5,1,-167,-109,1,-23,-89,1,-33,-6,1,-48,-6,1,-157,-3,1,-7,-108,1,-23,-88,1,-34,-5,1,-50,-6,1,-154,-9,1,-4,-107,1,-22,-89,1,-33,-6,1,-50,-6,1,-153,-122,1,-21,-89,1,-32,-6,1,-52,-6,1,-151,-123,1,-20,-89,1,-33,-5,1,-53,-6,1,-151,-123,1,-19,-89,1,-33,-6,1,-54,-6,1,-150,-124,1,-17,-90,1,-32,-6,1,-55,-6,1,-150,-124,1,-17,-89,1,-33,-5,1,-56,-7,1,-149,-124,1,-16,-89,1,-33,-5,1,-58,-6,1,-149,-124,1,-15,-89,1,-33,-6,1,-58,-6,1,-149,-125,1,-15,-87,1,-34,-5,1,-60,-6,1,-149,-124,1,-15,-6,1,-7,-73,1,-34,-5,1,-61,-6,1,-150,-124,1,-37,-62,1,-34,-6,1,-61,-6,1,-151,-123,1,-37,-61,1,-34,-6,1,-63,-6,1,-151,-123,1,-37,-58,1,-36,-5,1,-64,-6,1,-153,-123,1,-35,-57,1,-36,-6,1,-64,-6,1,-154,-131,1,-26,-56,1,-36,-6,1,-65,-7,1,-155,-133,1,-22,-55,1,-36,-6,1,-67,-6,1,-156,-134,1,-20,-55,1,-36,-6,1,-67,-6,1,-158,-136,1,-15,-55,1,-36,-6,1,-68,-6,1,-160,-137,1,-12,-55,1,-36,-5,1,-69,-7,1,-161,-137,1,-9,-55,1,-36,-6,1,-69,-7,1,-164,-136,1,-7,-55,1,-35,-6,1,-71,-6,1,-167,-135,1,-3,-56,1,-36,-6,1,-71,-6,1,-169,-192,1,-35,-6,1,-72,-6,1,-157,-203,1,-35,-6,1,-73,-6,1,-156,-203,1,-36,-6,1,-73,-7,1,-154,-190,1,-6,-7,1,-36,-6,1,-74,-7,1,-153,-190,1,-49,-6,1,-75,-7,1,-153,-189,1,-50,-5,1,-76,-7,1,-153,-188,1,-50,-6,1,-76,-7,1,-153,-188,1,-49,-6,1,-77,-7,1,-153,-187,1,-49,-6,1,-78,-7,1,-154,-186,1,-49,-5,1,-79,-7,1,-155,-185,1,-48,-6,1,-79,-7,1,-156,-183,1,-48,-6,1,-79,-8,1,-158,-181,1,-48,-6,1,-79,-7,1,-162,-178,1,-47,-6,1,-80,-7,1,-164,-176,1,-46,-6,1,-81,-7,1,-168,-173,1,-45,-6,1,-81,-7,1,-174,-168,1,-43,-6,1,-81,-8,1,-171,-176,1,-37,-7,1,-81,-7,1,-169,-183,1,-32,-7,1,-82,-7,1,-168,-186,1,-30,-6,1,-82,-8,1,-167,-188,1,-28,-7,1,-82,-8,1,-166,-191,1,-25,-7,1,-83,-7,1,-167,-193,1,-23,-6,1,-83,-8,1,-168,-194,1,-21,-5,1,-84,-8,1,-168,-199,1,-15,-6,1,-83,-8,1,-169,-202,1,-11,-6,1,-83,-8,1,-171,-203,1,-9,-5,1,-84,-8,1,-172,-203,1,-7,-5,1,-84,-8,1,-175,-203,1,-4,-5,1,-84,-9,1,-177,-203,1,0,-6,1,-83,-9,1,-186,-201,1,-83,-9,1,-187,-201,1,-82,-9,1,-188,-200,1,-83,-8,1,-188,-201,1,-82,-8,1,-189,-201,1,-81,-8,1,-189,-202,1,-80,-9,1,-189,-202,1,-79,-9,1,-190,-202,1,-78,-10,1,-191,-202,1,-77,-9,1,-193,-201,1,-76,-9,1,-196,-200,1,-74,-9,1,-203,-195,1,-72,-10,1,-205,-194,1,-71,-9,1,-205,-197,1,-68,-9,1,-205,-199,1,-66,-10,1,-205,-202,1,-62,-11,1,-205,-225,1,-38,-11,1,-205,-232,1,-31,-12,1,-206,-234,1,-27,-13,1,-206,-237,1,-22,-15,1,-208,-238,1,-17,-18,1,-215,-235,1,-9,-21,1,-215,-266,1,-214,-267,1,-37,-4,1,-171,-269,1,-34,-9,1,-168,-277,1,-25,-11,1,-167,-288,1,-13,-14,1,-165,-294,1,-5,-17,1,-166,-315,1,-173,-260,1,-10,-38,1,-173,-258,1,-18,-32,1,-172,-258,1,-29,-21,1,-173,-257,1,-30,-20,1,-173,-257,1,-31,-18,1,-176,-255,1,-32,-15,1,-185,-248,1,-33,-13,1,-187,-247,1,-34,-10,1,-189,-246,1,-37,-5,1,-192,-246,1,-234,-246,1,-235,-244,1,-239,-240,1,-247,-232,1,-248,-230,1,-250,-229,1,-252,-227,1,-253,-227,1,-255,-224,1,-263,-217,1,-265,-200,1,-2,-13,1,-266,-122,1,-4,-9,1,-21,-39,1,-8,-11,1,-268,-119,1,-7,-5,1,-27,-32,1,-11,-11,1,-270,-5,1,-4,-17,1,-3,-88,1,-8,-3,1,-40,-16,1,-16,-10,1,-281,-14,1,-6,-86,1,-8,-2,1,-73,-10,1,-282,-11,1,-8,-86,1,-9,0,1,-74,-10,1,-283,-8,1,-9,-86,1,-9,0,1,-74,-10,1,-300,-87,1,-8,-2,1,-73,-10,1,-300,-87,1,-8,-2,1,-73,-10,1,-300,-87,1,-8,-2,1,-74,-9,1,-299,-88,1,-9,0,1,-74,-9,1,-298,-90,1,-8,-2,1,-73,-9,1,-297,-91,1,-8,-2,1,-73,-10,1,-293,-94,1,-8,-2,1,-74,-9,1,-291,-96,1,-8,-3,1,-73,-9,1,-290,-97,1,-9,-2,1,-73,-9,1,-289,-98,1,-9,-2,1,-74,-9,1,-287,-99,1,-9,-3,1,-73,-9,1,-286,-100,1,-10,-2,1,-74,-8,1,-285,-101,1,-10,-2,1,-74,-9,1,-283,-102,1,-10,-2,1,-74,-9,1,-282,-103,1,-10,-3,1,-74,-8,1,-282,-103,1,-11,-2,1,-74,-9,1,-280,-104,1,-11,-2,1,-74,-9,1,-279,-105,1,-11,-2,1,-75,-8,1,-278,-106,1,-11,-3,1,-74,-9,1,-277,-106,1,-11,-3,1,-74,-9,1,-276,-107,1,-12,-2,1,-74,-9,1,-276,-107,1,-12,-2,1,-74,-9,1,-276,-107,1,-12,-2,1,-74,-9,1,-275,-108,1,-12,-3,1,-73,-9,1,-275,-108,1,-13,-2,1,-73,-9,1,-275,-107,1,-14,-2,1,-73,-9,1,-275,-107,1,-14,-2,1,-73,-9,1,-274,-108,1,-14,-3,1,-72,-9,1,-274,-108,1,-15,-2,1,-72,-9,1,-274,-108,1,-15,-2,1,-71,-10,1,-273,-108,1,-16,-2,1,-71,-9,1,-191,-7,1,-76,-108,1,-16,-3,1,-70,-9,1,-187,-14,1,-73,-108,1,-17,-2,1,-70,-9,1,-185,-18,1,-71,-108,1,-17,-2,1,-69,-10,1,-183,-21,1,-70,-107,1,-18,-3,1,-68,-9,1,-182,-24,1,-69,-107,1,-18,-3,1,-68,-9,1,-179,-28,1,-68,-107,1,-19,-2,1,-67,-10,1,-165,-42,1,-68,-107,1,-19,-2,1,-67,-9,1,-164,-45,1,-67,-106,1,-20,-3,1,-66,-9,1,-163,-46,1,-67,-106,1,-20,-3,1,-65,-10,1,-162,-47,1,-67,-106,1,-20,-3,1,-65,-9,1,-162,-49,1,-66,-105,1,-22,-2,1,-64,-10,1,-161,-50,1,-66,-105,1,-22,-3,1,-63,-9,1,-162,-50,1,-66,-104,1,-23,-3,1,-62,-10,1,-161,-51,1,-66,-103,1,-25,-2,1,-62,-9,1,-162,-51,1,-66,-103,1,-25,-2,1,-61,-10,1,-161,-52,1,-65,-103,1,-26,-3,1,-60,-9,1,-162,-52,1,-64,-103,1,-27,-3,1,-59,-9,1,-163,-53,1,-60,-105,1,-29,-2,1,-59,-9,1,-163,-53,1,-56,-108,1,-30,-2,1,-58,-9,1,-164,-54,1,-53,-110,1,-30,-2,1,-57,-9,1,-165,-56,1,-50,-109,1,-32,-3,1,-55,-10,1,-165,-68,1,-37,-110,1,-32,-3,1,-54,-10,1,-167,-70,1,-32,-112,1,-33,-2,1,-54,-9,1,-168,-72,1,-29,-112,1,-34,-2,1,-53,-9,1,-171,-5,1,-5,-63,1,-24,-114,1,-34,-3,1,-51,-10,1,-184,-62,1,-20,-116,1,-34,-3,1,-50,-10,1,-186,-62,1,-18,-117,1,-35,-2,1,-49,-10,1,-188,-63,1,-15,-119,1,-34,-2,1,-48,-10,1,-192,-61,1,-13,-120,1,-34,-3,1,-46,-10,1,-195,-59,1,-12,-122,1,-33,-3,1,-45,-10,1,-201,-55,1,-10,-123,1,-34,-2,1,-44,-10,1,-206,-52,1,-8,-124,1,-34,-3,1,-42,-10,1,-208,-52,1,-7,-125,1,-33,-3,1,-40,-11,1,-210,-52,1,-5,-127,1,-32,-3,1,-39,-11,1,-212,-52,1,-3,-128,1,-33,-2,1,-38,-11,1,-214,-182,1,-33,-3,1,-35,-12,1,-216,-182,1,-32,-3,1,-34,-12,1,-218,-181,1,-32,-3,1,-33,-11,1,-220,-181,1,-33,-2,1,-31,-12,1,-222,-180,1,-33,-2,1,-29,-13,1,-224,-180,1,-32,-3,1,-27,-12,1,-227,-179,1,-32,-3,1,-25,-12,1,-229,-179,1,-33,-2,1,-23,-13,1,-231,-178,1,-33,-2,1,-22,-13,1,-233,-177,1,-33,-2,1,-20,-13,1,-236,-177,1,-32,-3,1,-17,-14,1,-238,-176,1,-33,-2,1,-15,-14,1,-241,-175,1,-33,-2,1,-13,-15,1,-243,-174,1,-33,-2,1,-12,-14,1,-246,-174,1,-33,-2,1,-9,-13,1,-250,-173,1,-33,-2,1,-7,-13,1,-253,-172,1,-33,-3,1,-4,-13,1,-256,-171,1,-33,-19,1,-258,-170,1,-33,-17,1,-261,-169,1,-33,-14,1,-265,-168,1,-33,-10,1,-271,-166,1,-33,-8,1,-274,-165,1,-33,-6,1,-276,-165,1,-33,-5,1,-279,-163,1,-33,-4,1,-281,-101,1,-5,-56,1,-33,-4,1,-283,-97,1,-9,-54,1,-33,-3,1,-285,-95,1,-11,-53,1,-33,-3,1,-287,-91,1,-14,-53,1,-32,-2,1,-290,-87,1,-17,-52,1,-326,-83,1,-20,-51,1,-328,-77,1,-25,-50,1,-330,-73,1,-28,-49,1,-334,-65,1,-33,-48,1,-337,-58,1,-38,-47,1,-339,-47,1,-49,-46,1,-340,-36,1,-59,-45,1,-341,-23,1,-72,-44,1,-343,-18,1,-76,-43,1,-344,-14,1,-80,-43,1,-345,-10,1,-83,-42,1,-348,-4,1,-86,-42,1,-435,-45,1,-77,-3,1,-350,-50,1,-60,-7,1,-7,-9,1,-345,-52,1,-59,-10,1,-4,-11,1,-343,-53,1,-58,-12,1,0,-14,1,-341,-54,1,-57,-29,1,-339,-55,1,-57,-29,1,-337,-56,1,-58,-29,1,-336,-57,1,-57,-31,1,-334,-58,1,-57,-31,1,-334,-57,1,-58,-31,1,-332,-59,1,-58,-31,1,-332,-58,1,-59,-30,1,-332,-58,1,-61,-29,1,-331,-58,1,-62,-29,1,-331,-58,1,-62,-29,1,-330,-58,1,-63,-28,1,-331,-57,1,-65,-27,1,-330,-57,1,-66,-26,1,-331,-56,1,-68,-25,1,-330,-55,1,-70,-24,1,-331,-54,1,-72,-22,1,-331,-54,1,-74,-20,1,-331,-53,1,-77,-18,1,-332,-52,1,-78,-18,1,-331,-52,1,-80,-16,1,-331,-52,1,-82,-14,1,-331,-51,1,-85,-12,1,-330,-51,1,-89,-8,1,-332,-49,1,-92,-6,1,-330,-51,1,-94,-4,1,-329,-51,1,-426,-52,1,-427,-52,1,-426,-52,1,-427,-51,1,-428,-51,1,-428,-49,1,-431,-48,1,-431,-47,1,-433,-45,1,-435,-43,1,-437,-41,1,-439,-39,1,-441,-37,1,-443,-35,1,-445,-33,1,-447,-33,1,-448,-31,1,-449,-31,1,-450,-31,1,-449,-31,1,-450,-30,1,-451,-29,1,-452,-28,1,-453,-27,1,-454,-26,1,-456,-24,1,-457,-23,1,-457,-23,1,-458,-22,1,-458,-22,1,-458,-23,1,-457,-23,1,-458,-22,1,-458,-23,1,-457,-24,1,-456,-24,1,-456,-25,1,-456,-24,1,-456,-25,1,-457,-23,1,-457,-23,1,-459,-20,1,-463,-17,1,-467,-10,1,-5058,0)
    -uncompress_rle -r $1,$1,1,1,5 -if {$1>480} -b[-1] 0.2% -endif -ge 40%
    -nm "[Cupid binary mask]"
  -endl -v +

#@gmic cursor : _mode = { 0=hide | 1=show } : (+)
#@gmic : Show or hide mouse cursor for selected instant windows.
#@gmic : Command subset (if any) stands for instant window indices instead of image indices.
#@gmic : Default value: 'mode=1'.

#@gmic d : eq. to '-display'. : (+)

#@gmic display : _X,_Y,_Z : (+)
#@gmic : Display selected images in an interactive viewer (use the instant window [0] if opened).
#@gmic : Arguments 'X','Y','Z' determine the initial selection view, for 3d volumetric images.
#@gmic : (eq. to '-d').

#@gmic d0 : eq. to '-display0'.
d0 :
  -_display0

#@gmic display0
#@gmic : Display selected images without value normalization.
#@gmic : (eq. to '-d0').
display0 :
  -_$0

_display0 :
  -v -
  w=0 h=0 d=0 s=0
  -repeat @# -l[$>] w={$w+w} h={max($h,h)} d={max($d,d)} s={max($s,s)} -endl -done
  -if {@#==1} -w -1,-1,0,0,-1,-1,@{0,n}\ ($wx$hx$dx$s)
  -elif {@#==2} -w -1,-1,0,0,-1,-1,@{0,n},@{-1,n}\ ($wx$hx$dx$s)
  -else -w -1,-1,0,0,-1,-1,@{0,n},..,@{-1,n}\ ($wx$hx$dx$s)
  -endif
  -v + -d
  -v - -w[] 0 -v +

#@gmic d3d : eq. to '-display3d'. : (+)

#@gmic display3d : (+)
#@gmic : Display selected 3d objects in an interactive viewer (use the instant window [0] if opened).
#@gmic : (eq. to '-d3d').

#@gmic da : eq. to '-display_array'.
da :
  -v - __s="$?" -v +
  -_display_array $*

#@gmic display_array : _width>0,_height>0
#@gmic : Display images in interactive windows where pixel neighborhoods can be explored.
#@gmic : Default values: 'width=13' and 'height=width'.
display_array :
  -v - __s="$?" -v +
  -_$0 $*

_display_array : -check ${1=13}>0" && "${2=$1}>0
  -e[0--3] "Display $1x$2 array of pixel values for image"$__s"."
  -v -
  dxb={round($1/2,1,1)} dxf={$1-1-$dxb}
  dyb={round($2/2,1,1)} dyf={$2-1-$dyb}

  -repeat @# -l[$>]
    -if {w<128" && "h<128} -r 128,128,100%,100%,0,0,0.5,0.5 -endif    # Manage cases of small and large images.
    x0=0 y0=0 w={w} h={h}
    wmax={0.9*@{!,u}} hmax={0.9*@{!,v}}
    -do
      -if {w>=$wmax||h>=$hmax}
        n=@{-1,n} -nm[-1] "Image "'@{-1,b}.@{-1,x}'" is too large, please select a sub-image."
        --select[-1] 2 x0={i[0]} y0={i[1]} w={1+i[3]-i[0]} h={1+i[4]-i[1]}
        -rm[-1] -nm[-1] $n
      -endif
      --z[-1] $x0,$y0,0,{$x0+$w-1},{$y0+$h-1},0 -round[-1] 1 -n[-1] 0,255
    -while {w>=$wmax||h>=$hmax}

    x1=-1 y1=-1 c1=0 ox1=-1 oy1=-1 oc1=-1
    x2=-1 y2=-1 c2=0 ox2=-1 oy2=-1 oc2=-1
    x3=-1 y3=-1 c3=0 ox3=-1 oy3=-1 oc3=-1
    c0=0 oxm=-1 oym=-1
    -w[-1] -1,-1,0,0,-1,-1,@{-2,b}.@{-2,x}
    -do  # Enter event loop.

      # Manage user interactions.
      -wait[0-3]
      oc0=$c0
      -repeat 4
        -if {$>" && "!@{!$>}" && "${x$>}>=0} -w$> 0 x$>=-1 y$>=-1 c$>=0 -endif
        -if @{!$>,o} c$>={(${c$>}+sign(@{!$>,o}))%s} -wait[$>] -1 -endif
        -if {@{!$>,SPACE}" || "@{!$>,ENTER}" || "@{!$>,ARROWRIGHT}" || "@{!$>,ARROWDOWN}} c$>={(${c$>}+1)%s} -wait[$>] -1 -endif
        -if {@{!$>,BACKSPACE}" || "@{!$>,ARROWLEFT}" || "@{!$>,ARROWUP}} c$>={(${c$>}-1)%s} -wait[$>] -1 -endif
      -done
      -if {$oc0!=$c0} c1=$c0 c2=$c0 c3=$c0 -endif
      xm=@{!,x} ym=@{!,y}
      -if {$xm>=0" && "@{!,b}&1} x1=$xm y1=$ym -endif
      -if {$xm>=0" && "@{!,b}&2} x2=$xm y2=$ym -endif
      -if {$xm>=0" && "@{!,b}&4} x3=$xm y3=$ym -endif

      # Generate main image view.
      -if {$xm>=0" && "($oxm!=$xm" || "$oym!=$ym)} -w[] -1,-1,-1,-1,-1,-1,@{-2,b}.@{-2,x}" - ("$xm,$ym")" -endif
      -if {$x1!=$ox1" || "$y1!=$oy1" || "$x2!=$ox2" || "$y2!=$oy2" || "$x3!=$ox3" || "$y3!=$oy3}
        [-1]
        -if {$x1>=0}
          xb={$x1-$dxb} yb={$y1-$dyb} xe={$x1+$dxf} ye={$y1+$dyf}
          -rectangle[-1] $xb,$yb,$xe,$ye,0.2,0,255,255
          -rectangle[-1] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,0,255,255
        -endif
        -if {$x2>=0}
          xb={$x2-$dxb} yb={$y2-$dyb} xe={$x2+$dxf} ye={$y2+$dyf}
          -rectangle[-1] $xb,$yb,$xe,$ye,0.2,255,32,255
          -rectangle[-1] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,32,255
        -endif
        -if {$x3>=0}
          xb={$x3-$dxb} yb={$y3-$dyb} xe={$x3+$dxf} ye={$y3+$dyf}
          -rectangle[-1] $xb,$yb,$xe,$ye,0.2,255,255,0
          -rectangle[-1] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,255,255,0
        -endif
        -w[-1] @{-2,w},@{-2,h} -rm[-1] oxm=$xm oym=$ym
      -endif

      # Generate zoomed views.
      -if {$x1>=0" && "($ox1!=$x1" || "$oy1!=$y1" || "$oc1!=$c1)}
        --z[-2] {$x1-$dxb},{$y1-$dyb},0,$c1,{$x1+$dxf},{$y1+$dyf},0,$c1
        --z[-2] {$x1-$dxb},{$y1-$dyb},0,{$x1+$dxf},{$y1+$dyf},0
        -__display_array[-2,-1] $1,$2,0,255,255
        -w1[-1] {w},{h},0,0,-1,-1,@{-3,b}" - ("$x1,$y1,c=$c1")"
        -rm[-1] ox1=$x1 oy1=$y1 oc1=$c1
      -endif
      -if {$x2>=0" && "($ox2!=$x2" || "$oy2!=$y2" || "$oc2!=$c2)}
        --z[-2] {$x2-$dxb},{$y2-$dyb},0,$c2,{$x2+$dxf},{$y2+$dyf},0,$c2
        --z[-2] {$x2-$dxb},{$y2-$dyb},0,{$x2+$dxf},{$y2+$dyf},0
        -__display_array[-2,-1] $1,$2,255,32,255
        -w2[-1] {w},{h},0,0,-1,-1,@{-3,b}" - ("$x2,$y2,c=$c2")"
        -rm[-1] ox2=$x2 oy2=$y2 oc2=$c2
      -endif
      -if {$x3>=0" && "($ox3!=$x3" || "$oy3!=$y3" || "$oc3!=$c3)}
        --z[-2] {$x3-$dxb},{$y3-$dyb},0,$c3,{$x3+$dxf},{$y3+$dyf},0,$c3
        --z[-2] {$x3-$dxb},{$y3-$dyb},0,{$x3+$dxf},{$y3+$dyf},0
        -__display_array[-2,-1] $1,$2,255,255,0
        -w3[-1] {w},{h},0,0,-1,-1,@{-3,b}" - ("$x3,$y3,c=$c3")"
        -rm[-1] ox3=$x3 oy3=$y3 oc3=$c3
      -endif
    -while {@!" && "\
            !@{!,ESC}" && "!@{!,Q}" && "\
            !@{!1,ESC}" && "!@{!1,Q}" && "\
            !@{!2,ESC}" && "!@{!2,Q}" && "\
            !@{!3,ESC}" && "!@{!3,Q}}
    -k[0] -w 0 -w1 0 -w2 0 -w3 0
  -endl -done -v +

__display_array :
  -round[-2] 1 -c[-2] 0,999 -r[-1] 100%,100%,1,3,{if(s==1,1,0)}
  --luminance[-1] -r[-2] {$1*24},{$2*24} -grid[-2] {100/$1}%,{100/$2}%,0,0,1,0
  xb={24*int($1/2)} yb={24*int($2/2)} xe={$xb+24} ye={$yb+24}
  -rectangle[-2] $xb,$yb,$xe,$ye,1,0xFFFFFFFF,$3,$4,$5
  -repeat $2 yg=$>
    -repeat $1 xg=$>
      -t[-2] @{-3,($xg,$yg)},{5+$xg*24},{5+$yg*24},13,0.8,{if(@{-1,($xg,$yg)}>128,0,255)}
    -done
  -done
  -rm[-3,-1]

#@gmic dfft : eq. to '-display_fft'.
dfft :
  -_display_fft

#@gmic display_fft
#@gmic : Display fourier transform of selected images, with centered log-module and argument.
#@gmic : (eq. to '-dfft').
#@gmic : $ image.jpg --display_fft
display_fft :
  -_$0

_display_fft :
  -e[0--3] "Render fourier transform of image$? with centered log-module and argument."
  -v - -repeat @# -l[$>] -fftpolar -+[-2] 1 -log[-2] -n 0,255 -a x -endl -done -s x,2 -v +

#@gmic dg : eq. to '-display_graph'.
dg : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  -_display_graph ${1-8},"$9","$10"

#@gmic display_graph : _width>32,_height>32,_plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax,_xlabel,_ylabel
#@gmic : Render graph plot from selected image data.
#@gmic : Default values: 'width=640', 'height=480', 'plot_type=1', 'vertex_type=1', 'xmin=xmax=ymin=ymax=0', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 128,1,1,1,'cos(x/10+?)' --display_graph 400,300,3
display_graph : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  -_display_graph ${1-8},"$9","$10"

_display_graph : -check "${1=640}>32 && ${2=480}>32" -skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"
  -e[0--3] "Render $1x$2 graph plot from data of image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}

    # Determine xmin,xmax/ymin,ymax.
    one={$3!=3} siz={w*h*d}
    -if {$5==$6} xmin=0 xmax={$siz-$one} -else xmin={min($5,$6)} xmax={max($5,$6)} -endif
    -if {$7==$8} ymin={im-(iM-im)/20} ymax={iM+(iM-im)/20} -else ymin={min($7,$8)} ymax={max($7,$8)} -endif

    # Create plot canvas.
    gw={$1-32} gh={$2-32} gg={($gw-$one)/($siz-$one)}
    $gw,$gh,1,3,255
    -if {$siz<32} -grid[-1] $gg,$gg,0,0,0.25,0xCCCCCCCC,0
    -else -grid[-1] 10%,10%,0,0,0.25,0xCCCCCCCC,0
    -endif

    # Define color palette for curves.
    -if {@{-2,s}==1} (120,120,200)
    -elif {@{-2,s}<=3} (220,10,10;10,220,10;10,10,220)
    -else
      (0,255) -r[-1] 256,1,1,1,3 -map[-1] 2 -z[-1] 2,100% -permute[-1] cxyz -r[-1] 3,{max(3,@{-3,s})},1,1,0,2
      -sh[-1] 0,2,0,0 -f[-1] 255,0,0,0,255,0,0,0,255 -rm[-1]
    -endif

    # Draw plot for each channel.
    -repeat @{-3,s} -sh[-3] $>,$> -graph[-3] [-1],$3,$4,$ymax,$ymin,1,@{-2,0-2} -rm[-1] -shift[-1] 0,-1 -done
    -rm[-3,-1]
    -line[-1] 0,0,100%,0,1,110 -line[-1] 100%,0,100%,100%,1,110
    -line[-1] 100%,100%,0,100%,1,255 -line[-1] 0,100%,0,0,1,255

    100%,100%,1,1,255
    xmax_={$xmin+($xmax-$xmin)*($siz-$one)/($siz-1)}
    -axes[-1] $xmin,$xmax_,$ymax,$ymin,13,1,0
    -if {$xmin>0} -axes[-1] 0,0,$ymax,$ymin,13,1,160 -endif
    -if {$xmax<0} -axes[-1] {w-1},{w-1},$ymax,$ymin,13,1,160 -endif
    -if {$ymin>0} -axes[-1] $xmin,$xmax_,{h-1},{h-1},13,1,160 -endif
    -if {$ymax<0} -axes[-1] $xmin,$xmax_,0,0,13,1,160 -endif
    --erode[-1] 3 -neq[-1] 255 -r[-2] 100%,100%,1,3 -j[-3] [-2],0,0,0,0,1,[-1],1 -rm[-2,-1]
    -frame[-1] 16,16,220
    0 -t[-1] "$9",0,0,13,1,-220,-220,-220 -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-16},0,0,-1 -rm[-1]
    0 -t[-1] "$10",0,0,13,1,-220,-220,-220 -rotate[-1] -90 -j[-2] [-1],2,{(@{-2,h}-h)/2},0,0,-1 -rm[-1]

  -nm $nm,1 -endl -done -c 0,255 -v +

#@gmic dh : eq. to '-display_histogram'.
dh :
  -v - __s="$?" -v +
  -_display_histogram $*

#@gmic display_histogram : _width>0,_height>0,_clusters>0,_min_value[%],_max_value[%],_show_axes={ 0 | 1 },_cut_value.
#@gmic : Render a channel-by-channel histogram.
#@gmic : If selected image has several slices, the rendering is performed for all input slices.
#@gmic : 'cut_value' can be { -1=no-cut | >=0 }.
#@gmic : (eq. to '-dh').
#@gmic : Default values: 'width=512', 'height=300', 'clusters=256', 'min_value=0%', 'max_value=100%', 'show_axes=1' and 'cut_value=-1'.
#@gmic : $ image.jpg --display_histogram 512,300
display_histogram :
  -v - __s="$?" -v +
  -_$0 $*

_display_histogram : -check "${1=512}>0 && ${2=300}>0 && ${3=256}>0" -skip ${4=0%},${5=100%},${6=1},${7=-1}
  -e[0--3] "Render $1x$2 channel-by-channel histogram of image"$__s", with $3 clusters, minimum value $4 and maximum value $5."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -if @{-is_percent\ $4} m={im+(iM-im)*$4} -else m=$4 -endif
    -if @{-is_percent\ $5} M={im+(iM-im)*$5} -else M=$5 -endif
    s={s} -s c
    -repeat $s -l[{-1-$>}] -s z -histogram $3,$m,$M -a z -endl -done
    -a c vM={if($7>=0,$7,iM)} -s z
    -repeat @# -l[$>]
      $1,$2,1,{s},-255
      -repeat {s} -sh[-2,-1] $>,$> -graph[-1] [-2],3,0,$vM,0,1,0 -rm[-2,-1] -done
      -rm[-2] -+ 255
      -if $6 100%,100% -axes[-1] $m,$M,$vM,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1] -endif
    -endl -done
    -a z -nm $nm,1
  -endl -done -v +

#@gmic display_parametric : _width>0,_height>0,_outline_opacity,_vertex_radius>=0,_is_antialiased={ 0 | 1 },_is_decorated={ 0 | 1 },_xlabel,_ylabel
#@gmic : Render 2d or 3d parametric curve or point clouds from selected image data.
#@gmic : Curve points are defined as pixels of a 2 or 3-channel image.
#@gmic : If the point image contains more than 3 channels, additional channels define the (R,G,B) color for each vertex.
#@gmic : If 'outline_opacity>1', the outline is colored according to the specified vertex colors and 'outline_opacity-1' is used as
#@gmic : the actual drawing opacity.
#@gmic : Default values: 'width=512', 'height=width', 'outline_opacity=3', 'vertex_radius=0', 'is_antialiased=1', 'is_decorated=1', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 1024,1,1,2,'t=x/40;if(c==0,sin(t),cos(t))*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)' -display_parametric 512,512
#@gmic : $ 1000,1,1,2,?(-100,100) -quantize 4,1 -noise 12 -channels 0,2 --normalize 0,255 -append c -display_parametric 512,512,0.1,8
display_parametric : -check "${1=512}>0 && ${2=$1}>0 && ${4=0}>=0" -skip ${3=3},${5=1},${6=1},"${7=x-axis}","${8=y-axis}"
  -v - s0="no " s1="" o0="" o1="colored "
  -v + -e[^-1] "Render $1x$2 parametric graph plot from data of image$?, with "${o{$3>1}}"outline opacity "{if($3>1,$3-1,$3)}\
               ", vertex radius $4, "${s{$5!=0}}"antialiasing and "${s{$6!=0}}"decoration." -v -
  -repeat @# -l[$>]
    nm=@{0,n} N={w*h*d}
    -i[0] ({'CImg3d'}) -+[0] 0.5 -i[1] ($N;$N)  # Header + nb of vertices/primitives.

    # Calibrate colors of vertices.
    -if {s==4} --channels[-1] 3,3 -r[-1] 100%,100%,1,2 -a[-2,-1] c is_grayscale=1
    -else is_grayscale={s<4} -channels[-1] 0,5
    -endif

    # Manage coordinates of vertices.
    -sh[-1] 0,0 xm={im} xM={iM} -rm[-1]
    -sh[-1] 1,1 ym={im} yM={iM} -rm[-1]
    -sh[-1] 2,2 zm={im} zM={iM} -rm[-1]
    -permute[-1] cxyz -s[-1] x,2
    -i[-2] (1,0;1,{$N-1}) -r[-2] 2,$N,1,1,3 -round[-2] 1,$N,1,1,1 # Primitives, colors and opacities.
    -y -a y -c3d -n3d -*3d 1,-1,1

    {if($6,max(1,$1-32),$1)},{if($6,max(1,$2-32),$2)},1,{if($is_grayscale,1,3)},255
    -*3d[0] {0.96*min(w,h)}
    -if $6 L={0.1*max($1,$2)} -grid[1] $L,$L,0,0,0.25,0xCCCCCCCC,0 -endif

    -if $5 # Anti-aliased.
      -r[1] 200%,200%,1,100%,1 -*3d[0] 2
      -if $4 --circles3d[0] {2*$4} -object3d[1] [2],50%,50%,0,1,3,0,0 -rm[2] -endif
    -elif $4 # Aliased.
      --circles3d[0] $4 -object3d[1] [2],50%,50%,0,1,3,0,0 -rm[2]
    -endif

    -if $3 -l[0] -s3d -f[1] 'i-y' -rm[3] -i[3] (2,0,1;2,{$N-2},{$N-1}) -r[3] 3,{$N-1},1,1,3 -round[3]  # Convert point cloud to connected segments.
      -r[5] 1,{h-1},1,1,0
      -if {$3>1} -r[4] 3,@{4,h/3},1,1,-1 -r[4] 3,@{4,h-1},1,1,2 -else -rm[4] -i[4] 3,{$N-1} -endif
      -y -a y -endl -object3d[1] [0],50%,50%,0,{if($3>1,$3-1,$3)},2,0,0
    -endif

    -rm[0]
    -if $5 -r[-1] 50%,50%,1,100%,2 -endif

    -if $6 # Add decoration.
      xc={0.5*($xm+$xM)} yc={0.5*($ym+$yM)} dx={0.5*($xM-$xm)/0.96} dy={0.5*($yM-$ym)/0.96}
      xm={$xc-$dx} xM={$xc+$dx} ym={$yc-$dy} yM={$yc+$dy}
      100%,100% -axes[-1] $xm,$xM,$yM,$ym,13,1,1
      -if {$xm>0} -axes[-1] 0,0,$yM,$ym,13,1,160 -endif
      -if {$xM<0} -axes[-1] {w-1},{w-1},$yM,$ym,13,1,160 -endif
      -if {$ym>0} -axes[-1] $xm,$xM,{h-1},{h-1},13,1,160 -endif
      -if {$yM<0} -axes[-1] $xm,$xM,0,0,13,1,160 -endif
      --dilate[-1] 3 --[-1] [-2] -*[-1] 200 -eq[-2] 0
      -*[-3,-2] -+[-2,-1] -c[-1] 0,255
      -frame 1,1,128 -frame 15,15,220
      0 -t[-1] "$7",0,0,13,1,-220,-220,-220 -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-16},0,0,-1 -rm[-1]
      0 -t[-1] "$8",0,0,13,1,-220,-220,-220 -rotate[-1] -90 -j[-2] [-1],2,{(@{-2,h}-h)/2},0,0,-1 -rm[-1]
    -endif
    -nm[-1] $nm,1
  -endl -done -v +

#@gmic dp : eq. to '-display_polar'.
dp :
  -v - __s="$?" -v +
  -_display_polar $*

#@gmic display_polar : _width>32,_height>32,_outline_type,_fill_R,_fill_G,_fill_B,_theta_start,_theta_end,_xlabel,_ylabel
#@gmic : Render polar curve from selected image data.
#@gmic : (eq. to '-dp').
#@gmic : 'outline_type' can be { r<0=dots with radius -r | 0=no outline | r>0=lines+dots with radius r }.
#@gmic : 'fill_color' can be { -1=no fill | R,G,B=fill with specified color }.
#@gmic : Default values: 'width=500', 'height=width', 'outline_type=1', 'fill_R=fill_G=fill_B=200', 'theta_start=0', 'theta_end=360', 'xlabel="x-axis"' and 'ylabel="y-axis"'.
#@gmic : $ 300,1,1,1,'0.3+abs(cos(10*pi*x/w))+?(0.4)' -display_polar 512,512,4,200,255,200
#@gmic : $ 3000,1,1,1,'x^3/1e10' -display_polar 400,400,1,-1,,,0,{15*360}
display_polar :
  -v - __s="$?" -v +
  -_$0 $*

_display_polar : -check "${1=500}>32 && ${2=$1}>32" -skip ${3=1},${4=200},${5=$4},${6=$5},${7=0},${8=360},"${9=x-axis}","${10=y-axis}"
  -e[0--3] "Render $1x$2 polar graph plot from data of image"$__s", with outline $4 and fill color ($4,$5,$6)."
  -v - -repeat @# -l[$>] nm=@{0,n}

    # Compute (x,y) coordinates of the polar curve points.
    M={max(abs(iM),abs(im))}
    -* {0.48*min($1,$2)/$M}
    -y ({$7*pi/180};{-$8*pi/180}) -r[-1] 1,[-2],1,1,3
    --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
    -a[-2,-1] x N={h}
    -nm[-1] coords

    # Generate 3d object for curve outline.
    -if $3
      ({'CImg3d'}) -+[-1] 0.5 ($N,$N)
      --z[coords] 0,2
      1,$N,1,1,2 1,$N,1,1,'y' --+[-1] 1 -a[-3--1] x -=[-1] 0,2,100%
      3,$N,1,1,0 1,$N,1,1,1 -y[-6--1] -a[-6--1] y
      -nm[-1] _plot_polar_outline
    -endif

    # Generate 3d object for filling.
    -if {"$4>=0 && $5>=0 && $6>=0"}
      ({'CImg3d'}) -+[-1] 0.5 ({$N+1},$N)
      --z[coords] 0,-1,2,100% -z[-1] 0,2
      1,$N,1,1,3 1,$N 1,$N,1,1,'1+y' --+[-1] 1 -a[-4--1] x -=[-1] 1,3,100%
      3,$N,1,1,$4,$5,$6 1,$N,1,1,1
      -y[-6--1] -a[-6--1] y
      -nm[-1] _plot_polar_fill
    -endif
    -rm[coords]  # Remove original curve coordinates.

    # Render graph image.
    {$1-32},{$2-32},1,3,255
    L={0.1*max($1,$2)} -grid[-1] $L,$L,0,0,0.25,0xCCCCCCCC,0  # Draw background grid.
    -if {"$4>=0 && $5>=0 && $6>=0"}                           # Draw curve filling.
      -object3d[-1] [_plot_polar_fill],50%,50%,0,1,2,1,0
      -rm[_plot_polar_fill]
    -endif
    -if $3
      -if {$3>=0}                                             # Draw curve outline.
        -object3d[-1] [_plot_polar_outline],50%,50%,0,1,1,0,0
      -endif
      -if {$3!=0}                                             # Draw curve vertices.
        -if {abs($3)>1} -circles3d[_plot_polar_outline] {abs($3)} -endif
        -object3d[-1] [_plot_polar_outline],50%,50%,0,0.2,2,0,0
      -endif
      -rm[_plot_polar_outline]
    -endif

    # Draw axes and frame.
    nM={$M/0.96}
    100%,100% -axes[-1] {-$nM},$nM,$nM,{-$nM},13,1,1
    --dilate[-1] 3 --[-1] [-2] -*[-1] 200 -eq[-2] 0
    -*[-3,-2] -+[-2,-1] -c[-1] 0,255
    -frame[-1] 1,1,128 -frame[-1] 15,15,220
    0 -t[-1] "$9",0,0,13,1,-220,-220,-220 -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-16},0,0,-1 -rm[-1]
    0 -t[-1] "$10",0,0,13,1,-220,-220,-220 -rotate[-1] -90 -j[-2] [-1],2,{(@{-2,h}-h)/2},0,0,-1 -rm[-1]

  -nm $nm,1 -endl -done -v +

#@gmic drgba : eq. to '-display_rgba'.
drgba :
  -_display_rgba

#@gmic display_rgba
#@gmic : Render selected RGBA images over a checkerboard background.
#@gmic : (eq. to '-drgba').
#@gmic : $ image.jpg --norm -threshold[-1] 40% -blur[-1] 3 -normalize[-1] 0,255 -append c -display_rgba
display_rgba :
  -_$0

_display_rgba :
  -e[0--3] "Render RGBA image$? over a checkerboard background."
  -v - -to_a -repeat @# -l[$>]
    -i[0] (160,128;128,160) -nm[0] @{1,n} -r[0] 16,16 -r[0] [1],[1],1,{s-1},0,2 -blend alpha
  -endl -done -v +

#@gmic dt : eq. to '-display_tensors'.
dt :
  -v - __s="$?" -v +
  -_display_tensors $*

#@gmic display_tensors : _size_factor>0,_ellipse_factor>=0,_colored_mode={ 0 | 1 }
#@gmic : Render selected mask field of 2x2 tensors with ellipses.
#@gmic : (eq. to '-dt').
#@gmic : Default values: 'size_factor=16', 'ellipse_factor=0.92', 'color_mode=1'.
#@gmic : $ image.jpg -diffusiontensors 0.7,0.6 -crop 60,10,90,30 --display_tensors ,
display_tensors :
  -v - __s="$?" -v +
  -_$0 $*

_display_tensors : -check "${1=16}>0 && ${2=0.92}>=0" -skip "${3=1}"
  -e[0--3] "Render field of 2x2 tensors from image"$__s", with size factor $1, ellipse factor $2 in "@{-arg\ 1+!$3,colored,masked}" mode."
  -v -
  -if {$3} -repeat @# -l[$>]
    --_display_tensors $1,$2,0
    -s[0] c --min[0,2] -*[1] -1 -+[1,-1] -a[0-2] c
    -r[0] [-1],[-1] -n[0] 0,255 -*
  -endl -done -else -repeat @# -l[$>]
    w={w} h={h}
    -* {($2*$1/2)^2/max(abs(im),abs(iM))}     # Normalize tensor values.
    -s c -i[-2] [-2] -a c -s yx -r 2,2,1,1,-1 # Decompose field into list of 2x2 matrices.
    (0.5,0;0,0.5) -+[^-1] [-1] -rm[-1]        # Add 0.5*Id to ensure tensor positivity.
    -invert -y c -r $1,$1                     # Optimized code for ellipses drawing.
    $1,$1,1,1,'x' --[-1] {w/2}
    $1,$1,1,1,'y' --[-1] {h/2}
    --sqr[-1] -*[-2] [-3] -sqr[-3] -i[-2] [-2] -a[-4--1] c
    -*[^-1] [-1] -rm[-1] -compose_channels + -le 1
    -append_tiles $w,$h                       # Recompose ellipses as a tensor field.
  -endl -done -endif
  -v +

#@gmic dw : eq. to '-display_warp'.
dw :
  -v - __s="$?" -v +
  -_display_warp $*

#@gmic display_warp : _cell_size>0
#@gmic : Render selected 2d warping fields.
#@gmic : (eq. to '-dw').
#@gmic : Default value: 'cell_size=15'.
#@gmic : $ image.jpg -luminance -blur 5 -gradient -append c -display_warp ,
display_warp :
  -v - __s="$?" -v +
  -_$0 $*

_display_warp : -check "${1=15}>0"
  -e[0--3] "Render 2d warping field"$__s", with cell size $1."
  -v - -repeat @# -l[$>]
    -if {d!=1||s!=2}
      -error[0--3] "Invalid image ["{@#-$>-1}"]: Dimensions "{w}","{h}","{d}","{s}" does not represent a 2d field of 2d vectors."
    -endif
    -i[0] 100%,100%,1,1,1 -grid[0] $1,$1 -nm[0] @{1,n}
    -warp[0] [1],1,1,0 -rm[1]
  -endl -done -* 255 -v +

#@gmic document_gmic : _format={ ascii | html | latex | xml | bash | images },_image_path,_write_wrapper={ 0 | 1 }
#@gmic : Create documentation of .gmic command files (loaded as raw 'uchar' images), in specified format.
#@gmic : Default values: 'format=ascii', 'image_path=""' and 'write_wrapper=1'.\n
#@gmic : Example(s) : raw:file.gmic,uchar -document_gmic html,img
document_gmic : -skip ${1="ascii"},${2=""},${3=1}
  -if {!@#} -return -endif
  -v -1

  # Concatenate command data and split them into lines.
  _name=@{0,b} # Basename for the commands definition file.
  -if {@#>1} -i[1--2] (10) -endif -a y -m @{-1,t} -s -,10

  # Output header.
  -_document_gmic_header_$1[] $3

  # Define parsing variables.
  _subsection=0                              # Indice of current subsection.
  _example=0                                 # Indice of current example.
  _command=0                                 # Indice of current command.
  _path="$2"                                 # Path of example images.
  ks0="0" ks1="-k[0]"

  # Parse lines of the commands file.
  -repeat @# -l[$>] -if {h>7" && "{@{-1,0-5}'=='{'"#@gmic"'}}" && "(i[6]=={'" "'}" || "i[6]=={':'})} # Process only lines starting with '#@gmic'.
    -rows 7,100% -autocrop {'" "'}  # Discard '#@gmic'.
    -if {i!={':'}}

      # Reached line as '#@gmic Command : Arguments_line1 : Arguments_line2 : (qualifier)'.
      _command={$_command+1}
      -s -,{'": "'} -autocrop {'" "'}
      -_document_gmic_declaration_$1

    -else
      -rows 1,100% # Discard ':' char.
      -if {i=={':'}}

        # Reached line as '#@gmic :: Subsection name'.
        _subsection={$_subsection+1}
        -rows 1,100% -autocrop {'" "'} # Discard ':' character.
        -_document_gmic_subsection_$1

      -else
        -autocrop {'" "'}
        -if {i=={'$'}}

          # Reached line as '#@gmic : $ Example of use'.
          _example={$_example+1}
          -rows 1,100% -autocrop {'" "'} # Discard '$' character.
          _filename=$_path$_name$_example.jpg
          -_document_gmic_example_$1

        -else

          # Reached line as '#@gmic : description.'
          -_document_gmic_description_$1
        -endif
      -endif
    -endif
  -endif ${ks{@#!=0}} -endl -done
  -rm
  -_document_gmic_footer_$1[] $3


# Define document_gmic commands for html output.
_document_gmic_header_html :
  -if $1 -v + -e[] "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">
\n<head>
\n<script type=\"text/javascript\" src=\"highslide/highslide.js\"></script>
\n<link rel=\"stylesheet\" type=\"text/css\" href=\"highslide/highslide.css\" />
\n<script type=\"text/javascript\">
\nhs.graphicsDir = 'highslide/graphics/';
\nhs.wrapperClassName = 'wide-border';
\n</script>
\n</head>
\n<body>
\n"
  -v - -endif
  -m "don : -_document_gmic_desc_on_html"
  -m "doff : -_document_gmic_desc_off_html"
  -m "eon : -_document_gmic_ex_on_html"
  -m "eoff : -_document_gmic_ex_off_html"
  _is_desc=0
  _is_ex=0
  _shortcut=0

_document_gmic_desc_on_html :
  -v -
  -if $_is_desc
    -u "<br/>"
  -else
    -u "<p style=\"margin-left:100px\"><tt>"
    _is_desc=1
  -endif
  -v +

_document_gmic_desc_off_html :
  -v -
  -if $_is_desc
    -u "</tt></p>"
    _is_desc=0
  -else -u ""
  -endif
  -v +

_document_gmic_ex_on_html :
  -v -
  -if $_is_ex
    -u ""
  -else
    -u "<br/><table style=\"margin-left:100px\" width=\"75%\" bgcolor=\"#EEEEEE\" bordercolor=\"black\" border=\"1\" cellpadding=\"4\" cellspacing=\"0\">"\
       "<tr><td colspan=\"2\" bgcolor=\"#777777\"><font color=\"white\"><b>Example(s) of use:</b></font></td></tr>"
    _is_ex=1
  -endif
  -v +

_document_gmic_ex_off_html :
  -v -
  -if $_is_ex
    -u "</table>"
    _is_ex=0
  -else
    -u ""
  -endif
  -v +

_document_gmic_subsection_html :
  -v +
  -e[] @{-eoff}@{-doff}"<br/><h3><a id=\"subsection"$_subsection"\"><font color=\"purple\">** <u>"@{0,t}"</u></font></a>"\
       "&nbsp;&nbsp;<a href=\"#toc\"><img src=\"img/back_top.png\"></img></a></h3>"
  -v -

_document_gmic_declaration_html :
  -if {{@{-1,t}'=='"(*)"}" || "{@{-1,t}'=='"(+)"}} qualifier=" "@{-1,t} -rm[-1] -else qualifier="" -endif
  s1="\n" s0=" |<br/>"
  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    -v +
    -e[] @{-eoff}@{-doff}"<p style=\"margin-left:20px\"><font color=\"green\">&nbsp;&nbsp;<b>-"@{0,t}$qualifier"</b>:</font>"
    -if {@#>1}
      -e[] "<p style=\"margin-left:150px\"><tt><i><font color=\"purple\">"
      -repeat {@#-1}
        -e[] @{{1+$>},t}${s{$<==0}}
      -done
      -e[] "</font></i></tt></p>"
    -else -e[] ""
    -endif
    -v -
  -endif

_document_gmic_description_html :
  -if {@{-1,0-12}'=='{'"Default value"'}}  # Reached line as '#@gmic : Default value(s) : ... '.
    -s +,{':'} -l[^0] -a y -endl -autocrop {':'} -autocrop {'" "'}
    -v +
    -if {@#>1} -e[] @{-don}"<br/><b>"@{0,t}"</b>: "@{-1,t}
    -else -e[] @{-don}"<br/>"@{0,t}
    -endif
    -v -

  -elif {@{-1,0-7}'=='{'"(eq. to "'}}      # Reached line as '#@gmic : (eq. to -shortcut)'.
    -v + -e[] @{-don}"<i><font color=\"blue\">"@{-1,t}"</font></i>" -v -

  -else                                    # Reached line as '#@gmic : description'.
    -if {(i<{'A'}" || "i>{'Z'})" && "i!=40" && "i!=39} -v + -e[] @{-don}"&nbsp;"@{-1,t} -v -
    -else -v + -e[] @{-don}@{-1,t} -v -
    -endif

  -endif

_document_gmic_example_html :
  -if $_filename -else # Generate picture only if the file doesn't yet exist.
     -m "foo : "@{-1,t}
     -l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
     -uncommand foo
  -endif
  -v +
  -e[] @{-eon}"<tr><td width=\"40\"><div><a href=\""$_filename"\" class=\"highslide\" onclick=\"return hs.expand(this)\">"\
       "<font color=\"blue\">(view)</font></a><div class=\"highslide-caption\">"@{-1,t}"</div></div></td><td><tt>"@{-1,t}"</tt></td></tr>"
  -v -

_document_gmic_footer_html : -skip $1
  -if $_shortcut # Document shortcuts.
    _subsection={$_subsection+1}
    ({'"Commands shortcuts"'}) -_document_gmic_subsection_html[-1] -rm[-1]
    -v + -e[] "<p style=\"margin-left:20px\">"
    -repeat $_shortcut
      -e[] "<font color=\"green\"><b>&nbsp;&nbsp;-"${_shortcut$>}" "${_shortcutqualifier$>}"</b>:</font>"
      -e[] "<font color=\"blue\"><i>eq. to '"${_shortcutlink$>}"'</i></font><br/>"
    -done
    -e[] "</p>" -v -
  -endif
  -v +
  -e[] @{-eoff}@{-doff}"<p style=\"margin-left:100px\"><font color=\"blue\"><b>[ Total number of commands: "$_command" ]</b></font>"
  -v -
  -uncommand don
  -uncommand doff
  -uncommand eon
  -uncommand eoff

# Define document_gmic commands for XML output.
_document_gmic_header_xml :
  -if $1 -v +
    -e[] "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>
\n<?xml-stylesheet href=\"gmic_doc.xsl\" type=\"text/xsl\"?>"
  -v - -endif
  -v +
  -e[] "<gmic-package xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"gmic_doc.xsd\">
\n<name>"$_name"</name>
\n<section>
\n  <name>List of commands</name>"
  -v -
  -m "don : -_document_gmic_desc_on_xml"
  -m "doff : -_document_gmic_desc_off_xml"
  _is_subsection=0
  _is_command=0
  _is_desc=0

_document_gmic_desc_on_xml :
  -v -
  -if $_is_desc
    -u ""
  -else
    -u "    <description>\n"
    _is_desc=1
  -endif
  -v +

_document_gmic_desc_off_xml :
  -v -
  -if $_is_desc
    -u "    </description>\n"
    _is_desc=0
  -else -u ""
  -endif
  -v +

_document_gmic_subsection_xml :
  -v +
  -if $_is_subsection
    -if $_is_command -e[] @{-doff}"  </function>" -endif
    -e[] @{-doff}"</subsection>"
  -endif
  -e[] @{-doff}"<subsection>
\n  <name>"@{0,t}"</name>"
  -v -
  _is_subsection=1
  _is_command=0

_document_gmic_declaration_xml :
  -_document_gmic_replace_xml
  -v +
  -if $_is_command -e[] @{-doff}"  </function>" -endif
  -e[] @{-doff}"  <function>"
  -v -
  _is_command=1
  -if {{@{-1,t}'=='"(*)"}" || "{@{-1,t}'=='"(+)"}} qualifier=" "@{-1,t} -rm[-1] -else qualifier="" -endif
  s1="" s0=" |"
  -v +
  -e[] "    <name>"@{0,t}"</name>"
  -if {@#>1}
    -e[] "    <arguments>"
    -repeat {@#-1}
      -e[] "      "@{{1+$>},t}${s{$<==0}}
    -done
    -e[] "    </arguments>"
  -endif
  -v -

_document_gmic_description_xml :
  -_document_gmic_replace_xml
  -v +
  -e[] @{-don}"      "@{0,t}
  -v -

_document_gmic_example_xml :
  -_document_gmic_replace_xml
   -if $_filename -else # Generate picture only if the file doesn't yet exist.
      -m "foo : "@{-1,t}
      -l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
      -uncommand foo
   -endif
   -v +
   -e[] @{-doff}"    <example>"
   -e[] "      <command>"@{0,t}"</command>"
   -e[] "      <result>"$_filename"</result>"
   -e[] "    </example>"
   -v -

_document_gmic_footer_xml : -skip $1
  -v +
  -if $_is_command -e[] @{-doff}"</function>" -endif
  -if $_is_subsection -e[] @{-doff}"</subsection>" -endif
  -e[] @{-doff}"</section>
\n</gmic-package>"
  -v -
  -uncommand don
  -uncommand doff

_document_gmic_replace_xml :
  -replace_seq {'&'},@{-quote\ {'&amp;'}} # Replace '&'
  -replace_seq {'<'},@{-quote\ {'&lt;'}}  # Replace '<'
  -replace_seq {'>'},@{-quote\ {'&gt;'}}  # Replace '>'


# Define document_gmic commands for LateX output.
_document_gmic_header_latex :
  -if $1 -v +
    -e[] "\\documentclass[a4paper,10pt,twoside]{book}
\n\\usepackage{hyperref,fancyhdr,graphicx,amssymb,amsmath,times,makeidx}
\n\\graphicspath{{"$_path"}}
\n\\pagestyle{fancyplain}
\n\\lhead[\\fancyplain{}{\\textbf\\thepage}]{\\fancyplain{}{\\rightmark}}
\n\\rhead[\\fancyplain{}{\\leftmark}]{\\fancyplain{}{\\textbf\\thepage}}
\n\\cfoot{}
\n\\setlength{\\textwidth}{5.875in}
\n\\setlength{\\parindent}{0pc}
\n\\setlength{\\hoffset}{-0.8cm}
\n\\setcounter{tocdepth}{1}
\n\\sloppy{}
\n\\renewcommand\\indexname{Index of commands}
\n\\makeindex
\n\\begin{document}
\n\\tableofcontents"
  -v - -endif
  -v + -e[] "\n\\chapter{List of commands}" -v -
  -m "eon : -_document_gmic_ex_on_latex"
  -m "eoff : -_document_gmic_ex_off_latex"
  _is_desc=0
  _is_ex=0
  _shortcut=0

_document_gmic_ex_on_latex :
  -v -
  -if $_is_ex
    -u "\\\\"
  -else
    -u "\\begin{center}"
    _is_ex=1
  -endif
  -v +

_document_gmic_ex_off_latex :
  -v -
  -if $_is_ex
    -u "\\end{center}"
    _is_ex=0
  -else
    -u ""
  -endif
  -v +

_document_gmic_subsection_latex :
  _is_desc=0
  -_document_gmic_replace_latex
  -v + -e[] @{-eoff}"\n\\section{"@{0,t}"}" -v -

_document_gmic_declaration_latex :
  _is_desc=0
  -if {{@{-1,t}'=='"(*)"}" || "{@{-1,t}'=='"(+)"}} qualifier=@{-1,t} -rm[-1] -else qualifier="" -endif
  e1="\\\\~\\\\" e0="~~~$|$\\\\"
  s1="\\hspace*{2.2cm}" s0=""
  -_document_gmic_replace_latex

  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    -v +
    -e[] @{-eoff}"\n\n\\subsection{\\emph{-"@{0,t}"\\index{-"@{0,t}"}} "$qualifier"}\\vspace*{-0.5em}"
    -if {@#>1}
      -e[] "~\\\\\\textbf{Arguments: } "
      -repeat {@#-1}
         -e[] ${s{$>!=0}}"{\\small \\texttt{"@{{1+$>},t}"}}"${e{$<==0}}
      -done
    -endif
    -v -
  -endif

_document_gmic_description_latex :
  s0="" s1="~\\\\" s=${s$_is_desc}
  -_document_gmic_replace_latex
  -if {@{-1,0-12}'=='{'"Default value"'}}  # Reached line as '#@gmic : Default value(s) : ... '.
    -s +,{':'} -l[^0] -a y -endl -autocrop {':'} -autocrop {'" "'}
    -if {@#>1}
      -replace_seq[1] @{-quote\ {'" and "'}},@{-quote\ {'"} and \\\\texttt{"'}}
      -v + -e[] @{-eoff}$s"~\\\\\\textbf{"@{0,t}"}: {\\small \\texttt{"@{-1,t}"}}" -v -
    -else -v + -e[] @{-eoff}$s"~\\\\"@{0,t} -v -
    -endif
  -elif {@{-1,0-7}'=='{'"(eq. to "'}}      # Reached line as '#@gmic : (eq. to '-shortcut').'.
    -rows[-1] 8,100% -autocrop[-1] {'.'} -autocrop[-1] {')'} -autocrop[-1] {'" "'}
    -v + -e[] @{-eoff}$s"(\\emph{eq. to} {\\small \\texttt{"@{-1,t}"}})." -v -
  -else                                    # Reached line as '#@gmic : description'.
    -if {(i<{'A'}" || "i>{'Z'})" && "i!=40" && "i!=39} -v + -e[] @{-eoff}@{-1,t} -v -
    -else -v + -e[] @{-eoff}$s@{-1,t} -v -
    -endif
  -endif
  _is_desc=1

_document_gmic_example_latex :
  _is_desc=0
  -if $_filename -else # Generate picture only if the file doesn't yet exist.
     -m "foo : "@{-1,t}
     -l[] -v -99 -reset -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
     -uncommand foo
  -endif
  -_document_gmic_replace_latex
  -v +
  -e[] @{-eon}"\\includegraphics[keepaspectratio=true,height=7cm,width=\\textwidth]{"$_filename"}\\\\"
  -e[] "{\\footnotesize \\textbf{Example "$_example"~:} \\texttt{"@{-1,t}"}}"
  -v -

_document_gmic_footer_latex :
  -if $_shortcut # Document shortcuts.
    ({'"Commands shortcuts"'}) -_document_gmic_subsection_latex[-1] -rm[-1]
    -v + -repeat $_shortcut
      -e[] "$\\bullet$~'\\texttt{-"${_shortcut$>}"}' "${_shortcutqualifier$>}"~is equivalent to~~'\\texttt{"${_shortcutlink$>}"}'.\\\\"
    -done -v -
  -endif
  -if $1
    -v +
    -e[] "
\n\\printindex
\n~\\\\$\\square$~End of document.
\n\n\\end{document}"
    -v -
  -endif
  -uncommand eon
  -uncommand eoff

_document_gmic_replace_latex :
  -replace_seq {'\\'},@{-quote\ {'"\\\\textbackslash "'}} # Replace '\'
  -replace_seq {'_'},@{-quote\ {'\\\\_'}} # Replace '_'
  -replace_seq {'%'},@{-quote\ {'\\\\%'}} # Replace '%'
  -replace_seq {'#'},@{-quote\ {'\\\\%'}} # Replace '#'
  -replace_seq {'^'},@{-quote\ {'"\\\\textasciicircum "'}} # Replace '^'
  -replace_seq {'$'},@{-quote\ {'\\\\$'}} # Replace '$'
  -replace_seq {'\{'},@{-quote\ {'\\\\\{'}} # Replace '{'
  -replace_seq {'\}'},@{-quote\ {'\\\\\}'}} # Replace '}'
  -replace_seq {'&'},@{-quote\ {'\\\\&'}} # Replace '&'
  -replace_seq {'|'},@{-quote\ {'~$|$~'}} # Replace '|'
  -replace_seq {'<'},@{-quote\ {'$\<$'}} # Replace '<'
  -replace_seq {'>'},@{-quote\ {'$\>$'}} # Replace '>'

# Define document_gmic commands for images-only output.
_document_gmic_header_images : -skip $1
  -v +
  -e[] "\n - Generate example images from set of commands '"$_name"'.\n"
  -v -

_document_gmic_subsection_images : -_document_gmic_subsection_ascii
_document_gmic_declaration_images : _command_name=@{0,t}
_document_gmic_description_images :

_document_gmic_example_images :
  -v +
  -e[] "    . Command '-"$_command_name"': $ "@{-1,t}
  -v -
  -if $_filename -else # Generate picture only if the file doesn't yet exist.
     -m "foo : "@{-1,t}
     -l[] -v -1 -reset -v -99 -foo -v -1 -_document_gmic -o $_filename,85 -rm -endl
     -uncommand foo
  -endif

_document_gmic_footer_images : -skip $1
  -v +
  -e[] "\n - [ All done! ]\n\n"
  -v -

# Define document_gmic commands for ascii output.
_document_gmic_header_ascii : -skip $1
  _shortcut=0

_document_gmic_subsection_ascii :
  -v +
  -e[] "\n ** "@{0,t}":"
  -v -

_document_gmic_declaration_ascii :
  -if {{@{-1,t}'=='"(*)"}" || "{@{-1,t}'=='"(+)"}} qualifier=" "@{-1,t} -rm[-1] -else qualifier="" -endif
  -if {@#>1" && "{@{-1,0-6}'=='{'"eq. to "'}}}  # Declaration of a shortcut command.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-1,t}
    _shortcutqualifier$_shortcut=$qualifier
    _shortcut={$_shortcut+1}
  -else                                         # Declaration of a regular command.
    -v + -e[] "\n    -"@{0,t}${qualifier}":" -v - -rm[0]
    -if @#
      s="                        "
      -y x
      -repeat {@#-1} ({'" |"'}) -a[$>,-1] x -done  # Insert ' |'.
      -repeat @# -l[$>] -_document_gmic_split_ascii 80,0
        -repeat {@#-1} ({'\n$s"  "'}) -a[$>,-1] x -done
        -a x -v + -e[] $s@{0,t} -v -
      -endl -done
    -endif
    -v + -e[] "" -v -
  -endif

_document_gmic_description_ascii :
  s="        " bs0="\n" bs1="\\\\\n            "
  -y x -_document_gmic_split_ascii 96
  -repeat {@#-1} ({'${bs$_is_example}$s"  "'}) -a[$>,-1] x -done -a x
  -v + -repeat @# -e[] $s@{$>,t} -v - -done

_document_gmic_example_ascii :

_document_gmic_footer_ascii : -skip $1
  -if $_shortcut # Document shortcuts.
    ({'"Commands shortcuts"'}) -_document_gmic_subsection_ascii[-1] -v + -e[] "" -v - -rm[-1]
    -v + -repeat $_shortcut
      -e[] "    -"${_shortcut$>}" "${_shortcutqualifier$>}": eq. to '"${_shortcutlink$>}"'."
    -done -v -
  -endif
  -v + -e[] "\n   [ Total number of commands: "$_command" ]" -v -

_document_gmic_split_ascii :
  -do -if {w>$1}
    i={$1-1}
    -repeat {$1/2} -if {C=i($1-1-$>);C==32||C==38||C==42||C==43||C==44||C==46||C==47||C==58||C==59||C==63||C==92||C==124} i={$1-1-$>} -break
    -endif -done
    --z[-1] {$i+1},100% -z[-2] 0,$i
  -endif -while {w>$1}

# Define document_gmic commands for bash auto-completion script output.
_document_gmic_header_bash : -skip $1
  -v +
  -e[] "\#
\n\#  Bash completion rules for 'gmic'.
\n\#
\n\# This file has been generated automatically.
\n\# Do not edit!
\n\#
\n\# This file should be copied/renamed in '/etc/bash_completion.d/gmic'.
\n\#
\n
\n_"$_name"()
\n{
\n\tlocal cur prev opts coms
\n\tCOMPREPLY=()
\n\tcur=\"${COMP_WORDS[COMP_CWORD]}\"
\n\tprev=\"${COMP_WORDS[COMP_CWORD-1]}\"
"
  -v -
  _opts=
  _coms=
  _argcommand=0
  _shortcut=0
  _nbopts=0
  _nbcoms=0

_document_gmic_subsection_bash :
_document_gmic_description_bash :
_document_gmic_example_bash :

_document_gmic_declaration_bash :
  _opts$_nbopts=-@{0,t}" "--@{0,t}
  _nbopts={$_nbopts+1}

  _coms$_nbcoms=@{0,t}
  _nbcoms={$_nbcoms+1}

  -if {{@{0,t}'=='"input"}" || "{@{0,t}'=='"i"}" || "\ # Manage special commands (remove arguments).
       {@{0,t}'=='"output"}" || "{@{0,t}'=='"o"}" || "\
       {@{0,t}'=='"command"}" || "{@{0,t}'=='"m"}} -return -endif
  -repeat @# -if {{@{$<,t}'=='"(*)"}||{@{$<,t}'=='"(+)"}} -rm[$<] -endif -done # Discard '(*)' and '(+)' qualifiers.
  -if {@#==2" && "{@{-1,0-6}'=='{'"eq. to "'}}} # Command is a shortcut.
    -rows[-1] 7,100% -autocrop[-1] {'.'} -autocrop[-1] {'" "'} -autocrop[-1] 39 -autocrop[-1] {'-'}
    _shortcut$_shortcut=@{0,t}
    _shortcutlink$_shortcut=@{-str2hex\ @{1,t}}
    -rm[-1]
    _shortcut={$_shortcut+1}
  -elif {@#>1} # Command is regular and has arguments.
    _command$_argcommand=@{0,t}
    -if {@{0,t}'=='"help"} _argument$_argcommand="$coms\" -- \"$cur"  # Manage help command.
    -else
      -if {@#==2} ({'>'}) -endif # Add shadow parameter when single argument.
      -discard[^0] {'" "'} -i[2--2] ({'" "'}) -a[^0] y
      _argument$_argcommand=@{1,t}
    -endif
    _argumentlink@{-str2hex\ @{0,t}}=${_argument$_argcommand}
    _argcommand={$_argcommand+1}
  -endif

_document_gmic_footer_bash : -skip $1
  -v +
  -e[] "\topts=\"\\" -repeat $_nbopts -e[] "\t      "${_opts$>}\\ -done -e[] "\t     \""
  -e[] "\n\tcoms=\"\\" -repeat $_nbcoms -e[] "\t      "${_coms$>}\\ -done -e[] "\t     \""
  -e[] "\n\tcase \"${prev}\" in"
  -repeat $_argcommand  # Regular commands with arguments.
    -e[] "\t\t\"-"${_command$>}"\" | \"--"${_command$>}"\")"
    -e[] "\t\tCOMPREPLY=( $(compgen -W \""${_argument$>}"\") )\n\t\treturn 0\n\t\t;;"
  -done
  -repeat $_shortcut # Shortcut commands (with arguments).
    -if {narg(${_argumentlink${_shortcutlink$>}})}
      -e[] "\t\t\"-"${_shortcut$>}"\" | \"--"${_shortcut$>}"\")"
      -e[] "\t\tCOMPREPLY=( $(compgen -W \""${_argumentlink${_shortcutlink$>}}"\") )\n\t\treturn 0\n\t\t;;"
    -endif
  -done
  -e[] "\tesac"
  -e[] "\n\tif [[ \"$cur\" == -* ]] ; then
\n\t\tCOMPREPLY=( $(compgen -W \"$opts\" -- \"$cur\") )
\n\telse
\n\t\t_filedir
\n\tfi
\n
\n}
\n
complete -F _"$_name" -o filenames gmic"
  -v -

# Generate a single image from a list of images, for the reference documentation.
_document_gmic :
  -repeat @# -l[$>] W$>={w} H$>={h} D$>={d} S$>={s} IS_3D$>=@{-is_3d} -endl -done
  -repeat @# -l[$>] -if @{-is_3d} -r3d 1,1,0,-80 -r3d 0,1,0,80 -snapshot3d 400 -else -n 0,255 -endif -endl -done
  --append_tiles , -if {w>900} r={round(900*100/w,0.1)} -r[^-1] $r%,$r%,1,100%,2 -endif -rm[-1]
  -repeat @# -l[$>]
    -if {s==1} -r {w},{h},1,3 -else -r {w},{h},1,3,0 -endif
    -if {w<=h&&h<256} -r2dy 256,2 -elif {h<=w&&w<256} -r2dx 256,2 -endif
    -if {w<=h&&h>512} -r2dy 512,2 -elif {h<=w&&w>512} -r2dx 512,2 -endif
    -if {h<48} -r 100%,48 -endif
    -if {w<48} -r 48,100% -endif
    -frame 1,1,0 -frame 4,4,255
  -endl -done
  N=@# -repeat $N -l[$>]
    {w},24,1,3,255
    -if {w>75}
      -if {$N>1} -if {w>110} -t[-1] Image\ [$>]:,3,3,17 -else -t[-1] [$>]:,3,3,17 -endif -endif
      -if ${IS_3D$>} 0 -t[-1] (3d\ object),0,0,13,1,255
      -else 0 -t[-1] (${W$>}x${H$>}x${D$>}x${S$>}),0,0,13,1,255
      -endif
      -negative[-1] -n[-1] 0,255 -+[-1] 164 -c[-1] 0,255 -to_rgb[-1]
      -j[-2] [-1],{@{-2,w}-w-5},{@{-2,h}-h-5} -rm[-1]
    -else -t[-1] [$>]:,3,3,17 -endif
    -rv[-2,-1] -a[-2,-1] y
  -endl -done
  -- 255 -append_tiles , -+ 255
  -if {w<256} -- 255 -r 256,100%,1,3,0,0,0.5,0.5 -+ 255 -endif
  -if {h<256} -- 255 -r 100%,256,1,3,0,0,0.5,0.5 -+ 255 -endif

#@gmic e : eq. to '-echo'. : (*)

#@gmic echo : message : (*)
#@gmic : Output specified message, on the error output.
#@gmic : (eq. to '-e').
#@gmic : Command subset (if any) stands for displayed scope indices instead of image indices.

#@gmic echo_file : filename,message
#@gmic : Output specified message, appending it to specified output file.
#@gmic : (similar to '-echo' for specified output file stream).
echo_file : -skip ${2='\n'}
  -v - ({"'${2--1}\n'"}) -o[-1] raw:$1,uchar -rm[-1] -v +

#@gmic echo_stdout : message
#@gmic : Output specified message, on the standard output (stdout).
#@gmic : (similar to '-echo' for output on standard output instead of standard error).
echo_stdout :
  -v - ({'"$*"\n'}) -o[-1] -.raw,uchar -rm[-1] -v +

#@gmic function1d : 0<=smoothness<=1,x0>=0,y0,x1>=0,y1,...,xn>=0,yn
#@gmic : Input continuous 1d function from specified list of keypoints (xk,yk)
#@gmic : in range [0,max(xk)] (xk are positive integers).
#@gmic : Default values: 'smoothness=1' and 'x0=y0=0'.
#@gmic : $ -function1d 1,0,0,10,30,40,20,70,30,80,0 --display_graph 400,300
function1d : -check "${1=1}>=0 && $1<=1" -skip ${2=0},${3=0}
  -e[^-1] "Input continuous 1d function, with smoothness $1 and keypoints (${2--1})."
  -v -

  # Normalize input coordinates.
  -if {$#<5} {max(0,$2)+1},1,1,1,$3 -v + -return -endif
  (${2--1}) -r[-1] 2,{w/2},1,1,-1 -sort[-1] +,y -s[-1] x,2 -round[-2] 1 -a[-2,-1] x

  # Estimate pointwise forward/backward slopes.
  --shift[-1] 0,1,0,0,1 --[-1] [-2] -*[-1] -1   # Backward derivatives.
  --shift[-2] 0,-1,0,0,1 --[-1] [-3]            # Forward derivatives.
  --*[-2] {$1/2} --*[-2] {1-$1/2} -+[-2,-1]     # Forward tangents.
  -*[-3] {1-$1/2} -*[-2] {$1/2} -+[-3,-2]       # Backward tangents.
  -s[-2,-1] x -+[-4,-2] 1e-10
  -/[-3] [-4] -/[-1] [-2] -rm[-4,-2]            # Forward and backward slopes.
  -a[-3--1] x                                   # Append slopes to coordinates.

  # Compute multi-spline curve.
  {@{-1,(0,{h-1})}+1}
  -repeat {@{-2,h}-1}
    xstart={if($>,@{-2,0},0)}
    -_function1d @{-2,0-1},@{-2,3},@{-2,4-6},$xstart,@{-2,4} -j[-2] [-1],$xstart -rm[-1]
  -shift[-2] 0,-1 -done
  -rm[-2] -nm[-1] "[1d function (${2--1})]"
  -v +

# Generate single spline function from specified coordinates (x0,y0,s0)-(x1,y1,s1), in range [t0..t1]
_function1d :
  ({$1^3},{$1^2},$1,1;\
   {3*$1^2},{2*$1},1,0;\
   {$4^3},{$4^2},$4,1;\
   {3*$4^2},{2*$4},1,0)
  ($2;$3;$5;$6) -solve[-1] [-2] -rm[-2] -transpose[-1]
  ($7,$8) -r[-1] {1+$8-$7},1,1,1,3 --^[-1] 3 --^[-2] 2 --f[-1] 1 -mv[-4] -1 -a[-4--1] y
  -**[-2,-1]

#@gmic gmicky
#@gmic : Load a new image of the G'MIC mascot 'Gmicky'.
#@gmic : $ -gmicky
gmicky :
  -e[^-1] "Load image of the G'MIC mascot 'Gmicky'."
  -v - -i http://gmic.sourceforge.net/img/gmicky_large.cimgz -nm[-1] [gmicky] -v +

#@gmic gmicky_wilber
#@gmic : Load a new image of the G'MIC mascot 'Gmicky' together with GIMP mascot 'Wilber'.
#@gmic : $ -gmicky_wilber
gmicky_wilber :
  -e[^-1] "Load image of the G'MIC mascot 'Gmicky' together with GIMP mascot 'Wilber'."
  -v - -i http://gmic.sourceforge.net/img/gmicky_wilber_large.cimgz -nm[-1] [gmicky_wilber] -v +

#@gmic heart : _width>0,_height>0
#@gmic : Input heart binary mask with specified size.
#@gmic : $ -heart ,
heart : -check "${1=512}>=1 && ${2=$1}>=1"
  -e[^-1] "Input $1x$2 heart binary mask."
  -v - -l[]
    2048,1,1,1,'t=2*pi*x/w;16*sin(t)^3'
    2048,1,1,1,'t=2*pi*x/w;13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)'
    -a c -display_parametric $1,$2,1,0,0,0
    -flood 50%,50%,0,0,0,1,0 -eq[-1] 0
    -nm "[Heart binary mask]"
  -endl -v +

#@gmic i : eq. to '-input'. : (*)

#@gmic input : [type:]filename : [type:]http://URL : [selection]x_nb_copies>0 : { width>0[%] | [image_w] },{ _height>0[%] | [image_h] },{ _depth>0[%] | [image_d] },{ _spectrum>0[%] | [image_s] },_{ value1,_value2,.. | 'formula' } : (value1{,|;|/|^}value2{,|;|/|^}..) : 0 : (*)
#@gmic : Insert a new image taken from a filename or from a copy of an existing image ['indice'],"
#@gmic : or insert new image with specified dimensions and values. Single quotes may be omitted in
#@gmic : 'formula'. Specifying argument '0' inserts an 'empty' image.
#@gmic : (eq. to '-i' | (no args)).
#@gmic : Default values: 'nb_copies=1', 'height=depth=spectrum=1' and 'value1=0'.
#@gmic : $ -input image.jpg
#@gmic : $ -i (1,2,3;4,5,6;7,8,9^9,8,7;6,5,4;3,2,1)
#@gmic : $ image.jpg (1,2,3;4,5,6;7,8,9) (255^128^64) 400,400,1,3,'if(x>w/2,x,y)*c'

#@gmic o : eq. to '-output'. : (*)

#@gmic output : [type:]filename,_format_options : (*)
#@gmic : Output selected images as one or several numbered file(s).
#@gmic : (eq. to '-o').
#@gmic : Default value: 'format_options'=(undefined).

#@gmic output_ggr : filename,_gradient_name
#@gmic : Output selected images as GIMP gradient files.
#@gmic : If no gradient name is specified, it is deduced from the filename.
output_ggr : -skip "${2=}"
 -e[^-1] "Output image$? as GIMP gradient file '$1'."
 -v - N=@#
  -repeat $N --l[$>] -r 1,{w*h*d},1,100%,-1 -to_rgba -/ 255
    -if {narg("$2")} name="$2"
    -else -l[] 1 -nm[-1] "$1" ({'@{-1,b}'}) -f "if(x==0&&i>="{'a'}"&&i<="{'z'}",i-"{'a'}"+"{'A'}",i)" name=@{-1,t} -rm -endl
    -endif
    ({'"GIMP Gradient\nName: "$name\n@{0,h}\n'})
    -repeat @{0,h}
      start={_$>/@{0,h}}
      end={_($>+1)/@{0,h}}
      mid={_0.5*($start+$end)}
      rgba=@{-at[0]\ 0,$>}
      r={arg(1,$rgba)} g={arg(2,$rgba)} b={arg(3,$rgba)} a={arg(4,$rgba)}
      ({'$start" "$mid" "$end" "$r" "$g" "$b" "$a" "$r" "$g" "$b" "$a" 0 0\n"'})
    -done
    -rm[0] -a x
    -if {$N>1} -o raw:@{"-filename \"$1\",$>"},uchar -else -o raw:"$1",uchar -endif
    -rm
  -endl -done -v +

#@gmic on : eq. to '-outputn'.
on :
  -v - __s="$?" -v +
  -_outputn $*

#@gmic outputn : filename
#@gmic : Output selected images as automatically numbered filenames in repeat..done loops.
#@gmic : (eq. to '-on').
outputn :
  -v - __s="$?" -v +
  -_$0 $*

_outputn :
  -v - filename=@{-filename\ "$1",@{>}} -v +
  -e[0--3] "Output image"$__s" as file '"$filename"'."
  -v - -o $filename -v +

#@gmic op : eq. to '-outputp'.
op :
  -v - __s="$?" -v +
  -_outputp $*

#@gmic outputp : prefix
#@gmic : Output selected images as prefixed versions of their original filenames.
#@gmic : (eq. to '-op').
#@gmic : Default value: 'prefix=_'.
outputp :
  -v - __s="$?" -v +
  -_$0 $*

_outputp : -skip ${1="_"}
  -if {@#>1} -e[0--4] "Output image"$__s" as their initial locations, prefixed by '$1'."
  -else -e[0--4] "Output image"$__s" as its initial location, prefixed by '$1'."
  -endif
  -v - -repeat @# -o[$>] @{$>,f}$1@{$>,b}.@{$>,x} -done -v +

#@gmic ow : eq. to '-outputw'.
ow :
  -v - __s="$?" -v +
  -_outputw $*

#@gmic outputw
#@gmic : Output selected images by overwritting their original location.
#@gmic : (eq. to '-ow').
outputw :
  -v - __s="$?" -v +
  -_$0 $*

_outputw :
  -if {@#>1} -e[0--4] "Output image"$__s" as their initial location."
  -else -e[0--4] "Output image"$__s" as its initial location."
  -endif
  -v - -repeat @# -o[$>] @{$>,n} -done -v +

#@gmic plot : _plot_type,_vertex_type,_xmin,_xmax,_ymin,_ymax : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax : (+)
#@gmic : Display selected image or formula in an interactive viewer (use the instant window [0] if opened).
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'xmin','xmax','ymin','ymax' set the coordinates of the displayed xy-axes.
#@gmic : Default values: 'plot_type=1', 'vertex_type=1' and 'xmin=xmax=ymin=ymax=0 (auto)'.

#@gmic p : eq. to '-print'. : (*)

#@gmic print : (*)
#@gmic : Output information on selected images, on the standard error (stderr).
#@gmic : (eq. to '-p').

#@gmic rainbow_lut
#@gmic : Input a 256-entries RGB colormap of rainbow colors.
#@gmic : $ image.jpg -rainbow_lut --luminance[-2] -map[-1] [-2]
rainbow_lut :
  -e[^-1] "Input RGB colormap of 256 rainbow colors."
  -v -
  (2,10,13,13,15,16,15,15,18,23,26,31,33,37,38,39,42,42,44,45,44,44,45,45,44,42,44,45,45,49,50,52,54,55,56,57,\
   56,56,57,57,58,57,58,58,59,58,60,59,58,59,59,59,59,59,60,60,59,59,59,59,60,59,59,59,59,59,59,59,58,58,58,56,\
   56,54,51,48,44,39,33,20,5,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,25,50,66,81,90,102,109,118,129,137,144,152,158,168,178,183,190,199,207,\
   213,220,227,230,236,242,246,250,255,255,253,253,253,252,251,250,250,249,248,248,247,248,246,246,246,245,246,\
   245,245,245,246,246,246,246,246,246,246,246,245,245,245,245,245,244,245,244,245,245,245,245,245,245,245,245,\
   245,244,244,245,245,243,239,235,230,226,220,216,211,204,201,194,190,184,176,171,164,160,152,144,138,130,122,\
   114,107,96,87,78,69,57,50,46,38,31,19,5^3,10,14,15,17,18,19,18,19,23,25,30,31,35,37,39,42,44,45,48,49,50,51,\
   52,53,56,59,63,66,66,68,69,71,73,74,75,76,76,77,78,79,79,80,81,81,82,82,83,84,84,84,84,84,85,85,86,86,86,86,\
   87,88,87,86,86,86,86,88,89,89,90,92,92,94,96,99,102,104,107,111,117,120,126,130,136,142,149,155,161,167,172,\
   176,178,179,179,178,178,178,178,177,177,177,176,176,176,176,175,173,173,174,173,172,171,171,171,171,171,171,\
   171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,173,173,173,175,176,178,178,178,181,182,184,\
   186,186,190,192,193,195,198,200,201,204,206,209,211,208,206,202,197,194,190,185,182,178,172,167,162,157,152,\
   144,139,132,127,121,115,108,102,98,92,87,79,75,69,64,62,58,55,52,50,49,47,47,47,47,47,47,47,47,46,46,46,46,\
   45,44,44,42,42,41,41,40,39,38,37,36,34,31,30,29,30,30,31,32,32,32,33,33,34,34,33,34,33,32,31,31,30,29,26,25,\
   23,21,19,15,13,13,16,18,18,18,17,15,13,12,9,2^6,19,25,32,41,49,55,65,71,79,84,90,96,102,106,111,117,121,128,\
   132,134,139,143,146,149,152,155,156,157,159,159,160,161,162,163,164,164,165,166,167,166,165,166,166,167,167,\
   168,168,168,169,169,169,169,170,170,170,170,170,170,170,171,170,170,170,170,170,171,171,172,173,173,173,175,\
   177,179,180,183,185,187,190,193,198,201,206,213,219,225,227,227,223,218,214,204,199,192,184,179,172,168,162,\
   156,151,145,139,133,126,120,113,106,98,90,85,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,84,84,82,82,82,\
   82,82,83,83,81,81,81,80,80,78,78,78,76,74,73,73,71,72,69,68,67,65,62,59,58,56,51,50,49,45,43,40,38,37,35,32,\
   31,32,32,33,33,34,34,35,36,36,37,38,39,42,44,45,46,46,47,48,49,48,48,48,48,48,48,48,48,48,48,47,47,47,47,46,\
   45,45,43,43,42,41,40,39,38,37,38,38,37,37,38,38,38,38,39,40,39,40,39,40,40,39,39,38,38,37,35,34,32,30,28,26,\
   23,20,16,14,12,16,16,18,18,17,16,14,13,9,2)
  -nm[-1] [rainbow\ lut]
  -v +

#@gmic roddy
#@gmic : Load a new image of the G'MIC Rodilius mascot 'Roddy'.
#@gmic : $ -roddy
roddy :
  -e[^-1] "Load image of the G'MIC Rodilius mascot 'Roddy'."
  -v - -i http://gmic.sourceforge.net/img/roddy_large.cimgz -nm[-1] [roddy] -v +

#@gmic remove_duplicates
#@gmic : Remove duplicates images in the selected images list.
#@gmic : $ (1,2,3,4,2,4,3,1,3,4,2,1) -split x -remove_duplicates -append x
remove_duplicates :
  -e[^-1] "Remove duplicates images in selected list of image$?."
  -v - -repeat @#
    base=$> off=0
    -repeat {@#-$>-1}
      comp={$base+1+$>-$off}
      -if {$comp>=@#} -break -endif
      ---[$base,$comp] -abs[-1] is_duplicate={!@{-1,+}} -rm[-1]
      -if $is_duplicate -rm[$comp] off={$off+1} -endif
    -done
  -done -v +

#@gmic remove_empty
#@gmic : Remove empty images in the selected image list.
remove_empty :
  -e[^-1] "Remove empty images in selected list of image$?."
  -v - -repeat @# -if {!@{$<,whds}} -rm[$<] -endif -done -v +

#@gmic select : feature_type,_X,_Y,_Z : (+)
#@gmic : Interactively select a feature from selected images (use the instant window [0] if opened).
#@gmic : 'feature_type' can be { 0=point | 1=segment | 2=rectangle | 3=ellipse }.
#@gmic : Arguments 'X','Y','Z' determine the initial selection view, for 3d volumetric images.
#@gmic : The retrieved feature is returned as a 3d or 6d vector containing the feature coordinates.

#@gmic sh : eq. to '-shared'. : (*)

#@gmic shared : x0[%],x1[%],y[%],z[%],v[%] : y0[%],y1[%],z[%],v[%] : z0[%],z1[%],v[%] : v0[%],v1[%] : (no args) : (*)
#@gmic : Insert shared buffers from (opt. points/rows/planes/channels of) selected images.
#@gmic : (eq. to '-sh').
#@gmic : $ image.jpg -shared 1,1 -blur[-1] 3 -remove[-1]
#@gmic : $ image.jpg -repeat {s} -shared 25%,75%,0,$> -mirror[-1] x -remove[-1] -done

#@gmic srand : value : (no args) : (*)
#@gmic : Set random generator seed.
#@gmic : If no argument is specified, a random value is used as the random generator seed.

#@gmic testimage2d : _width>0,_height>0,_spectrum>0
#@gmic : Input a 2d synthetic image.
#@gmic : Default values: 'width=512', 'height=width' and 'spectrum=3'.
#@gmic : $ -testimage2d 512
testimage2d : -check "${1=512}>0 && ${2=$1}>0 && ${3=3}>0"
  -e[^-1] "Input 2d synthetic image of size $1x$2x$3."
  -v -
  Dmax2={0.15*min($1,$2)^2}
  $1,$2,1,$3,'X=x-w/2;Y=y-h/2;a=atan2(Y,X);if(X^2+Y^2<=$Dmax2,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))'
  -polygon[-1] 4,20%,20%,60%,20%,70%,70%,35%,45%,0.9,0,255,0
  -torus3d {$1/7},{$1/20} -r3d[-1] 0,1,1,80 -col3d[-1] 128,200,255
  -object3d[-2] [-1],30%,70%,0,1,5,0,0 -rm[-1] -round[-1] 1
  -nm[-1] "[2d test image]"
  -v +

#@gmic text2img : text,_line_separator
#@gmic : Input a 2d image whose values are ASCII characters of specified input text.
#@gmic : Default value: 'line_separator= '.
#@gmic : $ -text2img "There are 4 words"
text2img : -skip "${2= }"
  -e[^-1] "Input image from text \"$1\", with line separator '$2'."
  -v - ({'"$1"'}) -l[-1] -s -,{'"$2"'} -y x -a y -nm "[\"$1\"]" -endl -v +

#@gmic type : datatype : (*)
#@gmic : Set pixel datatype for all images of the list.
#@gmic : 'datatype' can be { bool | uchar | char | ushort | short | uint | int | float | double }.
#@gmic : Depending on how your G'MIC version has been compiled, some datatypes may be unavailable
#@gmic : (typically datatypes different from 'float').

#@gmic uncommand : command_name : * : (*)
#@gmic : Discard last definition of specified custom command.
#@gmic : Set argument to '*' for discarding all existing custom commands.

#@gmic uniform_distribution : nb_levels>=1,spectrum>=1
#@gmic : Input set of uniformly distributed N-d points in [0,1]^N.
#@gmic : $ -uniform_distribution 64,3 -* 255 --distribution3d -circles3d[-1] 10
uniform_distribution : -check "isint($1) && $1>0 && isint($2) && $2>0"
  -e[^1] "Input set of $1 uniformly distributed $2-d points in [0,1]^$2."
  -v - n={round($1^(1/$2),1,1)}
  (0,1) -r[-1] $n,1,1,1,3
  -repeat {$2-1} --channels[-1] 100% -r[-1] {$n*w},1,1,1,1 -r[-2] [-1],1,1,100%,0,2 -a[-2,-1] c -done
  -r[-1] $1,1,1,$2,1 -nm[-1] "[uniform $2d distribution]" -v +

#@gmic up : eq. to '-update'.
up :
  -_update

#@gmic update
#@gmic : Update commands from the latest definition file on the G'MIC server.
#@gmic : This requires an active Internet connection and an access to the external
#@gmic : tools 'curl' or 'wget'.
#@gmic : (eq. to '-up').
update :
  -_$0

_update :
  -e[0--3] "Update commands from the latest definition file on the G'MIC server."
  -v - -m http://gmic.sourceforge.net/update@..gmic -v +

#@gmic v : eq. to '-verbose'. : (*)

#@gmic verbose : _level : { + | - } : (*)
#@gmic : Set or increment/decrement the verbosity level.
#@gmic : (eq. to '-v').
#@gmic : When 'level'>=0, G'MIC log messages are displayed on the standard error (stderr).
#@gmic : Default value: 'level=0'.

#@gmic wait : delay : (no args) : (+)
#@gmic : Wait for a given delay (in ms) since last call, or sleep during a specified delay,
#@gmic : or wait for a user event occuring on the selected instant window.
#@gmic : 'delay' can be { <0=delay+flush | 0=event | >0=delay }.
#@gmic : Command subset (if any) stands for instant window indices instead of image indices.
#@gmic : If no window indices are specified and if 'delay' is negative, the command results
#@gmic : in a hard sleep during specified delay.
#@gmic : Default value: 'delay=0'.

#@gmic warn : message : (*)
#@gmic : Print specified warning message, on the standard error (stderr).
#@gmic : Command subset (if any) stands for displayed scope indices instead of image indices.

#@gmic w : eq. to '-window'. : (+)

#@gmic window : _width[%]>=-1,_height[%]>=-1,_normalization,_fullscreen,_pos_x[%],_pos_y[%],_title : (+)
#@gmic : Display selected images into an instant window with specified size, normalization type,
#@gmic : fullscreen mode and title.
#@gmic : (eq. to '-w').
#@gmic : If 'width' or 'height' is set to -1, the corresponding dimension is adjusted to the window
#@gmic : or image size.
#@gmic : When arguments 'pos_x' and 'pos_y' are both different than -1, the window is moved to
#@gmic : the specified coordinates.
#@gmic : 'width'=0 or 'height'=0 closes the instant window.
#@gmic : 'normalization' can be { -1=keep same | 0=none | 1=always | 2=1st-time | 3=auto }.
#@gmic : 'fullscreen' can be { -1=keep same | 0=no | 1=yes }.
#@gmic : You can manage up to 10 different instant windows by using the numbered variants
#@gmic : '-w0' (default, eq. to '-w'),'-w1',..,'-w9' of the command '-w'.
#@gmic : Default values: 'width=height=normalization=fullscreen=-1' and 'title=(undefined)'.

#---------------------------------
#
#@gmic :: List manipulation
#
#---------------------------------

#@gmic k : eq. to '-keep'. : (*)

#@gmic keep : (*)
#@gmic : Keep only selected images.
#@gmic : (eq. to '-k').
#@gmic : $ image.jpg -split x -keep[0-50%:2] -append x
#@gmic : $ image.jpg -split x -keep[^30%-70%] -append x

#@gmic mv : eq. to '-move'. : (*)

#@gmic move : position[%] : (*)
#@gmic : Move selected images at specified position.
#@gmic : (eq. to '-mv').
#@gmic : $ image.jpg -split x,3 -move[1] 0
#@gmic : $ image.jpg -split x -move[50%--1:2] 0 -append x

#@gmic nm : eq. to '-name'. : (*)

#@gmic name : name,_is_modified={ 0 | 1 } : (*)
#@gmic : Set name of selected images.
#@gmic : (eq. to '-nm').
#@gmic : Argument 'is_modified' tells about the modified state of selected images.
#@gmic : Default value: 'is_modified=0'.
#@gmic : $ image.jpg -name image -blur[image] 2

#@gmic rm : eq. to '-remove'. : (*)

#@gmic remove : (*)
#@gmic : Remove selected images.
#@gmic : (eq. to '-rm').
#@gmic : $ image.jpg -split x -remove[30%-70%] -append x
#@gmic : $ image.jpg -split x -remove[0-50%:2] -append x

#@gmic rv : eq. to '-reverse'. : (*)

#@gmic reverse : (*)
#@gmic : Reverse positions of selected images.
#@gmic : (eq. to '-rv').
#@gmic : $ image.jpg -split x,3 -reverse[-2,-1]
#@gmic : $ image.jpg -split x,-16 -reverse[50%-100%] -append x

#@gmic sort_list : _ordering={ + | - },_criterion
#@gmic : Sort list of selected images according to the specified image criterion.
#@gmic : Default values: 'ordering=+', 'criterion=i'.
#@gmic : $ (1;4;7;3;9;2;4;7;6;3;9;1;0;3;3;2) -split y -sort_list + -append y
sort_list : -skip ${1=+},${2=i}
  -e[^-1] "Sort list of image$? in "@{-arg\ 1+{$1'=='+},descending,ascending}" order, "\
          "according to the image criterion '$2'."
  -v - -if @#
    i=@# -repeat @# (@{$>,$2}) -done -a[$i--1] y --f[-1] 'y' -a[-2,-1] x -sort[-1] $1,y -z[-1] 1,1
    -repeat {h} nm$>=@{$>,n} -nm[$>] sortlist$> -done
    -repeat {h} -mv[sortlist{i(0,$>)}] -1 -done
    -repeat {h} -nm[$>] ${nm{i(0,$>)}} -done
  -rm[-1] -endif -v +

#@gmic sort_str
#@gmic : Sort selected images (viewed as a list of strings) in lexicographic order.
sort_str :
  -e[^-1] "Sort image$? in lexicographic order."
  -v - -y -a x
  -repeat {round(h/4,1,1)} y={4*$>}
    -repeat @# -l[$<]
      --rows $y,{$y+3} -f[1] 'if(i>=97&&i<=122,i-32,i)' --[-1] 32 -c[-1] 0,63 -s[-1] y -*[-2] 64 -*[-3] 4096 -*[-4] 262144 -+[-4--1]
      -rv -a y -sort +,x --rows 0 -rows[0] 1,100% -label[1] -%[1] 2
      -s[1] +,0 N={@#-1}
      x0=0 -repeat {@#-1} x1={$x0+@{{1+$>},h}} --z[0] $x0,{$x1-1} x0=$x1 -done
      -rm[0-$N]
    -endl -done
  -done -s x -v +

#---------------------------------
#
#@gmic :: Mathematical operators
#
#---------------------------------

#@gmic abs : (+)
#@gmic : Compute the pointwise absolute values of selected images.
#@gmic : $ image.jpg --sub {ia} -abs[-1]
#@gmic : $ 300,1,1,1,'cos(20*x/w)' --abs -display_graph 400,300

#@gmic acos : (+)
#@gmic : Compute the pointwise arc-cosine of selected images.
#@gmic : $ image.jpg --normalize -1,1 -acos[-1]
#@gmic : $ 300,1,1,1,'x/w+0.1*u' --acos -display_graph 400,300

#@gmic + : eq. to '-add'. : (+)

#@gmic add : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Add specified value, image or mathematical expression to selected images,
#@gmic : or compute the pointwise sum of selected images.
#@gmic : (eq. to '-+').
#@gmic : $ image.jpg --add 30% -cut 0,255
#@gmic : $ image.jpg --blur 5 -normalize 0,255 -add[1] [0]
#@gmic : $ image.jpg -add '80*cos(80*(x/w-0.5)*(y/w-0.5)+c)' -cut 0,255
#@gmic : $ image.jpg -repeat 9 --rotate[0] {$>*36},1,0,50%,50% -done -add -div 10

#@gmic and : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise AND of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise AND of selected images.
#@gmic : $ image.jpg -and {128+64}
#@gmic : $ image.jpg --mirror x -and

#@gmic asin : (+)
#@gmic : Compute the pointwise arc-sine of selected images.
#@gmic : $ image.jpg --normalize -1,1 -asin[-1]
#@gmic : $ 300,1,1,1,'x/w+0.1*u' --asin -display_graph 400,300

#@gmic atan : (+)
#@gmic : Compute the pointwise arc-tangent of selected images.
#@gmic : $ image.jpg --normalize 0,8 -atan[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --atan -display_graph 400,300

#@gmic atan2 : [x_argument] : (+)
#@gmic : Compute the pointwise oriented arc-tangent of selected images.
#@gmic : Each selected image is regarded as the y-argument of the arc-tangent function, while the
#@gmic : specified image gives the corresponding x-argument.
#@gmic : $ (-1,1) (-1;1) -resize 400,400,1,1,3 -atan2[1] [0] -keep[1] -mod {pi/8}

#@gmic << : eq. to '-bsl'. : (+)

#@gmic bsl : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise left shift of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise left shift of
#@gmic : selected images.
#@gmic : (eq. to '-<<').
#@gmic : $ image.jpg -bsl 'round(3*x/w,0)' -cut 0,255

#@gmic >> : eq. to '-bsr'. : (+)

#@gmic bsr : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise right shift of selected images with specified value, image or"
#@gmic : mathematical expression, or compute the pointwise sequential bitwise right shift of
#@gmic : selected images.
#@gmic : (eq. to '->>').
#@gmic : $ image.jpg -bsr 'round(3*x/w,0)' -cut 0,255

#@gmic cos : (+)
#@gmic : Compute the pointwise cosine of selected images.
#@gmic : $ image.jpg --normalize 0,{2*pi} -cos[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --cos -display_graph 400,300

#@gmic cosh : (+)
#@gmic : Compute the pointwise hyperbolic cosine of selected images.
#@gmic : $ image.jpg --normalize -3,3 -cosh[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --cosh -display_graph 400,300

#@gmic / : eq. to '-div'. : (+)

#@gmic div : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Divide selected image by specified value, image or mathematical expression,
#@gmic : or compute the pointwise quotient of selected images.
#@gmic : (eq. to '-/').
#@gmic : $ image.jpg -div '1+abs(cos(x/10)*sin(y/10))'
#@gmic : $ image.jpg --luminance --div

#@gmic == : eq. to '-eq'. : (+)

#@gmic eq : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the boolean equality of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean equality of selected images.
#@gmic : (eq. to '-==').
#@gmic : $ image.jpg -round 40 -eq {round(ia,40)}
#@gmic : $ image.jpg --mirror x -eq

#@gmic exp : (+)
#@gmic : Compute the pointwise exponential of selected images.
#@gmic : $ image.jpg --normalize 0,2 -exp[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --exp -display_graph 400,300

#@gmic >= : eq. to '-ge'. : (+)

#@gmic ge : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the boolean 'greater or equal than' of selected images with specified value, image
#@gmic : or mathematical expression, or compute the boolean 'greater or equal than' of selected images.
#@gmic : (eq. to '->=').
#@gmic : $ image.jpg -ge {ia}
#@gmic : $ image.jpg --mirror x -ge

#@gmic > : eq. to '-gt'. : (+)

#@gmic gt : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the boolean 'greater than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'greater than' of selected images.
#@gmic : (eq. to '->').
#@gmic : $ image.jpg -gt {ia}
#@gmic : $ image.jpg --mirror x -gt

#@gmic <= : eq. to '-le'. : (+)

#@gmic le : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the boolean 'less or equal than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'less or equal than' of selected images.
#@gmic : (eq. to '-<=').
#@gmic : $ image.jpg -le {ia}
#@gmic : $ image.jpg --mirror x -le

#@gmic < : eq. to '-lt'. : (+)

#@gmic lt : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the boolean 'less than' of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean 'less than' of selected images.
#@gmic : (eq. to '-<').
#@gmic : $ image.jpg -lt {ia}
#@gmic : $ image.jpg --mirror x -lt

#@gmic log : (+)
#@gmic : Compute the pointwise base-e logarithm of selected images.
#@gmic : $ image.jpg --add 1 -log[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --log -display_graph 400,300

#@gmic log10 : (+)
#@gmic : Compute the pointwise base-10 logarithm of selected images.
#@gmic : $ image.jpg --add 1 -log10[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --log10 -display_graph 400,300

#@gmic log2 : (+)
#@gmic : Compute the pointwise base-2 logarithm of selected images
#@gmic : $ image.jpg --add 1 -log2[-1]
#@gmic : $ 300,1,1,1,'7*x/w+u' --log2 -display_graph 400,300

#@gmic max : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the maximum between selected images and specified value, image or
#@gmic : mathematical expression, or compute the pointwise maxima between selected images.
#@gmic : $ image.jpg --mirror x -max
#@gmic : $ image.jpg -max 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@gmic // : eq. to '-mdiv'. : (+)

#@gmic mdiv : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the matrix division of selected matrices/vectors by specified value, image or
#@gmic : mathematical expression, or compute the matrix division of selected images.
#@gmic : (eq. to '-//').

#@gmic min : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the minimum between selected images and specified value, image or
#@gmic : mathematical expression, or compute the pointwise minima between selected images.
#@gmic : $ image.jpg --mirror x -min
#@gmic : $ image.jpg -min 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@gmic % : eq. to '-mod'. : (+)

#@gmic mod : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the modulo of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential modulo of selected images.
#@gmic : (eq. to '-%').
#@gmic : $ image.jpg --mirror x -mod
#@gmic : $ image.jpg -mod 'R=((x/w-0.5)^2+(y/h-0.5)^2)^0.5;255*R'

#@gmic ** : eq. to '-mmul'. : (+)

#@gmic mmul : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the matrix right multiplication of selected matrices/vectors by specified value, image or
#@gmic : mathematical expression, or compute the matrix right multiplication of selected images.
#@gmic : (eq. to '-**').
#@gmic : $ (0,1,0;0,0,1;1,0,0) (1;2;3) --mmul

#@gmic * : eq. to '-mul'. : (+)

#@gmic mul : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Multiply selected images by specified value, image or mathematical expression,
#@gmic : or compute the pointwise product of selected images.
#@gmic : (eq. to '-*').
#@gmic : $ image.jpg --mul 2 -cut 0,255
#@gmic : $ image.jpg (1,2,3,4,5,6,7,8) -resize[-1] [0] -mul[0] [-1]
#@gmic : $ image.jpg -mul '1-3*abs(x/w-0.5)' -cut 0,255
#@gmic : $ image.jpg --luminance -negative[-1] --mul

#@gmic != : eq. to '-neq'. : (+)

#@gmic neq : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the boolean inequality of selected images with specified value, image or
#@gmic : mathematical expression, or compute the boolean inequality of selected images.
#@gmic : (eq. to '-!=').
#@gmic : $ image.jpg -round 40 -neq {round(ia,40)}

#@gmic or : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise OR of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise OR of selected images.
#@gmic : $ image.jpg -or 128
#@gmic : $ image.jpg --mirror x -or

#@gmic ^ : eq. to '-pow'. : (+)

#@gmic pow : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Raise selected image to the power of specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential powers of selected images.
#@gmic : (eq. to '-^').
#@gmic : $ image.jpg -div 255 --pow 0.5 -mul 255
#@gmic : $ image.jpg -gradient -pow 2 -add -pow 0.2

#@gmic rol : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise left rotation of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise left rotation of
#@gmic : selected images.
#@gmic : $ image.jpg -rol 'round(3*x/w,0)' -cut 0,255

#@gmic ror : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise right rotation of selected images with specified value, image or
#@gmic : mathematical expression, or compute the pointwise sequential bitwise right rotation of
#@gmic : selected images.
#@gmic : $ image.jpg -ror 'round(3*x/w,0)' -cut 0,255

#@gmic sign : (+)
#@gmic : Compute the pointwise sign of selected images.
#@gmic : $ image.jpg --sub {ia} -sign[-1]
#@gmic : $ 300,1,1,1,'cos(20*x/w+u)' --sign -display_graph 400,300

#@gmic sin : (+)
#@gmic : Compute the pointwise sine of selected images.
#@gmic : $ image.jpg --normalize 0,{2*pi} -sin[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --sin -display_graph 400,300

#@gmic sinc : (+)
#@gmic : Compute the pointwise sinc function of selected images.
#@gmic : $ image.jpg --normalize {-2*pi},{2*pi} -sinc[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --sinc -display_graph 400,300

#@gmic sinh : (+)
#@gmic : Compute the pointwise hyperbolic sine of selected images.
#@gmic : $ image.jpg --normalize -3,3 -sinh[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --sinh -display_graph 400,300

#@gmic sqr : (+)
#@gmic : Compute the pointwise square function of selected images.
#@gmic : $ image.jpg --sqr
#@gmic : $ 300,1,1,1,'40*x/w+u' --sqr -display_graph 400,300

#@gmic sqrt : (+)
#@gmic : Compute the pointwise square root of selected images.
#@gmic : $ image.jpg --sqrt
#@gmic : $ 300,1,1,1,'40*x/w+u' --sqrt -display_graph 400,300

#@gmic - : eq. to '-sub'. : (+)

#@gmic sub : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Subtract specified value, image or mathematical expression to selected images,
#@gmic : or compute the pointwise difference of selected images.
#@gmic : (eq. to '--').
#@gmic : $ image.jpg --sub 30% -cut 0,255
#@gmic : $ image.jpg --mirror x -sub[-1] [0]
#@gmic : $ image.jpg -sub 'i(w/2+0.9*(x-w/2),y)'
#@gmic : $ image.jpg --mirror x -sub

#@gmic tan : (+)
#@gmic : Compute the pointwise tangent of selected images.
#@gmic : $ image.jpg --normalize {-0.47*pi},{0.47*pi} -tan[-1]
#@gmic : $ 300,1,1,1,'20*x/w+u' --tan -display_graph 400,300

#@gmic tanh : (+)
#@gmic : Compute the pointwise hyperbolic tangent of selected images.
#@gmic : $ image.jpg --normalize -3,3 -tanh[-1]
#@gmic : $ 300,1,1,1,'4*x/w+u' --tanh -display_graph 400,300

#@gmic xor : value[%] : [image] : 'formula' : (no args) : (+)
#@gmic : Compute the bitwise XOR of selected images with specified value, image or mathematical
#@gmic : expression, or compute the pointwise sequential bitwise XOR of selected images.
#@gmic : $ image.jpg -xor 128
#@gmic : $ image.jpg --mirror x -xor

#---------------------------------
#
#@gmic :: Values manipulation
#
#---------------------------------

#@gmic apply_curve : 0<=smoothness<=1,x0,y0,x1,y1,x2,y2,...,xN,yN
#@gmic : Apply curve transformation to image values.
#@gmic : Default values: 'smoothness=1', 'x0=0', 'y0=100'.
#@gmic : $ image.jpg --apply_curve 1,0,0,128,255,255,0
apply_curve : -check "${1=1}>=0 && $1<=1" -skip ${2=0},${3=100}
  -e[^-1] "Apply intensity curve with smoothness $1 and keypoints (${2--1}) on image$?."
  -v - -function1d ${^0} -map[^-1] [-1] -rm[-1] -v +

#@gmic apply_gamma : gamma>=0
#@gmic : Apply gamma correction to selected images.
#@gmic : $ image.jpg --apply_gamma 2
apply_gamma : -check $1>=0
  -e[^-1] "Apply Gamma-correction to image$?, with gamma $1."
  -if {$1==1} -return -endif
  -v - -repeat @# -l[$>] mM={im},{iM} -n 0,1 -^ {1/$1} -n $mM -endl -done -v +

#@gmic balance_gamma : _ref_color1,...
#@gmic : Apply color balance transformation on selected image, with respect to specified reference color.
#@gmic : Default values: 'ref_color1=128'.
#@gmic : $ image.jpg --balance_gamma 128,64,64
balance_gamma : -skip ${1=128}
  -e[^-1] "Apply color balance transformation on image$?, with gamma curve and reference color ("${^0}")."
  -v - -repeat @# -l[$>]
    (${^0}) -r[-1] @{-2,s},1,1,1,0,1 -s[-2] c -/[-1] 255
    -repeat {@#-1} -/[$>] 255 -^[$>] {log(@{-1,$>})/log(@{$>,a})} -*[$>] 255 -done
    -rm[-1] -a c -n 0,255
  -endl -done -v +

#@gmic complex2polar
#@gmic : Compute complex to polar transforms of selected images.
#@gmic : $ image.jpg --fft -complex2polar[-2,-1] -log[-2] -shift[-2] 50%,50%,0,0,2 -remove[-1]
complex2polar :
  -e[^-1] "Compute complex to polar transforms of image$?."
  -v - -repeat {int(@#/2)} -l[{2*$>},{2*$>+1}]
    -r[1] [0],3 --atan2[1] [0] -nm[-1] @{1,n},1 -sqr[-3,-2] -+[-3,-2] -sqrt[-2]
  -endl -done -v +

#@gmic compress_rle
#@gmic : Compress selected images as 2xN data matrices, using RLE algorithm.
#@gmic : $ image.jpg -resize2dy 100 -quantize 4 -round --compress_rle --uncompress_rle[-1]
compress_rle :
  -e[^-1] "Compress image$?, using RLE algorithm."
  -v - -repeat @# -l[$>] nm=@{0,n} im={im} whds={w};{h};{d};{s};$im
    -- $im -y x ({@{0,-1}+1}) -a x -r 100%,3
    -f[-1] '>if(y==0,i,if(y==1,if(i(x,0)==i(x+1,0),-1,x),if(i(x-1,1)==-1,i(x-1,2)+1,1)))'
    -z 0,{w-2} -s y,3 -discard[1] -1 -warp[0,2] [1],0,0 -rm[1]
    -*[-1] -1 -rv -a x -y -discard -1 -f '>if(i(0,y-1)<0&&i==0&&i(0,y+1)<0,-1,i)' -discard -1
     -i[0] ($whds) -a y -nm $nm,1
  -endl -done -v +

#@gmic cumul
#@gmic : Compute the cumulative function of specified image data.
#@gmic : $ image.jpg --histogram --cumul[-1] -display_graph[-2,-1] 400,300,3
cumul :
  -e[^-1] "Compute cumulative of function$?."
  -v - -repeat @# -l[$>]
    dim={w},{h},{d},{s} -y x
    -repeat {round(log2(w),1,1)} --shift[-1] {2^$>} -+[-2,-1] -done
    -r $dim,-1
  -endl -done -v +

#@gmic c : eq. to '-cut'. : (+)

#@gmic cut : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (no args) : (+)
#@gmic : Cut values of selected images in specified range.
#@gmic : (eq. to '-c').
#@gmic : (noargs) runs interactive mode (uses the instant window [0] if opened).
#@gmic : $ image.jpg --add 30% -cut[-1] 0,255
#@gmic : $ image.jpg --cut 25%,75%

#@gmic discard : value,_remove_if_not_found = { 0 | 1 }.
#@gmic : Remove specified value in selected images and return results as single-column vector.
#@gmic : Default value: 'remove_if_not_found=0'.
#@gmic : $ (1;2;3;4;3;2;1) --discard 2
discard : -skip ${2=0}
  -e[^-1] "Remove value $1 in image$?."
  -v - -repeat @# -l[$>]
    -s -,$1 -a y
    -if {!@#" && "!$2} 1,1,1,1,$1 -endif
  -endl -done -v +

#@gmic eigen2tensor
#@gmic : Recompose selected pairs of eigenvalues/eigenvectors as 2x2 or 3x3 tensor fields.
eigen2tensor :
  -e[^-1] "Recompose pairs in eigen field$? as 2x2 or 3x3 tensor fields."
  -v - -repeat {@#/2} -l[$>,{$>+1}] nm=@{0,n}
    -if {s==2} # 2d tensors.
      -s[-1] c
      --sqr[-1] -*[-2] [-3] -sqr[-3] # u^2 uv v^2
      -sh[-1] --*[-3] -1
      -sh[-5]     # v^2 -uv u^2
      -a[-3--1] c -a[-4--2] c
      -sh[-3] 0,0 -*[-3,-1]          # l1*(u^2;uv;v^2)
      -sh[-3] 1,1 -*[-2,-1]          # l2*(v^2;-uv;u^2)
      -rm[-3] -+[-2,-1]
    -elif {s==6} # 3d tensors.
      -s[-1] c
      -l[-6--4] --sqr[-2] --*[-2,-3] --sqr[-3] -*[-5] [-6] -*[-4] [-6] -sqr[-6] -a c -endl
      -l[-3--1] --sqr[-2] --*[-2,-3] --sqr[-3] -*[-5] [-6] -*[-4] [-6] -sqr[-6] -a c -endl
      -s[-3] c
      --[-5] [-3] --[-4] [-3] -*[-2] [-5] -*[-1] [-4]
      (1^0^0^1^0^1) -r[-1] [-3] -*[-1] [-4] -rm[-6--4] -+[-3--1]
    -else -error[0--3] "Invalid image ["{@#-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2d or 3d eigenvectors."
    -endif
  -nm $nm,1 -endl -done -v +

#@gmic endian : (*)
#@gmic : Reverse data endianness of selected images.

#@gmic equalize : _nb_levels>0[%],_value_min[%],_value_max[%]
#@gmic : Equalize histograms of selected images.
#@gmic : If value range is specified, the equalization is done only for pixels in the specified
#@gmic : value range.
#@gmic : Default values: 'nb_levels=256', 'value_min=0%' and 'value_max=100%'.
#@gmic : $ image.jpg --equalize
#@gmic : $ image.jpg --equalize 4,0,128

#@gmic f : eq. to '-fill'. : (+)

#@gmic fill : value1,_value2,.. : [image] : 'formula' : (+)
#@gmic : Fill selected images with values read from the specified value list, existing image
#@gmic : or mathematical expression. Single quotes may be omitted in 'formula'.
#@gmic : (eq. to '-f').
#@gmic : $ 4,4 -fill 1,2,3,4,5,6,7
#@gmic : $ 4,4 (1,2,3,4,5,6,7) -fill[-2] [-1]
#@gmic : $ 400,400,1,3 -fill "X=x-w/2; Y=y-h/2; R=sqrt(X^2+Y^2); a=atan2(Y,X); if (R<=180,255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))"

#@gmic float2int8
#@gmic : Convert selected float-valued images to 8bits integer representations.
float2int8 :
  -e[^-1] "Convert float-valued image$? to 8bits integer representations."
  -v - -repeat @# -l[$>]
    -s c -repeat @# -l[$>]
      m={im} M={iM} -quantize 16777216,0,1
      -->> 8 -and[-1] 255 --and[-2] 255 ->>[-3] 16
      ({'$m,$M'}) -a y
    -endl -done -a c
  -endl -done -v +

#@gmic int82float
#@gmic : Convert selected 8bits integer representations to float-valued images.
int82float :
  -e[^-1] "Convert 8bits integer representation$? to float-valued image$?."
  -v - -repeat @# -l[$>]
    -s c -repeat @# -l[$>]
      -sh[-1] {h-1},{h-1},0,0 m=@{-1,t} -rm[-1]
      -rows 0,{h-2} -s y,3 -*[-3] 65536 -*[-2] 256 -or -n $m
    -endl -done -a c
  -endl -done -v +

#@gmic index : { [palette] | predefined_palette },0<=_dithering<=1,_map_palette={ 0 | 1 } : (+)
#@gmic : Index selected vector-valued images by specified vector-valued palette.
#@gmic : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@gmic : Default values: 'dithering=0' and 'map_palette=0'.
#@gmic : $ image.jpg --index 1,1,1
#@gmic : $ image.jpg (0;255;255^0;128;255^0;0;255) --index[-2] [-1],1,1

#@gmic image_integral
#@gmic : Compute the image integral (summed area table) of selected images.
#@gmic : $ image.jpg --image_integral
image_integral :
  -e[^-1] "Compute the image integral of image$?."
  -v - -f '>i+i(x-1,y)' -f '>i+i(x,y-1)' -v +

#@gmic map : [palette] : predefined_palette : (+)
#@gmic : Map specified vector-valued palette to selected indexed scalar images.
#@gmic : 'predefined_palette' can be { 0=default | 1=HSV | 2=lines | 3=hot | 4=cool | 5=jet | 6=flag | 7=cube }.
#@gmic : $ image.jpg --luminance -map[-1] 3
#@gmic : $ image.jpg --rgb2ycbcr -split[-1] c (0,255,0) -resize[-1] 256,1,1,1,3 -map[-4] [-1] -remove[-1] -append[-3--1] c -ycbcr2rgb[-1]

#@gmic map_clut
#@gmic : Map RGB color LUT image (regarded as the last image) to all other selected images.
#@gmic : $ image.jpg -uniform_distribution {2^5},3 -mirror[-1] x --map_clut
map_clut :
  -e[^-1] "Map color LUT image, using image$?."
  -if {@#<2} -return -endif
  -v - -to_color[0--2] -to_rgb[-1]
  l={round((w*h*d)^(1/3))} -r[-1] $l,$l,$l,3,-1
  -repeat {@#-1} -l[$>,-1] -split_opacity[0] -/[0] {256/$l}
    --warp[-1] [0],0,1,1
    -rm[0] -mv[-1] 0 -a[^-1] c
  -endl -done -rm[-1] -v +

#@gmic mix_channels : (a00,...,aMN)
#@gmic : Apply specified matrix to channels of selected images.
#@gmic : $ image.jpg --mix_channels (0,1,0;1,0,0;0,0,1)
mix_channels :
  -e[^-1] "Apply matrix $1 to channels of image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    whd={w},{h},{d} -r {w*h*d},{s},1,1,-1 -i[0] ${^0} -** -r $whd,{h},-1
  -nm $nm,1 -endl -done -v +

#@gmic negative
#@gmic : Compute negative of selected images.
#@gmic : $ image.jpg --negative
negative :
  -e[^-1] "Compute negative of image$?."
  -v - -repeat @# -l[$>] -- {iM} -endl -done -* -1 -v +

#@gmic noise : std_variation>=0[%],_noise_type : (+)
#@gmic : Add random noise to selected images.
#@gmic : 'noise_type' can be { 0=gaussian | 1=uniform | 2=salt&pepper | 3=poisson | 4=rice }.
#@gmic : Default value: 'noise_type=0'.
#@gmic : $ image.jpg --noise[0] 50,0 --noise[0] 50,1 --noise[0] 10,2 -cut 0,255
#@gmic : $ 300,300,1,3 [0] -noise[0] 20,0 -noise[1] 20,1 --histogram 100 -display_graph[-2,-1] 400,300,3

#@gmic norm
#@gmic : Compute the pointwise euclidean norm of vector-valued pixels in selected images.
#@gmic : $ image.jpg --norm
norm :
  -e[^-1] "Compute pointwise euclidean norm of vectors, in image$?."
  -v - -sqr -compose_channels + -sqrt -v +

#@gmic n : eq. to '-normalize'. : (+)

#@gmic normalize : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@gmic : Linearly normalize values of selected images in specified range.
#@gmic : (eq. to '-n').
#@gmic : $ image.jpg -split x,2 -normalize[-1] 64,196 -append x

#@gmic normalize_sum
#@gmic : Normalize selected images with a unitary sum.
#@gmic : $ image.jpg --histogram[-1] -normalize_sum[-1] -display_graph[-1] 400,300
normalize_sum :
  -e[^-1] "Normalize image$? with a unitary sum."
  -v - -repeat @# sum=@{$>,+} -if {$sum!=0} -/[$>] $sum -endif -done -v +

#@gmic orientation
#@gmic : Compute the pointwise orientation of vector-valued pixels in selected images.
#@gmic : $ image.jpg --orientation --norm[-2] -negative[-1] -mul[-2] [-1] -reverse[-2,-1]
orientation :
  -e[^-1] "Compute pointwise orientation vectors, in image$?."
  -v - -repeat @# --norm[$>] -replace[-1] 0,1 -/[$>,-1] -done -v +

#@gmic otsu : _nb_levels>0
#@gmic : Hard-threshold selected images using Otsu's method.
#@gmic : The computed thresholds are returned as a list of values in the status.
#@gmic : Default value: 'nb_levels=256'.
#@gmic : $ image.jpg -luminance --otsu ,
otsu : -check "isint(${1=256}) && $1>0"
  -e[^-1] "Hard-threshold image$? using Otsu's method, with $1 histogram levels."
  -v - -repeat @# -l[$>]
    im={im} iM={iM} -n 0,{$1-1}
    --histogram $1 total=@{-1,+}
    --*[-1] 'x' sum=@{-1,+} -rm[-1]
    sumB=0 wB=0 wF=0 varMax=0 threshold=0
    -repeat $1
      wB={$wB+@{-1,$>}}
      -if {$wB==0} -continue -endif
      wF={$total-$wB}
      -if {$wF==0} -break -endif
      sumB={$sumB+$>*@{-1,$>}}
      mB={$sumB/$wB}
      mF={($sum-$sumB)/$wF}
      varBetween={$wB*$wF*($mB-$mF)^2}
      -if {$varBetween>$varMax} varMax=$varBetween threshold=$> -endif
    -done
    -rm[-1] -ge[-1] $threshold
    threshold={$im+$threshold*($iM-$im)/($1-1)}
    -if $> -u @{},$threshold -else -u $threshold -endif
  -endl -done -v +

#@gmic polar2complex
#@gmic : Compute polar to complex transforms of selected images.
polar2complex :
  -e[^-1] "Compute polar to complex transforms of image$?."
  -v - -repeat {int(@#/2)} -l[{2*$>},{2*$>+1}]
    -r[1] [0],3 --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
  -endl -done -v +

#@gmic quantize : nb_levels>=1,_keep_values={ 0 | 1 },_is_uniform={ 0 | 1 }
#@gmic : Quantize selected images.
#@gmic : Default value: 'keep_values=1' and 'is_uniform=0'.
#@gmic : $ image.jpg -luminance --quantize 3
#@gmic : $ 200,200,1,1,'cos(x/10)*sin(y/10)' --quantize[0] 6 --quantize[0] 4 --quantize[0] 3 --quantize[0] 2
quantize : -check "isint($1) && $1>=1" -skip ${2=1},${3=0}
  -e[^-1] "Quantize image$? using $1 levels, "@{-arg\ 1+!$2,with,without}" keeping value range."
  -v - -repeat @# -l[$>]
    -if $3 # Uniform quantization.
      -if {s==1} # Greyscale image.
        -if $2 mM={im},{iM} -n 0,$1 -round 1,-1 -min {$1-1} -n $mM
        -else -n 0,$1 -round 1,-1 -min {$1-1} -endif
      -else mM={im},{iM} -uniform_distribution $1,{s} -n[-1] $mM -index[-2] [-1],0,$2 -rm[-1]
      -endif
    -else --colormap $1,0 -index[-2] [-1],0,$2 -rm[-1] # Non-uniform quantization.
    -endif
  -endl -done -v +

#@gmic rand : { value0[%] | [image0] },{ value1[%] | [image1] } : [image] : (+)
#@gmic : Fill selected images with random values uniformly distributed in the specified range.
#@gmic : $ 400,400,1,3 -rand -10,10 --blur 10 -sign[-1]

#@gmic replace : value_src,value_dest
#@gmic : Replace pixel values in selected images.
#@gmic : $ (1;2;3;4) --replace 2,3
replace :
  -e[^-1] "Replace pixel values $1 with $2 in image$?."
  -v - -repeat @# -l[$>] --== $1 -*[-1] {$2-$1} -+ -endl -done -v +

#@gmic replace_inf : _expression
#@gmic : Replace all infinite values in selected images by specified expression.
#@gmic : $ (0;1;2) -log --replace_inf 2
replace_inf :
  -e[^-1] "Replace all infinite values in image$? by expression '$1'."
  -v - -f "if(i==i+1,$1,i)" -v +

#@gmic replace_nan : _expression
#@gmic : Replace all NaN values in selected images by specified expression.
#@gmic : $ (-1;0;2) -sqrt --replace_nan 2
replace_nan :
  -e[^-1] "Replace all NaN values in images$? by expression '$1'."
  -v - -f "if(i>=0 || i<=0,i,$1)" -v +

#@gmic replace_seq : "search_seq","replace_seq"
#@gmic : Search and replace a sequence of values in selected images.
#@gmic : $ (1;2;3;4;5) --replace_seq "2,3,4","7,8"
replace_seq :
  -e[^-1] "Replace value sequence '$1' by value sequence '$2' in image$?."
  -v - ($1) ($2) -repeat {@#-2} -l[$>,-2,-1]
    -s[0] +,$1 -s y,-@{-2,w}
    -repeat {@#-2} -if {@{$>,t}'=='@{-2,t}} -rows[$>] 0,{w-1} -f[$>] [-1] -endif -done
    -a[0--3] y
  -endl -done -rm[-2,-1] -v +

#@gmic round : rounding_value>=0,_rounding_type : (no args) : (+)
#@gmic : Round values of selected images.
#@gmic : 'rounding_type' can be { -1=backward | 0=nearest | 1=forward }.
#@gmic : Default value: 'rounding_type=0'.
#@gmic : $ image.jpg --round 100
#@gmic : $ image.jpg -mul {pi/180} -sin --round

#@gmic roundify : gamma>=0
#@gmic : Apply roundify transformation on float-valued data, with specified gamma.
#@gmic : Default value: 'gamma=0'.
#@gmic : $ 1000 -fill '4*x/w' -repeat 5 --roundify[0] {$>*0.2} -done -append c -display_graph 400,300
roundify : -check $1>=0
  -e[^-1] "Roundify image$?, with gamma $1."
  -if {$1==1} -return -endif
  -v - -repeat @# -l[$>]
    --round 1 --[-2] [-1] --*[-2] 2 -abs[-1] -^[-1] $1 -sign[-3] -*[-3,-1] -*[-2] 0.5 -+
  -endl -done -v +

#@gmic = : eq. to '-set'. : (+)

#@gmic set : value,_x[%],_y[%],_z[%],_c[%] : (*)
#@gmic : Set pixel value in selected images, at specified coordinates.
#@gmic : (eq. to '-=').
#@gmic : If specified coordinates are outside the image bounds, no action is performed.
#@gmic : Default values: 'x=y=z=c=0'.
#@gmic : $ 2,2 -set 1,0,0 -set 2,1,0 -set 3,0,1 -set 4,1,1
#@gmic : $ image.jpg -repeat 10000 -set 255,{?(100)}%,{?(100)}%,0,{?(100)}% -done

#@gmic threshold : value[%],_is_soft : (no args) : (+)
#@gmic : Threshold values of selected images.
#@gmic : 'soft' can be { 0=hard-thresholding | 1=soft-thresholding }.
#@gmic : (noargs) runs interactive mode (uses the instant window [0] if opened).
#@gmic : Default value: 'is_soft=0'.
#@gmic : $ image.jpg --threshold[0] 50% --threshold[0] 50%,1

#@gmic t2 : eq. to '-threshold2'.
t2 :
  -v - __s="$?" -v +
  -_threshold2 $*

#@gmic threshold2 : min[%],max[%]
#@gmic : Threshold selected images between the two given values.
#@gmic : (eq. to '-t2').
#@gmic : $ image.jpg --threshold2 25%,75%
threshold2 :
  -v - __s="$?" -v +
  -_$0 $*

_threshold2 :
  -e[0--3] "Hard-threshold image"$__s" between values $1 and $2."
  -v - -repeat @# -l[$>]
    m=$1 M=$2
    -if @{-is_percent\ $1} m={im+(iM-im)*$m} -endif
    -if @{-is_percent\ $2} M={im+(iM-im)*$M} -endif
    -- {0.5*($m+$M)} -abs -le {0.5*abs($M-$m)}
  -endl -done -v +

#@gmic uncompress_rle
#@gmic : Uncompress selected 2xN data matrices, using RLE algorithm.
uncompress_rle :
  -e[^-1] "Uncompress data vector$?, using RLE algorithm."
  -v - -repeat @# -l[$>]

    # Retrieve original data dimension and min value.
    -y whds=@{0,0-3} im=@{0,4} -rows 5,100%

    # Transform RLE data to list of pairs {nb_occurences,value}.
    --lt[-1] 0 (0;1;1) -erode[-2] [-1],0 -rm[-1] --[-1] 1 -a x -discard -1  # Get back compressed '0' (minimum) values.
    --lt 0 (1;1;0) -dilate[-2] [-1] -rm[-1] -*[-1] -2 -+[-1] 1              # Get back singletons.
    -rv -abs[-1] -a x -discard -1
    -r 2,{h/2},1,1,-1 -s y,-256

    # Uncompress, using 3d objects.
    -repeat @# -l[$>]
      -i[0] ({'CImg3d'}) -+[0] 0.5
      -i[1] ({2*h};{h})
      -s[-1] x,2 -cumul[-2] siz=@{-2,-1}
      --shift[-2] 0,1 --[-3] 1 -rv[-3,-1] -z[-3,-1] 0,2 -a[-3,-1] x
      -i[3] (2,0,1;2,{2*h-2},{2*h-1}) -r[3] 3,{h},1,1,3 -round[3]
      -r[4] 3 1,100%,1,1,1 -y -a y
      $siz -object3d[-1] [-2],0,0,0,1,2,0,0 -rm[-2]
    -endl -done
    -a x -r $whds,-1 -+ $im
  -endl -done -v +

#@gmic unrepeat
#@gmic : Remove repetition of adjacent values in selected images.
#@gmic : $ (1;1;1;1;1;2;2;2;3;4;4;4;5;5;5) --unrepeat
unrepeat :
  -e[^-1] "Remove repetition of adjacent values in image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -y x ({@{0,-1}+1}) -a x -r 100%,2
    -f[-1] '>if(y==0,i,if(i(x,0)==i(x+1,0),-1,x))'
    -z 0,{w-2} -s y,2 -discard[1] -1 -map[1] [0]
    -rm[0] -nm $nm,1
  -endl -done -v +

#@gmic vector2tensor
#@gmic : Convert selected vector fields to corresponding diffusion tensor fields.
vector2tensor :
  -e[^-1] "Convert vector field$? to diffusion tensor field$?."
  -v - -repeat @# -l[$>]
    -s c
    -if {@#==2} --sqr[-1] -*[-2] [-3] -sqr[-3]
    -elif {@#==3} --sqr[-2] --*[-3] [-2] --sqr[-3] -*[-5,-4] [-6] -sqr[-6]
    -else -error[0--4] "Invalid image ["{@#-$>-1}"] : Dimensions "{w}","{h}","{d}","{s}" does not represent a field of 2d or 3d vectors."
    -endif
    -a c
  -endl -done -v +

#---------------------------------
#
#@gmic :: Colors manipulation
#
#---------------------------------

#@gmic apply_channels : "command",_channels={ all=0 | rgba=1 | rgb=2 | y=3 | cbcr=4 | cb=5 | cr=6 | l=7 | ab=8 | a=9 | b=10 | h=11 | s=12 | v=13 | k=14 | cg=15 | ch=16 | c=17 | H=18 | r=19 | g=20 | b=21 | alpha==22 },_normalize={ 0=cut | 1=normalize }
#@gmic : Apply specified command on chosen normalized channels of each selected images.
#@gmic : Default value: 'normalize=0'.
#@gmic : $ image.jpg --apply_channels "-equalize -blur 2",5
apply_channels : -skip ${3=0}

  # All components.
  -if {{$2'=='all}" || "{$2'=='0}}
    -e[^-1] "Apply command '$1' on image$?." -v -
    -repeat @# -l[$>]
      -_apply_channels "$1"
      -if $3 -n 0,255 -else -c 0,255 -endif
    -endl -done

  # RGBA.
  -elif {{$2'=='rgba}" || "{$2'=='1}}
    -e[^-1] "Apply command '$1' on RGBA channels of image$?." -v -
    -to_rgba -repeat @# -l[$>]
      -_apply_channels "$1"
      -if $3 -n 0,255 -else -c 0,255 -endif
    -endl -done

  # RGB.
  -elif {{$2'=='rgb}" || "{$2'=='2}}
    -e[^-1] "Apply command '$1' on RGB channels of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0]
      -_apply_channels[0] "$1"
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -to_rgb[0]
      -a c
    -endl -done

  # Y.
  -elif {{$2'=='y}" || "{$2'=='3}}
    -e[^-1] "Apply command '$1' on luminance Y of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[0] "$1" -channels[0] 0
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -done

  # CbCr.
  -elif {{$2'=='cbcr}" || "{$2'=='4}}
    -e[^-1] "Apply command '$1' on blue and red chrominances CbCr of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c -a[1,2] c
      -_apply_channels[1] "$1" -channels[1] 0,1
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-1] c -ycbcr2rgb[0] -a c
    -endl -done

  # Cb.
  -elif {{$2'=='cb}" || "{$2'=='5}}
    -e[^-1] "Apply command '$1' on blue chrominance Cb of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[1] "$1" -channels[1] 0
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -done

  # Cr.
  -elif {{$2'=='cr}" || "{$2'=='6}}
    -e[^-1] "Apply command '$1' on red chrominance Cr of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2ycbcr[0] -s[0] c
      -_apply_channels[2] "$1" -channels[2] 0
      -if $3 -n[2] 0,255 -else -c[2] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -a c
    -endl -done

  # L.
  -elif {{$2'=='l}" || "{$2'=='7}}
    -e[^-1] "Apply command '$1' on lightness L of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -*[0] 2.55 -_apply_channels[0] "$1" -channels[0] 0 -/[0] 2.55
      -if $3 -n[0] 0,100 -else -c[0] 0,100 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # a-b.
  -elif {{$2'=='ab}" || "{$2'=='8}}
    -e[^-1] "Apply command '$1' on a-b channels of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[1] 86 -*[1] 1.38587 -+[2] 108 -*[2] 1.25616
      -a[1,2] c -_apply_channels[1] "$1" -channels[1] 0,1 -s[1] c
      -/[1] 1.38587 --[1] 86 -/[2] 1.25616 --[2] 108
      -if $3 -n[1] -86,98 -n[2] -108,95 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # a.
  -elif {{$2'=='a}" || "{$2'=='9}}
    -e[^-1] "Apply command '$1' on a-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[1] 86 -*[1] 1.38587 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 1.38587 --[1] 86
      -if $3 -n[1] -86,98 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # b.
  -elif {{$2'=='b}" || "{$2'=='10}}
    -e[^-1] "Apply command '$1' on b-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lab[0] -s[0] c
      -+[2] 108 -*[2] 1.25616 -_apply_channels[2] "$1" -channels[2] 0 -/[2] 1.25616 --[2] 108
      -if $3 -n[1] -108,95 -endif
      -a[0-2] c -lab2rgb[0] -a c
    -endl -done

  # H.
  -elif {{$2'=='h}" || "{$2'=='11}}
    -e[^-1] "Apply command '$1' on hue H of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[0] 0.708333 -_apply_channels[0] "$1" -channels[0] 0 -/[0] 0.708333
      -if $3 -n[0] 0,360 -else -%[0] 360 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -done

  # S.
  -elif {{$2'=='s}" || "{$2'=='12}}
    -e[^-1] "Apply command '$1' on saturation S of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[1] 255 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 255
      -if $3 -n[1] 0,1 -else -c[1] 0,1 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -done

  # V.
  -elif {{$2'=='v}" || "{$2'=='13}}
    -e[^-1] "Apply command '$1' on value V of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2hsv[0] -s[0] c
      -*[2] 255 -_apply_channels[2] "$1" -channels[2] 0 -/[2] 255
      -if $3 -n[2] 0,1 -else -c[2] 0,1 -endif
      -a[0-2] c -hsv2rgb[0] -a c
    -endl -done

  # K.
  -elif {{$2'=='k" || "{$2'=='14}}
    -e[^-1] "Apply command '$1' on key channel K of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2cmyk[0] -s[0] c
      -_apply_channels[3] "$1" -channels[3] 0
      -if $3 -n[3] 0,255 -else -c[3] 0,255 -endif
      -a[0-3] c -cmyk2rgb[0] -a c
    -endl -done

  # Cg.
  -elif {{$2'=='cg}" || "{$2'=='15}}
    -e[^-1] "Apply command(s) '$1' on green chrominance Cg of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c -rv[1,2] -a[0-2] c -rgb2ycbcr[0] -s[0] c
      -_apply_channels[1] "$1" -channels[1] 0
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -a[0-2] c -ycbcr2rgb[0] -s[0] c -rv[1,2] -a c
    -endl -done

  # c-h.
  -elif {{$2'=='ch}" || "{$2'=='16}}
    -e[^-1] "Apply command '$1' on c-h channels of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lch[0] -s[0] c
      -*[1] 2.55 -+[2] {pi} -*[2] {255/(2*pi)}
      -a[1,2] c -_apply_channels[1] "$1" -channels[1] 0,1 -s[1] c
      -/[1] 2.55 -/[2] {255/(2*pi)} --[2] {pi}
      -if $3 -n[1] 0,100 -n[2] -{pi},{pi} -endif
      -a[0-2] c -lch2rgb[0] -a c
    -endl -done

  # c.
  -elif {{$2'=='c}" || "{$2'=='17}}
    -e[^-1] "Apply command '$1' on c-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lch[0] -s[0] c
      -*[1] 2.55 -_apply_channels[1] "$1" -channels[1] 0 -/[1] 2.55
      -if $3 -n[1] 0,100 -else -c[1] 0,100 -endif
      -a[0-2] c -lch2rgb[0] -a c
    -endl -done

  # H.
  -elif {{$2'=='h}" || "{$2'=='18}}
    -e[^-1] "Apply command '$1' on h-channel of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -rgb2lch[0] -s[0] c
      -+[2] {pi} -*[2] {255/(2*pi)} -_apply_channels[2] "$1" -channels[2] 0 -/[2] {255/(2*pi)} --[2] {pi}
      -if $3 -n[2] -{pi},{pi} -endif
      -a[0-2] c -lch2rgb[0] -a c
    -endl -done

  # Red.
  -elif {{$2'=='r}" || "{$2'=='19}}
    -e[^-1] "Apply command '$1' on red channel R of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c
      -_apply_channels[0] "$1"
      -if $3 -n[0] 0,255 -else -c[0] 0,255 -endif
      -to_gray[0]
      -a c
    -endl -done

  # Green.
  -elif {{$2'=='g}" || "{$2'=='20}}
    -e[^-1] "Apply command '$1' on green channel G of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c
      -_apply_channels[1] "$1"
      -if $3 -n[1] 0,255 -else -c[1] 0,255 -endif
      -to_gray[1]
      -a c
    -endl -done

  # Blue.
  -elif {{$2'=='b}" || "{$2'=='21}}
    -e[^-1] "Apply command '$1' on blue channel B of image$?." -v -
    -repeat @# -l[$>]
      -split_opacity -to_rgb[0] -s[0] c
      -_apply_channels[2] "$1"
      -if $3 -n[2] 0,255 -else -c[2] 0,255 -endif
      -to_gray[2]
      -a c
    -endl -done

  # Alpha.
  -elif {{$2'=='alpha}" || "{$2'=='22}}
    -e[^-1] "Apply command '$1' on alpha channel A of image$?." -v -
    -repeat @# -l[$>]
      -to_rgba -s c
      -_apply_channels[3] "$1"
      -if $3 -n[3] 0,255 -else -c[3] 0,255 -endif
      -to_gray[3]
      -a c
    -endl -done

  -endif
  -v +

_apply_channels :
  ${1--1} -k[0]

#@gmic autoindex : nb_colors>0,0<=_dithering<=1,_method={ 0=median-cut | 1=k-means }
#@gmic : Index selected vector-valued images by adapted colormaps.
#@gmic : Default values: 'dithering=0' and 'method=0'.
#@gmic : $ image.jpg --autoindex[0] 4 --autoindex[0] 8 --autoindex[0] 16
autoindex : -check "isint($1) && $1>0 && ${2=0}>=0" -skip ${3=0}
  -e[^-1] "Index colors in images$? by adapted colormap with $1 entries, dithering level $2 and "\
          @{-arg\ 1+!$3,k-means,median-cut}" method."
  -v - -repeat @# -l[$>]
    -if {w>h} -if {w>256} --r2dx 256 -else [0] -endif
    -else -if {h>256} --r2dy 256 -else [0] -endif
    -endif
    -colormap[1] $1,$3,0
    -index[0] [1],$2,1 -rm[1]
  -endl -done -v +

#@gmic bayer2rgb : _GM_smoothness,_RB_smoothness1,_RB_smoothness2
#@gmic : Transform selected RGB-Bayer sampled images to color images.
#@gmic : Default values: 'GM_smoothness=RB_smoothness=1' and 'RB_smoothness2=0.5'.
#@gmic : $ image.jpg -rgb2bayer 0 --bayer2rgb 1,1,0.5
bayer2rgb : -skip ${1=1},${2=1},${3=0.5}
  -e[^-1] "Transform RGB-Bayer image$? to color images, with smoothness ($1,$2,$3)."
  -v - -channels 0 -repeat @# -l[$>]

    # Expand image size to avoid problems with borders.
    -expand_x {"2 + 4*$1"},0 -expand_y {"2 + 4*$1"},0

    # Compute green-magenta chromaticity.
    (-1,1;1,-1) -r[-1] [-2],[-2],1,1,0,2
    --*[-2] [-1]

    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -b[-1] $1

    -*[-2] [-1]
    --[-3,-2]

    # Compute red-blue chromaticity.
    (1,-1) -r[-1] [-2],[-2],1,1,0,2  # Horizontal estimate
    -*[-1] [-3]
    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur_y[-1] $2 -blur_x[-1] $3

    (1;-1) -r[-1] [-2],[-2],1,1,0,2  # Vertical estimate
    -*[-1] [-4]
    (0.25,0.5,0.25) -convolve[-2] [-1] -transpose[-1] -convolve[-2] [-1] -rm[-1]
    -blur_x[-1] $2 -blur_y[-1] $3

    -+[-2,-1] -/[-1] 2

    # Luminance reconstruction.
    (2,0;0,-2) -r[-1] [-2],[-2],1,1,0,2
    -*[-1] [-2]
    --[-4,-1]

    # RGB reconstruction.
    -a[-3--1] c
    -mix_rgb[-1] 1,-1,2,1,1,0,1,-1,-2

    # Shrink to original image size.
    -shrink_x {"2 + 4*$1"},0 -shrink_y {"2 + 4*$1"},0
    -c 0,255

  -endl -done -v +

#@gmic cmy2rgb
#@gmic : Convert selected images from CMY to RGB colorbases.
cmy2rgb :
  -e[^-1] "Convert image$? from CMY to RGB color bases."
  -v - -rgb2cmy -v +

#@gmic cmyk2rgb
#@gmic : Convert selected images from CMYK to RGB colorbases.
cmyk2rgb :
  -e[^-1] "Convert image$? from CMYK to RGB color bases."
  -v - -repeat @# -l[$>]
    -s c --/[-1] -255 -+[-1] 1 -*[0-2] [-1] -rm[-1] -+[0-2] [-1] -rm[-1]
    -a c -cmy2rgb
  -endl -done -v +

#@gmic colormap : nb_levels>=1,_method={ 0=median-cut | 1=k-means },_sort_vectors={ 0 | 1 }
#@gmic : Estimate best-fitting colormap with 'nb_colors' entries, to index selected images.
#@gmic : Default value: 'method=0' and 'sort_vectors=1'.
#@gmic : $ image.jpg --colormap[0] 4 --colormap[0] 8 --colormap[0] 16
colormap : -check "isint($1) && $1>0" -skip ${2=0},${3=1}
  -e[^-1] "Estimate colormap with $1 entries for image$?, by "@{-arg\ 1+!$2,k-means,median-cut}" method."
  -v - -repeat @# -l[$>]
    -r {w*h},1,1,100%,-1
    -if {!$2} -_colormap $1                                 # Just run the median-cut algorithm.
    -else
      m={im} M={iM} -n[-1] 0,255                            # Keep track of the initial statistics.
      --_colormap $1 --index[-2] [-1] -*[-1] 256 -+[-3,-1]  # Initialize k-means labels and add them on the image.

      # Start k-means iterations.
      -do
        -repeat {s}                                             # Estimate new colormap.
          -sh[0] $>,$> --histogram[-1] {$1*256},0,{$1*256-1} -rm[-2]
          -i[-2] 256,1,1,1,'x' -r[-2] {w},1,1,1,0,2 -*[-2] [-1] -r[-2,-1] $1,1,1,1,2 -max[-1] 0.01 -/[-2,-1]
        -done -a[2--1] c
        --[-2] [-1] -abs[-2] diff={@{-2,+}/w} -rm[-2]           # Compute colormap difference.
        -and[-2] 255 --index[-2] [-1],0,0 -*[-1] 256 -+[-3,-1]  # Compute new k-means labels.
      -while {$diff>0.5}
      -rm[-2] -*[-1] {($M-$m)/255} -+[-1] $m                    # Convert colormap values back to initial value range.
    -endif
    -if $3 --norm -rv -a y -sort +,x -rows 1 -endif             # Sort colors by increasing norm.
    -nm "[colormap of "@{-1,b}"]"
  -endl -done -v +

_colormap : # Implementation of the median-cut algorithm.
  -repeat {$1-1}
    @#,{s} -repeat {@#-1} # Compute box variances along all axes and find highest one (without a single element).
      n=$> -repeat @{$n,s} -sh[$n] $>,$> -=[-2] {if(w>1,iv,-1)},$n,$> -rm[-1] -done
    -done
    c=@{-1,C}
    b=@{-arg\ 1,$c}  # Indice of box with highest variance.
    a=@{-arg\ 2,$c}  # Indice of axe with highest variance inside box 'b'.
    -rm[-1] -shift[$b] 0,0,0,{-$a},2 -sort[$b] +,x -shift[$b] 0,0,0,$a,2 -s[$b] x,2 # Split selected box along its median axis.
  -done
  -r 1,1,1,100%,2 -a x # Average value in each box and append as final colormap.

#@gmic compose_channels
#@gmic : Compose all channels of each selected image, using specified arithmetic operator (+,-,or,min,...).
#@gmic : Default value: '1=+'.
#@gmic : $ image.jpg --compose_channels and
compose_channels : -skip ${1="+"}
  -e[^-1] "Compose all channels of image$?, with operator '$1'."
  -v - -repeat @# -l[$>]
    -sh 0,0
    -repeat {@{-2,s}-1} -sh[-2] {$>+1},{$>+1} -l[-2,-1] -$1 -endl -done
    -rm[-1] -r 100%,100%,100%,1,-1
  -endl -done -v +

#@gmic direction2rgb
#@gmic : Compute RGB representation of selected 2d direction fields.
#@gmic : $ image.jpg -luminance -gradient -append c -blur 2 -orientation --direction2rgb
direction2rgb :
  -e[^-1] "Compute RGB representation of 2d direction field$?."
  -v - -channels 0,1 -repeat @# -l[$>] nm=@{0,n}
    -s c -complex2polar -round[-2] 0.001
    -*[-1] {180/pi} -%[-1] 360 100%,100%,1,1,1 -mv[-3] @#
    -if {im!=iM} -n[-1] 0,1 -else -f[-1] 1 -endif
    -a c -hsv2rgb
  -nm $nm,1 -endl -done -v +

#@gmic ditheredbw
#@gmic : Create dithered B&W version of selected images.
#@gmic : $ image.jpg --equalize -ditheredbw[-1]
ditheredbw :
  -e[^-1] "Create dithered B&W version of image$?."
  -v - -repeat @# -l[$>] -split_opacity
    -luminance[0] -n[0] 0,255 (0,255) -index[0] [-1],1,1 -rm[-1]
  -a c -endl -done -v +

#@gmic fc : eq. to '-fill_color'.
fc :
  -v - __s="$?" -v +
  -_fill_color $*

#@gmic fill_color : col1,...,colN
#@gmic : Fill selected images with specified color.
#@gmic : (eq. to '-fc').
#@gmic : $ image.jpg --fill_color 255,0,255
fill_color :
  -v - __s="$?" -v +
  -_$0 $*

_fill_color :
  -e[0--3] "Fill image"$__s" with color (${^0})."
  -v - -repeat @# -l[$>]
    -repeat {s} -sh[-1] $>,$> -f[-1] {arg(1+$>,${^0})} -rm[-1] -done
  -nm @{-1,n},1 -endl -done -v +

#@gmic gradient2rgb : _is_orientation={ 0 | 1 }
#@gmic : Compute RGB representation of 2d gradient of selected images.
#@gmic : Default value: 'is_orientation=0'.
#@gmic : $ image.jpg --gradient2rgb 0 -equalize[-1]
gradient2rgb : -check "isbool(${1=0})"
  -arg 1+!$1,"orientation ",""
  -e[^-1] "Compute RGB representation of 2d gradient "@{}"of image$?."
  -v - -norm -repeat @# -l[$>]
    -if $1 -gradient_orientation 2 -else -g xy -endif
    -a c -direction2rgb
  -endl -done -v +

#@gmic hsi2rgb : (+)
#@gmic : Convert selected images from HSI to RGB colorbases.

#@gmic hsi82rgb
#@gmic : Convert selected images from HSI8 to RGB color bases.
hsi82rgb :
  -e[^-1] "Convert image$? from HSI8 to RGB color bases."
  -v - -_hsx82rgb -hsi2rgb -v +

#@gmic hsl2rgb : (+)
#@gmic : Convert selected images from HSL to RGB colorbases.

#@gmic hsl82rgb
#@gmic : Convert selected images from HSL8 to RGB color bases.
hsl82rgb :
  -e[^-1] "Convert image$? from HSL8 to RGB color bases."
  -v - -_hsx82rgb -hsl2rgb -v +

#@gmic hsv2rgb : (+)
#@gmic : Convert selected images from HSV to RGB colorbases.
#@gmic : $ (0,360;0,360^0,0;1,1^1,1;1,1) -resize 400,400,1,3,3 -hsv2rgb

#@gmic hsv82rgb
#@gmic : Convert selected images from HSV8 to RGB color bases.
hsv82rgb :
  -e[^-1] "Convert image$? from HSV8 to RGB color bases."
  -v - -_hsx82rgb -hsv2rgb -v +

_hsx82rgb :
 -repeat @#
   -sh[$>] 0,0 -/[-1] 0.708333 -rm[-1]
   -sh[$>] 1,2 -/[-1] 255 -rm[-1]
 -done -v +

#@gmic lab2lch
#@gmic : Convert selected images from Lab to Lch color bases.
lab2lch :
  -e[^-1] "Convert image$? from Lab to Lch color bases."
  -v - -r 100%,100%,100%,3 -repeat @# -l[$>]
    -s c -complex2polar[-2,-1] -a c
  -endl -done -v +

#@gmic lab2rgb : (+)
#@gmic : Convert selected images from Lab to RGB colorbases.
#@gmic : $ (50,50;50,50^-3,3;-3,3^-3,-3;3,3) -resize 400,400,1,3,3 -lab2rgb

#@gmic lab82rgb
#@gmic : Convert selected images from Lab8 to RGB color bases.
lab82rgb :
  -e[^-1] "Convert image$? from Lab8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -/[-1] 1.275 --[-1] 100 -rm[-1]
    -sh[$>] 2,2 -/[-1] 1.15909 --[-1] 110 -rm[-1]
  -done -lab2rgb -v +

#@gmic lch2lab
#@gmic : Convert selected images from Lch to Lab color bases.
lch2lab :
  -e[^-1] "Convert image$? from Lch to Lab color bases."
  -v - -r 100%,100%,100%,3 -repeat @# -l[$>]
    -s c -polar2complex[-2,-1] -a c
  -endl -done -v +

#@gmic lch2rgb
#@gmic : Convert selected images from Lch to RGB color bases.
lch2rgb :
  -e[^-1] "Convert image$? from Lch to RGB color bases."
  -v - -lch2lab -lab2rgb -v +

#@gmic lch82rgb
#@gmic : Convert selected images from Lch8 to RGB color bases.
lch82rgb :
  -e[^-1] "Convert image$? from Lch8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -/[-1] 1.88889 -rm[-1]
    -sh[$>] 2,2 -/[-1] 40.5845 --[-1] 3.14159 -rm[-1]
  -done -lch2rgb -v +

#@gmic luminance
#@gmic : Compute luminance of selected sRGB images.
#@gmic : $ image.jpg --luminance
luminance :
  -e[^-1] "Compute luminance of image$?."
  -v - -remove_opacity -srgb2rgb
  -repeat @# -l[$>]
  -if {s==3} -sh 0,0 -sh[0] 1,1 -sh[0] 2,2 -*[1] 0.299 -*[2] 0.587 -*[3] 0.114 -+[1-3] -rm[1]
  -elif {s!=1} -norm -n 0,255
  -endif -endl -done
  -channels 0 -rgb2srgb -v +

#@gmic mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33
#@gmic : Apply 3x3 specified matrix to RGB colors of selected images.
#@gmic : Default values: 'a11=1', 'a12=a13=a21=0', 'a22=1', 'a23=a31=a32=0' and 'a33=1'.
#@gmic : $ image.jpg --mix_rgb 0,1,0,1,0,0,0,0,1
mix_rgb : -skip ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
  -e[^-1] "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
  -v - -r 100%,100%,1,3,0,2 -mix_channels ($1,$2,$3;$4,$5,$6;$7,$8,$9) -v +

#@gmic pseudogray : _max_increment>=0,_JND_threshold>=0,_bits_depth>0
#@gmic : Generate pseudogray colormap with specified increment and perceptual threshold.
#@gmic : If 'JND_threshold' is 0, no perceptual constraints are applied.
#@gmic : Default values: 'max_increment=5', 'JND_threshold=2.3' and 'bits_depth=8'.
#@gmic : $ -pseudogray 5
pseudogray : -check "isint(${1=5}) && $1>=0 && ${2=2.3}>=0 && isint(${3=8}) && $3>0"
  -e[^-1] "Generate pseudogray colormap with increment $1, JND threshold $2 and $3 bits depth."
  -v -

  # Generate all possible sRGB colors with given increments.
  {round(2^$3)},1,1,3,'x'
  -if {!$1} -n[-1] 0,255 -v + -return -endif
  {$1+1},{$1+1},{$1+1},1,'x' --f[-1] 'y' --f[-1] 'z' -a[-3--1] c -r[-1] {w*h*d},1,1,3,-1
  -f[-1] 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(min(R,G,B),-1,i)'
  -permute[-1] cxyz -discard[-1] -1 -r[-1] 3,{h/3},1,1,-1 -permute[-1] yzcx
  -r[-2] {w*100}% -r[-1] [-2],0,2 -+[-2,-1]
  -f[-1] 'R=i(x,0,0,0);G=i(x,0,0,1);B=i(x,0,0,2);if(max(R,G,B)>2^$3-1,-1,i)'
  -permute[-1] cxyz -discard[-1] -1 -r[-1] 3,{h/3},1,1,-1 -permute[-1] yzcx
  -n[-1] 0,255
  --srgb2rgb[-1] -rgb2lab[-1] -rv[-2,-1] -a[-2,-1] y -sort[-1] +,x  # Sort by increasing lightness.
  -if {!$2} -rows[-1] 1
  -else # Add perceptual constraint if requested.

    # Constraint 1 : keep colors close enough to equivalent 'pure' grays.
    -s[-1] y -rv[-2,-1] [-1] -sh[-1] 1,2 -f[-1] 0 -rm[-1] --[-2,-1] -norm[-1]
    -le[-1] $2 -*[-1] 'x+1' -discard[-1] 0 --[-1] 1 -map[-1] [-2] -rm[-2]

    # Constraint 2 : remove neighboring colors that are above the JND.
    -repeat 10000
      --srgb2rgb[-1] -rgb2lab[-1] --shift[-1] 0,{1-2*($>%2)},0,0,1 --[-2,-1] -norm[-1]
      -le[-1] $2
      -if {im} -rm[-1] -break -endif
      -*[-1] 'y+1' -discard[-1] 0 --[-1] 1 -map[-1] [-2] -rm[-2]
    -done
    -transpose[-1]

  -endif
  -v +

#@gmic replace_color : tolerance[%]>=0,smoothness[%]>=0,src1,src2,...,dest1,dest2,...
#@gmic : Replace pixels from/to specified colors in selected images.
#@gmic : $ image.jpg --replace_color 40,3,204,153,110,255,0,0
replace_color : -check "$1>=0 && $2>=0"
  -v - -l[] (${3--1}) -y c -s c,2 col1=@0 col2=@1 -rm -endl -v +
  -e[^-1] "Replace color ("$col1") by color ("$col2") in image$?, with tolerance $1 and smoothness $2."
  -v - -repeat @# -l[$>]
    1,1,1,100%,$col1 -r[1] [0]
    -if $1 --[1] [0] -norm[1] -le[1] $1 -else -==[1] [0] -l[1] -s c -and -endl -endif
    -b[1] $2
    1,1,1,@{0,s},$col2 -r[2] [0] -j[0] [2],0,0,0,0,1,[1] -k[0]
  -endl -done -v +

#@gmic rgb2bayer : _start_pattern=0,_color_grid=0
#@gmic : Transform selected color images to RGB-Bayer sampled images.
#@gmic : Default values: 'start_pattern=0' and 'color_grid=0'.
#@gmic : $ image.jpg --rgb2bayer 0
rgb2bayer : -skip ${1=0},${2=0}
  -e[^-1] "Transform image$? to a RGB-Bayer "@{-arg\ 1+!$2,color,monochrome}" grid, starting from pattern '$1'."
  -v - -to_rgb -repeat @# -l[$>]
    -_rgb2bayer$1 -r[1] [0],0,2 -* -if {!$2} -s c -+ -endif
  -endl -done -v +

_rgb2bayer0 : (1,0;0,0^0,1;1,0^0,0;0,1)
_rgb2bayer1 : (0,0;0,1^0,1;1,0^1,0;0,0)
_rgb2bayer2 : (0,0;1,0^1,0;0,1^0,1;0,0)
_rgb2bayer3 : (0,1;0,0^1,0;0,1^0,0;1,0)

#@gmic rgb2cmy
#@gmic : Convert selected images from RGB to CMY colorbases.
#@gmic : $ image.jpg -rgb2cmy -split c
rgb2cmy :
  -e[^-1] "Convert image$? from RGB to CMY color bases."
  -v - -to_rgb -c 0,255 -* -1 -+ 255 -v +

#@gmic rgb2cmyk
#@gmic : Convert selected images from RGB to CMYK colorbases.
#@gmic : $ image.jpg -rgb2cmyk -split c
#@gmic : $ image.jpg -rgb2cmyk -split c -fill[3] 0 -append c -cmyk2rgb
rgb2cmyk :
  -e[^-1] "Convert image$? from RGB to CMYK color bases."
  -v - -rgb2cmy -repeat @# -l[$>]
    -s c --min --[0-2] [-1] --/[-1] 255 --[-1] 1 -*[-1] -1 --eq[-1] 0 -+[-2,-1]
    -/[0-2] [-1] -rm[-1] -a c
  -endl -done -v +

#@gmic rgb2hsi : (+)
#@gmic : Convert selected images from RGB to HSI colorbases.
#@gmic : $ image.jpg -rgb2hsi -split c

#@gmic rgb2hsi8
#@gmic : Convert selected images from RGB to HSI8 color bases.
#@gmic : $ image.jpg -rgb2hsi8 -split c
rgb2hsi8 :
  -e[^-1] "Convert image$? from RGB to HSI8 color bases."
  -v - -rgb2hsi -_rgb2hsx8 -v +

#@gmic rgb2hsl : (+)
#@gmic : Convert selected images from RGB to HSL colorbases.
#@gmic : $ image.jpg -rgb2hsl -split c
#@gmic : $ image.jpg -rgb2hsl --split c -add[-3] 100 -mod[-3] 360 -append[-3--1] c -hsl2rgb

#@gmic rgb2hsl8
#@gmic : Convert selected images from RGB to HSL8 color bases.
#@gmic : $ image.jpg -rgb2hsl8 -split c
rgb2hsl8 :
  -e[^-1] "Convert image$? from RGB to HSL8 color bases."
  -v - -rgb2hsl -_rgb2hsx8 -v +

#@gmic rgb2hsv : (+)
#@gmic : Convert selected images from RGB to HSV colorbases.
#@gmic : $ image.jpg -rgb2hsv -split c
#@gmic : $ image.jpg -rgb2hsv --split c -add[-2] 0.3 -cut[-2] 0,1 -append[-3--1] c -hsv2rgb

#@gmic rgb2hsv8
#@gmic : Convert selected images from RGB to HSV8 color bases.
#@gmic : $ image.jpg -rgb2hsv8 -split c
rgb2hsv8 :
  -e[^-1] "Convert image$? from RGB to HSV8 color bases."
  -v - -rgb2hsv -_rgb2hsx8 -v +

_rgb2hsx8 :
  -repeat @#
    -sh[$>] 0,0 -*[-1] 0.708333 -rm[-1]
    -sh[$>] 1,2 -*[-1] 255 -rm[-1]
  -done

#@gmic rgb2lab : (+)
#@gmic : Convert selected images from RGB to Lab colorbases.
#@gmic : $ image.jpg -rgb2lab -split c
#@gmic : $ image.jpg -rgb2lab --split c -mul[-2,-1] 2.5 -append[-3--1] c -lab2rgb

#@gmic rgb2lab8
#@gmic : Convert selected images from RGB to Lab8 color bases.
#@gmic : $ image.jpg -rgb2lab8 -split c
rgb2lab8 :
  -e[^-1] "Convert image$? from RGB to Lab8 color bases."
  -v - -rgb2lab -repeat @#
    -sh[$>] 0,0 -*[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -+[-1] 100 -*[-1] 1.275 -rm[-1]
    -sh[$>] 2,2 -+[-1] 110 -*[-1] 1.15909 -rm[-1]
  -done -v +

#@gmic rgb2lch
#@gmic : Convert selected images from RGB to Lch color bases.
#@gmic : $ image.jpg -rgb2lch -split c
rgb2lch :
  -e[^-1] "Convert image$? from RGB to Lch color bases."
  -v - -rgb2lab -lab2lch -v +

#@gmic rgb2lch8
#@gmic : Convert selected images from RGB to Lch8 color bases.
#@gmic : $ image.jpg -rgb2lch8 -split c
rgb2lch8 :
  -e[^-1] "Convert image$? from RGB to Lch8 color bases."
  -v - -rgb2lch -repeat @#
    -sh[$>] 0,0 -*[-1] 2.55 -rm[-1]
    -sh[$>] 1,1 -*[-1] 1.88889 -rm[-1]
    -sh[$>] 2,2 -+[-1] 3.14159 -*[-1] 40.5845 -rm[-1]
  -done -v +

#@gmic rgb2luv
#@gmic : Convert selected images from RGB to LUV color bases.
#@gmic : $ image.jpg -rgb2luv -split c
rgb2luv :
  -e[^-1] "Convert image$? from RGB to LUV color bases."
  -v - -repeat @# -l[$>]
    --rgb2xyz -rgb2lab[-2] -channels[-2] 0 -s[-1] c
    -*[-1] 3 --*[-2] 15 -+[-2,-1] -+[-1] [-3] -+[-1] 1e-8  # Z <- X+15Y+3Z
    -*[-3] 4 -*[-2] 9 -/[-3,-2] [-1] -rm[-1]
    --[-2] 0.2009 --[-1] 0.4610
    --*[-3] 13 -*[-3] [-1] -*[-2,-1] -a c
  -endl -done -v +

#@gmic rgb2srgb : (+)
#@gmic : Convert selected images from RGB to sRGB colorbases.

#@gmic rgb2xyz
#@gmic : Convert selected images from RGB to XYZ colorbases.
#@gmic : the D65 illuminant is used as the white point).
#@gmic : $ image.jpg -rgb2xyz -split c
rgb2xyz :
  -e[^-1] "Convert image$? from RGB to XYZ color bases."
  -v - -/ 255 -mix_rgb 0.412453,0.357580,0.180423,0.212671,0.715160,0.072169,0.019334,0.119193,0.950227 -v +

#@gmic rgb2xyz8
#@gmic : Convert selected images from RGB to XYZ8 color bases.
#@gmic : $ image.jpg -rgb2xyz8 -split c
rgb2xyz8 :
  -e[^-1] "Convert image$? from RGB to XYZ8 color bases."
  -v - -rgb2xyz -repeat @#
    -sh[$>] 0,0 -*[-1] 255 -rm[-1]
    -sh[$>] 1,1 -*[-1] 255 -rm[-1]
    -sh[$>] 2,2 -*[-1] 231.8182 -rm[-1]
  -done -v +

#@gmic rgb2ycbcr
#@gmic : Convert selected images from RGB to YCbCr colorbases.
#@gmic : $ image.jpg -rgb2ycbcr -split c
rgb2ycbcr :
  -e[^-1] "Convert image$? from RGB to YCbCr color bases."
  -v - -mix_rgb 66,129,25,-38,-74,112,112,-94,-18 -+ 128 -/ 256
  -repeat @# -l[$>] -sh 0,0 -+[-1] 16 -rm[-1] -sh 1,2 -+[-1] 128 -rm[-1] -endl -done
  -v +

#@gmic rgb2yuv
#@gmic : Convert selected images from RGB to YUV colorbases.
#@gmic : $ image.jpg -rgb2yuv -split c
rgb2yuv :
  -e[^-1] "Convert image$? from RGB to YUV color bases."
  -v - -/ 255 -mix_rgb 0.299,0.587,0.114,-0.14713,-0.28886,0.436,0.615,-0.51498,-0.10001 -v +

#@gmic rgb2yuv8
#@gmic : Convert selected images from RGB to YUV8 color bases.
#@gmic : $ image.jpg -rgb2yuv8 -split c
rgb2yuv8 :
  -e[^-1] "Convert image$? from RGB to YUV8 color bases."
  -v - -rgb2yuv -repeat @#
    -sh[$>] 0,0 -*[-1] 255 -rm[-1]
    -sh[$>] 1,1 -+[-1] 0.44 -*[-1] 289.773 -rm[-1]
    -sh[$>] 2,2 -+[-1] 0.62 -*[-1] 205.645 -rm[-1]
  -done -v +

#@gmic remove_opacity
#@gmic : Remove opacity channel of selected images.
remove_opacity :
  -e[^-1] "Remove opacity channel of image$?."
  -v - -repeat @# -l[$>]
    -if {s==2} -channels 0
    -elif {s==4} -channels 0,2
    -endif
  -nm @{-1,n},1 -endl -done -v +

#@gmic select_color : tolerance[%]>=0,col1,..,colN
#@gmic : Select pixels with specified color in selected images.
#@gmic : $ image.jpg --select_color 40,204,153,110
select_color : -skip ${1=0}
  -e[^-1] "Select color (${2--1}) in image$?, with tolerance $1."
  -v - -repeat @# -l[$>]
    --fc ${2--1} -- -norm -le $1
  -endl -done -v +

#@gmic sepia
#@gmic : Apply sepia tones effect on selected images.
#@gmic : $ image.jpg --sepia
sepia :
  -e[^-1] "Apply sepia tones effect on image$?."
  -v - (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200) -r[-1] 256,1,1,3,3
  -repeat {@#-1} -l[$>,-1] -split_opacity -luminance[0] -map[0] [-1] -a[^-1] c -endl -done
  -rm[-1] -v +

#@gmic solarize
#@gmic : Solarize selected images.
#@gmic : $ image.jpg --solarize
solarize :
  -e[^-1] "Solarize image$?."
  -v - -luminance -n 0,128 -map 1 -v +

#@gmic split_opacity
#@gmic : Split color and opacity parts of selected images.
split_opacity :
  -e[^-1] "Split color and opacity parts of image$?."
  -v - -repeat @# -l[$<] -s c,{if(s==4,-3,if(s==2,-1,-s))} -endl -done -v +

#@gmic srgb2rgb : (+)
#@gmic : Convert selected images from sRGB to RGB colorbases.

#@gmic to_a
#@gmic : Force selected images to have an alpha channel.
to_a :
  -e[^-1] "Force image$? to have an alpha channel."
  -v - -repeat @# -l[$>]
    -if {s==1||s==3} -channels 0,{s} -sh[-1] {s-1},{s-1} -f[-1] 255 -rm[-1] -endif
  -endl -done -v +

#@gmic to_color
#@gmic : Force selected images to be in color mode (RGB or RGBA).
to_color :
  -e[^-1] "Force image$? to be in color mode."
  -v - -repeat @# -l[$>]
    -if {s>4} -error[] "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {s==2} -r 100%,100%,1,4,0,1,0,0,0,1
    -elif {s==1} -r 100%,100%,1,3,1
    -endif
  -endl -done -v +

#@gmic to_colormode : mode={ 0=adaptive | 1=G | 2=GA | 3=RGB | 4=RGBA }
#@gmic : Force selected images to be in a given color mode.
#@gmic : Default value: 'mode=0'.
to_colormode : -skip ${1=0}
  -if {$1==1} -to_gray
  -elif {$1==2} -to_graya
  -elif {$1==3} -to_rgb
  -elif {$1==4} -to_rgba
  -else
    s=1 -repeat @#
      -if {@{$>,s}>4} -error "Image ["$>"] is not a G,GA,RGB or RGBA image."
      -else s={max($s,@{$>,s})}
      -endif
    -done -to_colormode $s
  -endif

#@gmic to_gray
#@gmic : Force selected images to be in GRAY mode.
#@gmic : $ image.jpg --to_gray
to_gray :
  -e[^-1] "Force image$? to be in GRAY mode."
  -v - -repeat @# -l[$>]
    -if {s>4} -error[] "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {s>=3} -channels 0,2 -luminance
    -elif {s==2} -r 100%,100%,100%,1,0
    -endif
  -endl -done -v +

#@gmic to_graya
#@gmic : Force selected images to be in GRAYA mode.
to_graya :
  -e[^-1] "Force image$? to be in GRAYA mode."
  -v - -repeat @# -l[$>]
    -if {s>4} -error[] "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
    -elif {s==4} --channels 3 -channels[-2] 0,2 -luminance[-2] -a c
    -elif {s==3} -luminance -channels 0,1 -sh[-1] 1,1 -f[-1] 255 -rm[-1]
    -elif {s==1} -channels 0,1 -sh[-1] 1,1 -f[-1] 255 -rm[-1]
    -endif
  -endl -done -v +

#@gmic to_pseudogray : _max_step>=0,_is_perceptual_constraint={ 0 | 1 },_bits_depth>0
#@gmic : Convert selected scalar images ([0-255]-valued) to pseudo-gray color images.
#@gmic : Default parameters : 'max_step=5', 'is_perceptual_constraint=1' and 'bits_depth=8'.
#@gmic : The original pseudo-gray technique has been introduced by Rich Franzen [http://r0k.us/graphics/pseudoGrey.html].
#@gmic : Extension of this technique to arbitrary increments for more tones, has been done by David Tschumperle.
to_pseudogray : -check "isint(${1=5}) && $1>=0 && isint(${3=8}) && $3>0" -skip ${2=1}
  -e[^-1] "Convert scalar image$? to pseudo-gray color images, with steps $1."
  -v - -channels 0 -srgb2rgb -pseudogray $1,{2.3*$2},$3

  # Compute colormap with 65336 entries, to have match corresponding lightness.
  --srgb2rgb[-1] -rgb2lab[-1] -channels[-1] 0 -*[-1] {65535/100} -round[-1] -rows[-1] 0,2
  -rv[-2,-1] -permute[-1] xcyz -+[-1] 1 -a[-2,-1] y -pointcloud[-1] 0
  --norm[-1] -neq[-1] 0 -distance[-1] 1 -*[-1] -1 -watershed[-2] [-1] -rm[-1] --[-1] 1

  # Map colormap to images, with lightness preservation.
  -repeat {@#-1}
    -to_rgb[$>] -rgb2lab[$>] -channels[$>] 0 -*[$>] {65535/100} -round[$>] -c[$>] 0,65535
    -map[$>] [-1]
  -done -rm[-1] -v +

#@gmic to_rgb
#@gmic : Force selected images to be in RGB mode.
to_rgb :
   -e[^-1] "Force image$? to be in RGB mode."
   -v - -repeat @# -l[$>]
     -if {s>4} -error[] "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
     -elif {s==4} -channels 0,2
     -elif {s==2} -channels 0,0 -r 100%,100%,100%,3
     -elif {s==1} -r 100%,100%,100%,3
     -endif
   -endl -done -v +

#@gmic to_rgba
#@gmic : Force selected images to be in RGBA mode.
to_rgba :
   -e[^-1] "Force image$? to be in RGBA mode."
   -v - -repeat @# -l[$>]
     -if {s>4} -error[] "Image ["@{<,-1}"] is not a G,GA,RGB or RGBA image."
     -elif {s==3} -channels 0,3 -sh[-1] 3,3 -f[-1] 255 -rm[-1]
     -elif {s==2} -r 100%,100%,100%,4 -sh[-1] 2,2 -f[-1] [-2] -rm[-1]
     -elif {s==1} -r 100%,100%,100%,4 -sh[-1] 3,3 -f[-1] 255 -rm[-1]
     -endif
   -endl -done -v +

#@gmic transfer_colors : _transfer_brightness={ 0 | 1 }
#@gmic : Transfer colors of the first selected image to the other ones.
#@gmic : Default value: 'transfer_brightness=0'.
#@gmic : $ image.jpg --rand 0,255 -reverse --transfer_colors 1
transfer_colors : -skip ${1=0}
  -e[^-1] "Transfer colors of image [0] to image$?."
  -if {@#<2} -return -endif
  -v - -to_rgb[0] -to_colormode[^0] {max(3,@{-max_s})} -c 0,255      # Convert all images to RGB[A]
  -repeat @# -l[$>] -split_opacity -rgb2ycbcr[0] -a c -endl -done    # Perform RGB[A] to YCbCr[A] conversion.
  -l[0] -s c -histogram_cumul 256,1,0,255 -a c -* 255 -endl          # Compute channel-by-channel cumulative histogram of target image.
  -repeat {@#-1} -l[0,-1]
    -if $1 -repeat 3 -sh[0,1] $>,$> -equalize[-1] 256,0,255 -index[-1] [-2],0,0 -rm[-2,-1] -done         # Transfer brightness + colors.
    -else -repeat 2 -sh[0,1] {$>+1},{$>+1} -equalize[-1] 256,0,255 -index[-1] [-2],0,0 -rm[-2,-1] -done  # Transfer colors only.
    -endif
  -endl -mv[-1] 1 -done -rm[0]
  -repeat @# -l[$>] -split_opacity -ycbcr2rgb[0] -a c -endl -done    # Perform YCbCr[A] to RGB[A] conversion.
  -v +

_transfer_colors :  # Check transfer_colors performance.
  -repeat @# -l[$>] -rgb2ycbcr -s c -histogram 256,0,255 -a c -dg 300,200 -endl -done

#@gmic xyz2rgb
#@gmic : Convert selected images from XYZ to RGB colorbases.
xyz2rgb :
  -e[^-1] "Convert image$? from XYZ to RGB color bases."
  -v - -* 255 -mix_rgb 3.240479,-1.537150,-0.498535,-0.969256,1.875992,0.041556,0.055648,-0.204043,1.057311 -c 0,255 -v +

#@gmic xyz82rgb
#@gmic : Convert selected images from XYZ8 to RGB color bases.
xyz82rgb :
  -e[^-1] "Convert image$? from XYZ8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 255 -rm[-1]
    -sh[$>] 1,1 -/[-1] 255 -rm[-1]
    -sh[$>] 2,2 -/[-1] 231.8182 -rm[-1]
  -done -xyz2rgb -v +

#@gmic ycbcr2rgb
#@gmic : Convert selected images from YCbCr to RGB colorbases.
ycbcr2rgb :
  -e[^-1] "Convert image$? from YCbCr to RGB color bases."
  -v - -repeat @# -l[$>] -sh 0,0 --[-1] 16 -rm[-1] -sh 1,2 --[-1] 128 -rm[-1] -endl -done
  -mix_rgb 298,0,409,298,-100,-208,298,516,0 -+ 128 -/ 256 -c 0,255
  -v +

#@gmic yuv2rgb
#@gmic : Convert selected images from YUV to RGB colorbases.
yuv2rgb :
  -e[^-1] "Convert image$? from YUV to RGB color bases."
  -v - -mix_rgb 1,0,1.13983,1,-0.39465,-0.5806,1,2.03211,0 -* 255 -v +

#@gmic yuv82rgb
#@gmic : Convert selected images from YUV8 to RGB color bases.
yuv82rgb :
  -e[^-1] "Convert image$? from YUV8 to RGB color bases."
  -v - -repeat @#
    -sh[$>] 0,0 -/[-1] 255 -rm[-1]
    -sh[$>] 1,1 -/[-1] 289.773 --[-1] 0.44 -rm[-1]
    -sh[$>] 2,2 -/[-1] 205.645 --[-1] 0.62 -rm[-1]
  -done -yuv2rgb -v +

#---------------------------------
#
#@gmic :: Geometry manipulation
#
#---------------------------------

#@gmic a : eq. to '-append' : (*)

#@gmic append : [image],axis,_alignment : axis,_alignment : (*)
#@gmic : Append specified image to selected images, or all selected images together, along specified axis.
#@gmic : (eq. to '-a').
#@gmic : 'axis' can be { x | y | z | c }.
#@gmic : Usual 'alignment' values are { 0=left-justified | 0.5=centered | 1=right-justified }.
#@gmic : Default value: 'alignment=0'.
#@gmic : $ image.jpg -split y,10 -reverse -append y
#@gmic : $ image.jpg -repeat 5 --rows[0] 0,{10+18*$>}% -done -remove[0] -append x,0.5
#@gmic : $ image.jpg -append[0] [0],y

#@gmic append_tiles : _M>=0,_N>=0,0<=_x_alignment<=1,0<=_y_alignment<=1
#@gmic : Append MxN selected tiles as new images.
#@gmic : If 'N' is set to 0, number of rows is estimated automatically.
#@gmic : If 'M' is set to 0, number of columns is estimated automatically.
#@gmic : If 'M' and 'N' are both set to '0', auto-mode is used.
#@gmic : If 'M' or 'N' is set to 0, only a single image is produced.
#@gmic : 'x_alignment' and 'y_aligment' tells about the alignment of tiles when they have different sizes.
#@gmic : Default values: 'M=0', 'N=0', 'x_alignment=y_alignment=0.5'.
#@gmic : $ image.jpg -split xy,4 -append_tiles ,
append_tiles : -check "isint(${1=0}) && isint(${2=0}) && ${3=0.5}>=0 && $3<=1 && ${4=$3}>=0 && $4<=1"
  -if {!@#} -e[0--3] "Append image$? as a 0x0-tiled image." -return -endif
  -if {!$1&&!$2} # auto-mode
    -v - N={int(sqrt(@#))} M={round(@#/$N,1,1)}
    -v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image (auto-mode)." -v -
    MN={$M*$N} -if {@#%$MN} {$MN-(@#%$MN)} -s[-1] x -endif
  -elif {!$2} # auto-rows
    -v - M=$1 N={round(@#/$1,1,1)}
    -v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image." -v -
    -if {$M>@#} -v + -warn[0--3] "Missing images for having one row in a "${M}x${N}"-tiled image." -return -endif
    -if {@#%$M} {$M-(@#%$M)} -s[-1] x -endif
  -elif {!$1} # auto-columns
    -v - M={round(@#/$2,1,1)} N=$2
    -v + -e[0--3] "Append image$? as a "${M}x${N}"-tiled image." -v -
    -if {$N>@#} -v + -warn[0--3] "Missing images for having one column in a "${M}x${N}"-tiled image." -return -endif
    -if {@#%$M} {$M-(@#%$M)} -s[-1] x -endif
  -else
    -e[0--3] "Append image$?, as $1x$2-tiled images." -v -
    M=$1 N=$2
  -endif

  MN={$M*$N}
  -repeat {int(@#/$MN)} -l[$>-{$>+$MN-1}]

    # Resize to best match for each column and row.
    $MN,1,1,2 -repeat $MN -point[-1] $>,0,0,1,@{$>,w},@{$>,h} -done -r[-1] $M,$N,1,2,-1
    -s[-1] c -l[-2] -s y -max -endl -l[-1] -s x -max -endl
    i=0 -repeat $N y=$> -repeat $M -r[$i] @{-2,$>},@{-1,$y},100%,100%,0,0,$3,$4 i={$i+1} -done -done
    -rm[-2,-1]

    # Append images together.
    -repeat {int(@#/$M)} -a[$>-{$>+$M-1}] x -done
    -repeat {int(@#/$N)} -a[$>-{$>+$N-1}] y -done
  -endl -done
  -v +

#@gmic autocrop : value1,value2,... : (no args) : (*)
#@gmic : Autocrop selected images by specified vector-valued intensity.
#@gmic : If no arguments are provided, cropping value is guessed.
#@gmic : $ 400,400,1,3 -fill_color 64,128,255 -ellipse 50%,50%,120,120,0,1,255 --autocrop

#@gmic autocrop_components : _threshold[%],_min_area[%]>=0,_is_high_connectivity={ 0 | 1 },_output_type={ 0=crop | 1=segmentation | 2=coordinates }
#@gmic : Autocrop and extract connected components in selected images, according to a mask given as the last channel of
#@gmic : each of the selected image (e.g. alpha-channel).
#@gmic : Default values: 'threshold=0%', 'min_area=0.1%', 'is_high_connectivity=0' and 'output_type=1'.
#@gmic : $ 256,256 -noise 0.1,2 -dilate_circ 20 -label_fg 0,1 -normalize 0,255 --neq 0 -*[-1] 255 -append c --autocrop_components ,
autocrop_components : -skip ${1=0%} -check "${2=0.1%}>=0 && isbool(${3=0}) && isint(${4=1}) && $4>=0 && $4<=2"
  -e[^-1] "Autocrop connected components from image$?, with threshold $1, minimal area $2, "@{-arg\ 1+$3,low,high}" connectivity "\
          "and output type set to '"@{-arg\ 1+$4,crop,segmentation,coordinates}"'.\n"
  -v - -repeat @# -l[$>]
    min_area={max(1,round(if(@{-is_percent\ $2},$2*w*h,$2)))}
    --channels 100% -gt[-1] $1 -area_fg[-1] 0,$3 -ge[-1] $min_area  # Discard background and small objects.
    --area[-1] 0,1 -lt[-1] $min_area -or[-2,-1] -label_fg[-1] 0,1   # Fill small holes in objects.

    # Extract detected objects.
    N={iM} -repeat {iM}
      n={1+$>}
      -v + -e[] "\r  > "$n/$N -v -
      -rprogress {100*$n/$N}
      --==[1] $n --*[0,-1] -rm[-2]
      -if {$4==0} coords=@{-autocrop_coords[-1]\ auto} -rm[-1] --z[0] $coords
      -elif {$4==1} -autocrop[-1]
      -else coords=@{-autocrop_coords[-1]\ auto} -rm[-1] ($coords) -y[-1]
      -endif
    -done
    -rm[0,1]
    -if {$4==2} -a x -endif
  -endl -done -v +

#@gmic autocrop_seq : value1,value2,... | auto
#@gmic : Autocrop selected images using the crop geometry of the last one by specified vector-valued intensity,
#@gmic : or by automatic guessing the cropping value.
#@gmic : Default value: auto mode.
#@gmic : $ image.jpg --fill[-1] 0 -ellipse[-1] 50%,50%,30%,20%,0,1,1 -autocrop_seq 0
autocrop_seq : -skip ${1=auto}
  -e[^-1] "Auto-crop image$? using crop geometry of last image by vector '$*'."
  -if {!@#} -return -endif
  -v -
  -if {@#==1} -_autocrop$is_auto ${1--1} -v + -return -endif
  coords=@{-autocrop_coords[-1]\ ${1--1}}
  x0={arg(1,$coords)} y0={arg(2,$coords)} z0={arg(3,$coords)}
  x1={arg(4,$coords)} y1={arg(5,$coords)} z1={arg(6,$coords)}
  -if {$x0>$x1" || "$y0>$y1" || "$z0>$z1} -i[0--2] 0 -rm[1--1:2]
  -else -crop $x0,$y0,$z0,$x1,$y1,$z1
  -endif
  -v +

#@gmic channels : { [image0] | c0[%] },_{ [image1] | c1[%] } : (*)
#@gmic : Keep only specified channels of selected images.
#@gmic : Dirichlet boundary is used when specified channels are out of range.
#@gmic : $ image.jpg -channels 0,1
#@gmic : $ image.jpg -luminance -channels 0,2

#@gmic columns : { [image0] | x0[%] },_{ [image1] | x1[%] } : (*)
#@gmic : Keep only specified columns of selected images.
#@gmic : Dirichlet boundary is used when specified columns are out of range.
#@gmic : $ image.jpg -columns -25%,50%

#@gmic z : eq. to '-crop'. : (*)

#@gmic crop : x0[%],x1[%],_boundary : x0[%],y0[%],x1[%],y1[%],_boundary : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%],_boundary : x0[%],y0[%],z0[%],c0[%],x1[%],y1[%],z1[%],c1[%],_boundary : (noargs) : (*)
#@gmic : Crop selected images with specified region coordinates.
#@gmic : (eq. to '-z').
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : (noargs) runs interactive mode (uses the instant window [0] if opened).
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --crop -230,-230,280,280,1 -crop[0] -230,-230,280,280,0
#@gmic : $ image.jpg -crop 25%,25%,75%,75%

#@gmic diagonal
#@gmic : Transform selected vectors as diagonal matrices.
#@gmic : $ 1,10,1,1,'y' --diagonal
diagonal :
  -e[^-1] "Transform vector$? as diagonal matrix."
  -v - -y -repeat @# -r[$>] @{$>,h+1},100%,1,1,0 -r[$>] @{$>,h},100%,1,1,-1 -done -v +

#@gmic elevate : _depth,_is_plain,_is_colored
#@gmic : Elevate selected 2d images into 3d volumes.
#@gmic : Default values: 'depth=64', 'is_plain=1' and 'is_colored=1'.
elevate : -check "${1=64}>0" -skip ${2=1},${3=1}
  -e[^-1] "Elevate 2d image$? into $1-slices volume(s)."
  -v - -r 100%,100%,1,100%
  -repeat @# -l[$>] nm=@{0,n}
    --norm 100%,100%,$1,{if($3,@{0,s},1)}
    m=@{-2,m} d={@{-2,M}-$m}
    -repeat $1
      -if $2 --ge[1] {$m+$d*($>+1)/$1}
      -else --t2[1] {$m+$d*$>/$1},{$m+$d*($>+1)/$1}
      -endif
      -r[-1] 100%,100%,1,[-2] -if $3 -*[-1] [0] -endif
      -j[-2] [-1],0,0,$> -rm[-1]
    -done
  -rm[0,1] -nm $nm,1 -endl -done -v +

#@gmic expand_x : size_x>=0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Expand selected images along the x-axis.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_x 30,0
expand_x : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the x-axis with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] @{$>,w+2*$1},100%,100%,100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_xy : size>=0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Expand selected images along the xy-axes.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_xy 30,0
expand_xy : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the xy-axes with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] @{$>,w+2*$1},@{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_xyz : size>=0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Expand selected images along the xyz-axes.
#@gmic : Default value: 'border=1'.
expand_xyz : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the xyz-axes with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] @{$>,w+2*$1},@{$>,h+2*$1},@{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_y : size_y>=0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Expand selected images along the y-axis.
#@gmic : Default value: 'border=1'.
#@gmic : $ image.jpg -expand_y 30,0
expand_y : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the y-axis with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] 100%,@{$>,h+2*$1},100%,100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic expand_z : size_z>=0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Expand selected images along the z-axis.
#@gmic : Default value: 'border=1'.
expand_z : -check "$1>=0 && ${2=1}>=0 && $2<=2"
  -e[^-1] "Expand image$? along the z-axis with size $1 and border conditions $2."
  -v - -repeat @# -r[$>] 100%,100%,@{$>,d+2*$1},100%,0,$2,0.5,0.5,0.5 -done -v +

#@gmic mirror : { x | y | z }..{ x | y | z } : (*)
#@gmic : Mirror selected images along specified axes.
#@gmic : $ image.jpg --mirror y --mirror[0] c
#@gmic : $ image.jpg --mirror x --mirror y -append_tiles 2,2

#@gmic permute : permutation_string : (*)
#@gmic : Permute selected image axes by specified permutation.
#@gmic : 'permutation' is a combination of the character set {x|y|z|c},
#@gmic : e.g. 'xycz', 'cxyz', ..
#@gmic : $ image.jpg -permute yxzc

#@gmic r : eq. to '-resize'. : (*)

#@gmic resize : [image],_interpolation,_boundary,_ax,_ay,_az,_ac : {[image_w] | width>0[%]},_{[image_h] | height>0[%]},_{[image_d] | depth>0[%]},_{[image_s] | spectrum>0[%]},_interpolation,_boundary,_ax,_ay,_az,_ac : (noargs) : (*)
#@gmic : Resize selected images with specified geometry.
#@gmic : (eq. to '-r').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0 or 4'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : (noargs) runs interactive mode (uses the instant window [0] if opened).
#@gmic : Default values: 'interpolation=1', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg (0,1;0,1^0,0;1,1^1,1;1,1) -resize[-1] [-2],3 -mul[-2] [-1]
#@gmic : $ image.jpg --resize[-1] 256,128,1,3,2 --resize[-1] 120%,120%,1,3,0,1,0.5,0.5 --resize[-1] 120%,120%,1,3,0,0,0.2,0.2 --resize[-1] [0],[0],1,3,4

#@gmic pow2 : _interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images so that each dimension is a power of 2.
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=0', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize_pow2[-1] 0
resize_pow2 : -check "isint(${1=0}) && $1>=-1 && $1<=6" -skip ${2=0},${3=0},${4=0},${5=0},${6=0}
  -e[^-1] "Resize image$? so that each dimension is a power of 2."
  -v - -repeat @#
    -r[$>] @{$>,2^(round(log2(w),1,1))},@{$>,2^(round(log2(h),1,1))},@{$>,2^(round(log2(d),1,1))},100%,${1-6}
  -done -v +

#@gmic rr2d : eq. to '-resize_ratio2d'.
rr2d :
  -v - __s="$?" -v +
  -_resize_ratio2d $*

#@gmic resize_ratio2d : width>0,height>0,_mode={ 0=inside | 1=outside | 2=padded },0=<_interpolation<=6
#@gmic : Resize selected images while preserving their aspect ratio.
#@gmic : (eq. to '-rr2d').
#@gmic : Default values: 'mode=0' and 'interpolation=6'.
resize_ratio2d :
  -v - __s="$?" -v +
  -_$0 $*

_resize_ratio2d : -check "$1>0 && $2>0 && ${3=0}>=0 && $3<=2 && ${4=6}>=0 && $4<=6"
  -e[0--3] "Resize 2d image"$__s" to $1x$2 with ratio-"@{-arg\ 1+$3,inside,outside,padded}\
           " mode and interpolation type $4."
  -v - -repeat @#
    ratio=@{$>,if($3==1,max($1/w,$2/h),min($1/w,$2/h))}
    -r[$>] @{$>,w*$ratio},@{$>,h*$ratio},100%,100%,$4
  -done
  -if {$3==2} -r $1,$2,100%,100%,0,0,0.5,0.5 -endif
  -v +

#@gmic r2dx : eq. to '-resize2dx'.
r2dx :
  -v - __s="$?" -v +
  -_resize2dx $*

#@gmic resize2dx : width[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the x-axis, preserving 2d ratio.
#@gmic : (eq. to '-r2dx').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize2dx 100,2 -append x
resize2dx :
  -v - __s="$?" -v +
  -_$0 $*

_resize2dx : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 2d image"$__s" to $1 pixels along the x-axis, preserving 2d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*w,$1)}
    -r {max(1,$size)},{max(1,h*$size/w)},100%,100%,${2-7}
  -endl -done -v +

#@gmic r2dy : eq. to '-resize2dy'.
r2dy :
  -v - __s="$?" -v +
  -_resize2dy $*

#@gmic resize2dy : height[%]>=0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the y-axis, preserving 2d ratio.
#@gmic : (eq. to '-r2dy').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
#@gmic : $ image.jpg --resize2dy 100,2 -append x
resize2dy :
  -v - __s="$?" -v +
  -_$0 $*

_resize2dy : -check "$1>=0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 2d image"$__s" to $1 pixels along the y-axis, preserving 2d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*h,$1)}
    -r {max(1,w*$size/h)},{max(1,$size)},100%,100%,${2-7}
  -endl -done -v +

#@gmic r3dx : eq. to '-resize3dx'.
r3dx :
  -v - __s="$?" -v +
  -_resize3dx $*

#@gmic resize3dx : width[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the x-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dx').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dx :
  -v - __s="$?" -v +
  -_$0 $*

_resize3dx : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 3d image"$__s" to $1 pixels along the x-axis, preserving 3d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*w,$1)}
    -r {max(1,$size)},{max(1,h*$size/w)},{max(1,d*$size/w)},100%,${2-7}
  -endl -done -v +

#@gmic r3dy : eq. to '-resize3dy'.
r3dy :
  -v - __s="$?" -v +
  -_resize3dy $*

#@gmic resize3dy : height[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the y-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dy').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dy :
  -v - __s="$?" -v +
  -_$0 $*

_resize3dy : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 3d image"$__s" to $1 pixels along the y-axis, preserving 3d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*h,$1)}
    -r {max(1,w*$size/h)},{max(1,$size)},{max(1,d*$size/h)},100%,${2-7}
  -endl -done -v +

#@gmic r3dz : eq. to '-resize3dz'.
r3dz :
  -v - __s="$?" -v +
  -_resize3dz $*

#@gmic resize3dz : depth[%]>0,_interpolation,_boundary,_ax,_ay,_az,_ac
#@gmic : Resize selected images along the z-axis, preserving 3d ratio.
#@gmic : (eq. to '-r3dz').
#@gmic : 'interpolation' can be { -1=none (memory content) | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | 5=bicubic | 6=lanczos }.
#@gmic : 'boundary' has different meanings, according to the chosen 'interpolation' mode :
#@gmic : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary' is meaningless.
#@gmic : . When 'interpolation==0', 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary' can be { 0=none | 1=neumann }.
#@gmic : 'ax,ay,az,ac' set the alignment mode along each axis when 'interpolation=0'
#@gmic : (set to '0' by default, must be defined in range [0,1]).
#@gmic : Default values: 'interpolation=3', 'boundary=0' and 'ax=ay=az=ac=0'.
resize3dz :
  -v - __s="$?" -v +
  -_$0 $*

_resize3dz : -check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=2 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  -e[0--3] "Resize 3d image"$__s" to $1 pixels along the z-axis, preserving 3d ratio."
  -v - -repeat @# -l[$>]
    size={if(@{-is_percent\ $1},$1*d,$1)}
    -r[$>] {max(1,w*$size/d)},{max(1,h*$size/d)},{max(1,$size)},100%,${2-7}
  -endl -done -v +

#@gmic rotate : angle,_interpolation,_boundary,_cx[%],_cy[%],_zoom : (*)
#@gmic : Rotate selected images with specified angle (in deg.).
#@gmic : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : When rotation center ('cx','cy') is specified, the size of the image is preserved.
#@gmic : Default values: 'boundary=0', 'interpolation=1', 'cx=cy=(undefined)' and 'zoom=1'.
#@gmic : $ image.jpg --rotate -25,1,2,50%,50%,0.6 -rotate[0] 25

#@gmic rotate_tileable : angle,_max_size_factor>=0
#@gmic : Rotate selected images by specified angle and make them tileable.
#@gmic : If resulting size of an image is too big, the image is replaced by a 1x1 image.
#@gmic : Default values: 'max_size_factor=8'.
rotate_tileable : -check ${2=8}>=0
  -e[^-1] "Rotate image$? with angle $1 deg. and make them tileable."
  -v -

  # Reduce angle to known fraction.
  angle={$1%360}
  -if {$angle>=270} -rotate 270 angle={$angle-270}
  -elif {$angle>=180} -rotate 180 angle={$angle-180}
  -elif {$angle>=90} -rotate 90 angle={$angle-90}
  -endif
  (0,1;1,8;1,7;1,6;1,5;1,4;1,5;1,3;2,5;1,2;2,5;3,5;2,3;3,4;4,5;1,1;5,4;7,5;3,2;8,5;9,5;2,1;3,1;4,1;5,1;6,1;7,1;8,1) # List of known fractions.
  -s[-1] x,2 --/[-2,-1] -atan[-1] -*[-1] {180/pi}         # Compute corresponding angles.
  ($angle) -index[-1] [-2] -rm[-2]
  p=@{-3,@-1} q=@{-2,@-1} -rm[-3--1]                      # Find nearest fraction p/q to atan(angle).
  -if {!$p||!$q} -return -endif

  -repeat @# -l[$>]
    # Compute width and height of tile.
    theta={atan2($p,$q)}
    gcd=@{-gcd" "{h*$q},{w*$p}}
    pw={h*$q/$gcd}
    nw={round($pw*w/cos($theta))}
    gcd=@{-gcd" "{h*$p},{w*$q}}
    qh={w*$q/$gcd}
    nh={round($qh*h/cos($theta))}

    # Rotate and make tileable (may result in very large images!).
    -if {!$2" || "($nw<$2*w" && "$nh<$2*h)}
      -r {1.5*$nw},{1.5*$nh},1,100%,0,2
      -rotate {$theta*180/pi},1,2,50%,50%
      -r $nw,$nh,1,100%,0,2,0.5,0.5
    -else -rm 1
    -endif
  -endl -done -v +

#@gmic rows : { [image0] | y0[%] },_{ [image1] | y1[%] } : (*)
#@gmic : Keep only specified rows of selected images.
#@gmic : Dirichlet boundary is used when specified rows are out of range.
#@gmic : $ image.jpg -rows -25%,50%

#@gmic scale2x
#@gmic : Resize selected images using the Scale2x algorithm.
#@gmic : $ image.jpg -threshold 50% -resize 50%,50% --scale2x
scale2x :
  -e[^-1] "Double xy-dimensions of image$?, using Scale2x algorithm."
  -v - -repeat @# -l[$>]
    -r 200%,200%

#    -apply_parallel_overlap
     -f "dx=x&1;dy=y&1;A=j(0,-2,0,0,0,1);B=j(2,0,0,0,0,1);C=j(-2,0,0,0,0,1);D=j(0,2,0,0,0,1);"\
        "!dy*(!dx*if(C==A&&C!=D&&A!=B,A,i) + dx*if(A==B&&A!=C&&B!=D,B,i)) + dy*(dx*if(B==D&&B!=A&&D!=C,D,i) + !dx*if(D==C&&D!=B&&C!=A,C,i))"
  -endl -done -v +

#@gmic scale3x
#@gmic : Resize selected images using the Scale3x algorithm.
#@gmic : $ image.jpg -threshold 50% -resize 33%,33% --scale3x
scale3x :
  -e[^-1] "Triple xy-dimensions of image$?, using Scale3x algorithm."
  -v - -repeat @# -l[$>]
    -r 300%,300%
    -f "dx=x%3;dy=y%3;c0=!dx;c1=(dx==1);c2=(dx==2);"\
       "A=j(-3,-3,0,0,0,1);B=j(0,-3,0,0,0,1);C=j(3,-3,0,0,0,1);"\
       "D=j(-3,0,0,0,0,1);F=j(3,0,0,0,0,1);"\
       "G=j(-3,3,0,0,0,1);H=j(0,3,0,0,0,1);I=j(3,3,0,0,0,1);"\
       "!dy*(c0*if(D==B&&D!=H&&B!=F,D,i) + c1*if((D==B&&D!=H&&B!=F&&i!=C)||(B==F&&B!=D&&F!=H&&i!=A),B,i) + c2*if(B==F&&B!=D&&F!=H,F,i)) + "\
       "(dy==1)*(c0*if((H==D&&H!=F&&D!=B&&i!=A)||(D==B&&D!=H&&B!=F&&i!=G),D,i) + c1*i + c2*if((B==F&&B!=D&&F!=H&&i!=I)||(F==H&&F!=B&&H!=D&&i!=C),F,i)) + "\
       "(dy==2)*(c0*if(H==D&&H!=F&&D!=B,D,i) + c1*if((F==H&&F!=B&&H!=D&&i!=G)||(H==D&&H!=F&&D!=B&&i!=I),H,i) + c2*if(F==H&&F!=B&&H!=D,F,i))"
  -endl -done -v +

#@gmic shift : vx[%],_vy[%],_vz[%],_vc[%],_boundary : (*)
#@gmic : Shift selected images by specified displacement vector.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : Default value: 'boundary=0'.
#@gmic : $ image.jpg --shift[0] 50%,50%,0,0,0 --shift[0] 50%,50%,0,0,1 --shift[0] 50%,50%,0,0,2

#@gmic shrink_x : size_x>=0
#@gmic : Shrink selected images along the x-axis.
#@gmic : $ image.jpg -shrink_x 30
shrink_x : -check "$1>=0"
  -e[^-1] "Shrink image$? along the x-axis with size $1."
  -v - -repeat @# -z[$>] $1,@{$>,w-$1-1} -done -v +

#@gmic shrink_xy : size>=0
#@gmic : Shrink selected images along the xy-axes.
#@gmic : $ image.jpg -shrink_xy 30
shrink_xy : -check "$1>=0"
  -e[^-1] "Shrink image$? along the xy-axes with size $1."
  -v - -repeat @# -z[$>] $1,$1,@{$>,w-$1-1},@{$>,h-$1-1} -done -v +

#@gmic shrink_xyz : size>=0
#@gmic : Shrink selected images along the xyz-axes.
shrink_xyz : -check "$1>=0"
  -e[^-1] "Shrink image$? along the xyz-axes with size $1."
  -v - -repeat @# -z[$>] $1,$1,$1,@{$>,w-$1-1},@{$>,h-$1-1},@{$>,d-$1-1} -done -v +

#@gmic shrink_y : size_y>=0
#@gmic : Shrink selected images along the y-axis.
#@gmic : $ image.jpg -shrink_y 30
shrink_y : -check "$1>=0"
  -e[^-1] "Shrink image$? along the y-axis with size $1."
  -v - -repeat @# -z[$>] 0,$1,100%,@{$>,h-$1-1} -done -v +

#@gmic shrink_z : size_z>=0
#@gmic : Shrink selected images along the z-axis.
shrink_z : -check "$1>=0"
  -e[^-1] "Shrink image$? along the z-axis with size $1."
  -v - -repeat @# -z[$>] 0,0,$1,100%,100%,@{$>,d-$1-1} -done -v +

#@gmic slices : { [image0] | z0[%] },_{ [image1] | z1[%] } : (*)
#@gmic : Keep only specified slices of selected images.
#@gmic : Dirichlet boundary is used when specified slices are out of range.

#@gmic sort : _ordering={ + | - },_axis={ x | y | z | c } : (+)
#@gmic : Sort pixel values of selected images.
#@gmic : If 'axis' is specified, the sorting is done according to the data of the first column/row/slice/channel
#@gmic : of selected images.
#@gmic : Default values: 'ordering=+' and 'axis=(undefined)'.
#@gmic : $ 64 -rand 0,100 --sort -display_graph 400,300,3

#@gmic s : eq. to '-split'. : (*)

#@gmic split : { x | y | z | c }..{ x | y | z | c },_nb_parts : keep_splitting_values={ + | - },value1,value2,... : (no args) : (*)
#@gmic : Split selected images either along a specified axis, or regarding to a sequence of scalar values, or as a set of constant sub-vectors.
#@gmic : (eq. to '-s').
#@gmic : 'nb_parts' can be { 0=maximum split | >0=split in N parts | <0=split in parts of size -N }.
#@gmic : Default value: 'nb_parts=0'.
#@gmic : $ image.jpg -split c
#@gmic : $ image.jpg -split y,3
#@gmic : $ image.jpg -split x,-128
#@gmic : $ 1,20,1,1,"1,2,3,4" --split -,2,3 -append[1--1] y

#@gmic split_tiles : M!=0,_N!=0,_is_homogeneous={ 0 | 1 }
#@gmic : Split selected images as a MxN array of tiles.
#@gmic : If M or N is negative, it stands for the tile size instead.
#@gmic : Default values: 'N=M' and 'is_homogeneous=0'.
#@gmic : $ image.jpg --local -split_tiles 5,4 -blur 3,0 -sharpen 700 -append_tiles 4,5 -endlocal
split_tiles : -skip ${2=$1},${3=0}
  -if $3 -e[^-1] "Split image$? as a $1x$2 array of homogeneous tiles."
  -else -e[^-1] "Split image$? as a $1x$2 array of tiles."
  -endif
  -v - -repeat @# -l[$<] -s y,$2 -s x,$1 -if $3 -r [0],[0],100%,100%,0 -endif -endl -done -v +

#@gmic y : eq. to '-unroll'. : (*)

#@gmic unroll : _axis={ x | y | z | c } : (*)
#@gmic : Unroll selected images along specified axis.
#@gmic : (eq. to '-y').
#@gmic : Default value: 'axis=y'.
#@gmic : $ (1,2,3;4,5,6;7,8,9) --unroll y

#@gmic upscale_smart : width,_height,_depth,_smoothness>=0,_anisotropy=[0,1],sharpening>=0
#@gmic : Upscale selected images with an edge-preserving algorithm.
#@gmic : Default values: 'height=100%', 'depth=100%', 'smoothness=2', 'anisotropy=0.4' and 'sharpening=10'.
#@gmic : $ image.jpg -resize2dy 100 --upscale_smart 500%,500% -append x
upscale_smart : -skip ${2=100%},${3=100%} -check "${4=2}>=0 && ${5=0.4}>=0 && $5<=1 && ${6=10}>=0"
  -e[^-1] "Upscale image$? to $1x$2x$3, with smoothness $4, anisotropy $5 and sharpening $6."
  -v - -repeat @# -l[$>]
    w={w} h={h}
    --r[-1] $1,$2,$3,1,0 # Compute desired dimensions.
    -if {w<$w" && "h<$h} # Test for downscaling
      -rm[-1] -r[-1] $1,$2,$3,100%,2
    -else
      -rm[-1] --diffusiontensors 0,$5,1.2,1.2
      -r[-2,-1] $1,$2,$3,100%,5
      -smooth[-2] [-1],$4 -rm[-1]
      -apply_channels "-sharpen[-1] $6,10",3,0
    -endif
  -endl -done -v +

#@gmic warp : [warping_field],_is_relative={ 0 | 1 },_interpolation,_boundary,_nb_frames>0 : (+)
#@gmic : Warp selected image with specified displacement field.
#@gmic : 'interpolation' can be { 0=nearest-neighbor | 1=linear | 2=cubic }.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann | 2=cyclic }.
#@gmic : Default values: 'is_relative=0', 'interpolation=1', 'boundary=1' and 'nb_frames=1'.
#@gmic : $ image.jpg 100%,100%,1,2,'X=x/w-0.5;Y=y/h-0.5;R=(X*X+Y*Y)^0.5;A=atan2(Y,X);130*R*if(c==0,cos(4*A),sin(8*A))' -warp[-2] [-1],1,1,0 -quiver[-1] [-1],10,0.2,1,1,100

#---------------------------------
#
#@gmic :: Filtering
#
#---------------------------------

#@gmic bandpass : _min_freq[%],_max_freq[%]
#@gmic : Apply bandpass filter to selected images.
#@gmic : Default values: 'min_freq=0' and 'max_freq=20%'.
#@gmic : $ image.jpg -bandpass 1%,3%
bandpass : -skip ${1=0},${2=20%}
  -e[^-1] "Apply bandpass filter [$1,$2] to image$?."
  -v - -repeat @# -l[$>]
    100%,100%,100% -f[-1] "sqrt((x/w-0.5)^2 + (y/h-0.5)^2 + (z/d-0.5)^2)"
    -n[-1] 0,1 -t2[-1] $1,$2 -shift[-1] {int(w/2)},{int(h/2)},50%,0,2
    -fft[-2] -*[-3] [-1] -*[-2,-1] -ifft -rm[-1]
  -endl -done -v +

#@gmic bilateral : [guide],std_variation_s>0[%],std_variation_r[%]>0 : std_variation_s>0[%],std_variation_r[%]>0 : (+)
#@gmic : Blur selected images by anisotropic (eventually joint/cross) bilateral filtering.
#@gmic : If a guide image is provided, it is used for computing the smoothing geometry in the cross bilateral filter.
#@gmic : A guide image must be of the same xyz-size as the selected images.
#@gmic : $ image.jpg [0] -repeat 5 -bilateral[-1] 10,10 -done

#@gmic b : eq. to '-blur'. : (+)

#@gmic blur : std_variation>=0[%],_boundary={ 0=dirichlet | 1=neumann },_kernel={ 0=quasi-gaussian (faster) | 1=gaussian } : (+)
#@gmic : Blur selected images by a quasi-gaussian or gaussian filter (recursive implementation).
#@gmic : (eq. to '-b').
#@gmic : Default value: 'boundary=1' and 'kernel=0'.
#@gmic : $ image.jpg --blur 5,0 --blur[0] 5,1

#@gmic blur_angular : amplitude[%],_cx,_cy
#@gmic : Apply angular blur on selected images.
#@gmic : Default values: 'cx=cy=0.5'.
#@gmic : $ image.jpg --blur_angular 2%
blur_angular : -skip ${2=0.5},${3=0.5}
  -e[^-1] "Apply angular blur on image$?, with amplitude $1 and center ($2,$3)."
  -v - -euclidean2polar $2,$3,1.3,1 -expand_y 16,2 -blur_y $1 -shrink_y 16 -polar2euclidean $2,$3,1.3,1 -v +

#@gmic blur_linear : amplitude1[%],_amplitude2[%],_angle,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Apply linear blur on selected images, with specified angle and amplitudes.
#@gmic : Default values: 'amplitude2=0', 'angle=0' and 'boundary=1'.
#@gmic : $ image.jpg --blur_linear 10,0,45
blur_linear : -skip ${2=0},${3=0},${4=1}
  -e[^-1] "Apply linear blur on image$?, with angle $3 deg. and amplitudes ($1,$2)."
  -v -
  std1={if(@{-is_percent\ $1},$1*max(w,h),$1)}
  std2={if(@{-is_percent\ $2},$2*max(w,h),$2)}
  stdM={round(1.25*max($std1,$std2))}
  -if {$stdM<=0} -return -endif
  -repeat @# -l[$>]
    -expand_xy $stdM,{$4!=0}
    {2*$stdM},{2*$stdM} -gaussian[-1] $1,$2,$3 -normalize_sum[-1]
    -convolve_fft -shrink_xy $stdM
  -endl -done -v +

#@gmic blur_radial : amplitude[%],_cx,_cy
#@gmic : Apply radial blur on selected images.
#@gmic : Default values: 'cx=cy=0.5'.
#@gmic : $ image.jpg --blur_radial 2%
blur_radial : -skip ${2=0.5},${3=0.5}
  -e[^-1] "Apply radial blur on image$?, with amplitude $1 and center ($2,$3)."
  -v - -euclidean2polar $2,$3,5,1 -blur_x $1 -polar2euclidean $2,$3,5,1 -v +

#@gmic blur_selective : sigma>=0,_edges>0,_nb_scales>0
#@gmic : Blur selected images using selective gaussian scales.
#@gmic : Default values: 'sigma=5', 'edges=0.5' and 'nb_scales=5'.
#@gmic : $ image.jpg -noise 20 -cut 0,255 --local[-1] -repeat 4 -blur_selective , -done -endlocal
blur_selective : -check "${1=5}>=0 && ${2=0.5}>=0 && isint(${3=5}) && $3>0"
  -e[^-1] "Blur image$? using $3 selective gaussian scales, with sigma $1 and edges $2."
  -v - -repeat @# -l[$>] nm=@{0,n}
    --gradient_norm -+[-1] 1 -^[-1] {-max(0.01,$2)} -quantize[-1] {$3+1},0,1 -min[-1] {$3-1} -r[-1] [-2] -/[-1] 100
    -repeat $3 --==[-1] {$>/100} -*[-1] [-3] -+[-2,-1] -b[-2] {$1/($3+1)} -done
  -rm[-2] -nm $nm,1 -endl -done -v +

#@gmic blur_x : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the x-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_x 6
blur_x : -skip ${2=1}
  -e[^-1] "Blur image$? along the x-axis, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,x,$2 -v +

#@gmic blur_xy : amplitude_x[%],amplitude_y[%],_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the X and Y axes.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_xy 6
blur_xy : -skip ${2=$1},${3=1}
  -e[^-1] "Blur image$? along the xy-axes, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,x,$3 -deriche $2,0,y,$3 -v +

#@gmic blur_xyz : amplitude_x[%],amplitude_y[%],amplitude_z,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the X, Y and Z axes.
#@gmic : Default value: 'boundary=1'.
blur_xyz : -skip ${4=1}
  -e[^-1] "Blur image$? along the xyz-axes, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,x,$4 -deriche $2,0,y,$4 -deriche $3,0,z,$4 -v +

#@gmic blur_y : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the y-axis.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --blur_y 6
blur_y : -skip ${2=1}
  -e[^-1] "Blur image$? along the y-axis, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,y,$2 -v +

#@gmic blur_z : amplitude[%]>=0,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Blur selected images along the z-axis.
#@gmic : Default value: 'boundary=1'.
blur_z : -skip ${2=1}
  -e[^-1] "Blur image$? along the z-axis, with sigma $1 and "@{-arg\ 1+!$2,neumann,dirichlet}" boundary conditions."
  -v - -deriche $1,0,z,$2 -v +

#@gmic bokeh : _amplitude>=0,_smoothness>=0,0<=_density<=100,_bokeh_size>0,0<=_bokeh_outline_size<=100,_bokeh_outline_amplitude>=0,_bokeh_smoothness>=0
#@gmic : Create a Bokeh effect from selected images.
#@gmic : Default values: 'amplitude=200', 'smoothness=2', 'density=0.2', 'bokeh_size=24', 'bokeh_outline_size=10', 'bokeh_outline_amplitude=1' and 'bokeh_smoothness=0.1'.
#@gmic : $ image.jpg --bokeh ,
bokeh : -check "${1=200}>=0 && ${2=2}>=0 && ${3=0.2}>=0 && $3<=100 && ${4=24}>0 && ${5=10}>=0 && $5<=100 && ${6=2}>=0 && ${7=1}>=0 && ${8=0.1}>=0"
  -e[^-1] "Apply bokeh effect to image$?, with amplitude $1, smoothness $2, density $3%, bokeh size $4, bokeh outline size $5 "\
          "bokeh outline amplitude $6 and bokeh smoothness $7."
  -v -

  # Create bokeh kernel.
  256,256 -=[-1] 1,50%,50% -distance[-1] 1
  --lt[-1] 70% -t2[-2] 70%,{70-$5*70/100}% -*[-2] $6 -+[-2,-1] -r[-1] $4,$4,1,1,2
  -expand_xy[-1] {3*$7},0 -b[-1] $7,0 --gt[-1] 0.1 -*[-2,-1] -autocrop[-1]
  -normalize_sum[-1]

  # Apply bokeh effect.
  -repeat {@#-1} -l[$>,-1]
    --remove_pixels[0] {100-$3} -convolve[-1] [-2],0 -n[-1] 0,$1
    -b[0] $2 -+[0,-1] -c[0] 0,255
  -endl -done -rm[-1]
  -v +

#@gmic compose_freq
#@gmic : Compose selected low and high frequency parts into new images.
#@gmic : $ image.jpg -split_freq 2% -mirror[-1] x -compose_freq
compose_freq :
  -e[^-1] "Compose low and high frequency part$? into new images."
  -v - -repeat {int(@#/2)} -+[$>,{$>+1}] -done -v +

#@gmic convolve : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Convolve selected images by specified mask.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg (0,1,0;1,-4,1;0,1,0) -convolve[-2] [-1] -keep[-2]
#@gmic : $ image.jpg (0,1,0) -resize[-1] 130,1,1,1,3 --convolve[0] [1]

#@gmic convolve_fft
#@gmic : Convolve selected images two-by-two through fourier transforms.
#@gmic : $ image.jpg 100%,100% -gaussian[-1] 20,1,45 --convolve_fft
convolve_fft :
  -e[^-1] "Convolve image$? two-by-two through fourier transforms."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    w2={int(@{0,w}/2)} h2={int(@{0,h}/2)} d2={int(@{0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
    -fft[0] -fft[2]
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft -rm[-1]
  -endl -done -v +

#@gmic correlate : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Correlate selected images by specified mask.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg (0,1,0;1,-4,1;0,1,0) -correlate[-2] [-1] -keep[-2]
#@gmic : $ image.jpg --crop 40%,40%,60%,60% --correlate[0] [-1],0,1

#@gmic cross_correlation
#@gmic : Compute cross-correlation using two-by-two selected images.
#@gmic : $ image.jpg --shift -30,-20 -cross_correlation
cross_correlation :
  -e[^-1] "Compute cross-correlation using two-by-two image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    -norm -fft[-2] -fft[-1] [-2,-1] -*[-2] [-5] -*[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] -ifft -rm[-1]
  -endl -done -v +

#@gmic curvature
#@gmic : Compute isophote curvatures on selected images.
#@gmic : $ image.jpg -blur 10 -curvature
curvature :
  -e[^-1] "Compute isophote curvatures on image$?."
  -v - -repeat @# -l[$>]
    -if {d==1}
      --g xy,0 -hessian[-3] xxxyyy                            # ixx ixy iyy ix iy
      -*[-3] [-2] -*[-4] [-1] -*[-4] -2                       # ixx -2iyixy ixiyy ix iy
      -+[-4,-3] -*[-3] [-2]                                   # ixx -2ixiyixy+ix^2iyy ix iy
      -sqr[-2,-1] -*[-4] [-1] -+[-4,-3]                       # iy^2ixx-2ixiyixy+ix^2iyy ix^2 iy^2
      -+[-2,-1] -+[-1] 0.1 -^[-1] 1.5 -/                      # (iy^2ixx+2ixiyixy+ix^2iyy)/(ix^2+iy^2)
    -else
      --inn --gradient_norm[-2] -laplacian[-3]                # inn+iee inn in
      --[-3,-2] -+[-1] 0.1 -/[-2,-1]                          # iee in
      --inn[-1] -laplacian[-2] --                             # iee/in
    -endif
  -endl -done -v +

#@gmic deblur : amplitude[%]>=0,_nb_iter>=0,_dt>=0,_regul>=0,_regul_type={ 0=Tikhonov | 1=meancurv. | 2=TV }
#@gmic : Deblur image using a regularized Jansson-Van Cittert algorithm.
#@gmic : Default values: 'nb_iter=10', 'dt=20', 'regul=0.7' and 'regul_type=1'.
#@gmic : $ image.jpg -blur 3 --deblur 3,40,20,0.01
deblur : -check "${2=10}>=0 && ${3=20}>=0 && ${4=0.7}>=0" -skip ${5=1}
  -e[^-1] "Deblur image$? with a regularized Jansson-Van Cittert algorithm, with sigma $1, $2 iterations, time step $3 and regularization $4."
  -v - -repeat @# -l[$>] nm=@{0,n}
    [0]
    -repeat $2
      -if {$5>=2} --curvature[-1]                         # TV regularization.
      -elif {$5>=1} --iee[-1]                             # Meancurv. regularization.
      -else --laplacian[-1]                               # Tikhonov regularization.
      -endif
      -*[-1] $4
      --b[-2] $1 --[-1] [-4]                              # Data fidelity term.
      --[-2,-1]
      -*[-1] {$3/(0.0001+max(abs(@{-1,m}),abs(@{-1,M})))} # Adaptive time step.
      -+[-2,-1]                                           # Update image.
    -done
    -rm[-2]
  -nm $nm,1 -endl -done -v +

#@gmic deblur_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur selected images using Gold-Meinel algorithm
#@gmic : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_goldmeinel[-1] 1
###### : (contribution from Jérôme Boulanger).
deblur_goldmeinel : -check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1}
  -e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "@{-arg\ 1+!$4,"",quasi-}"gaussian kernel."
  -v - -repeat @# -l[$>]
    [0] -repeat $2
      --b[-1] $1,1,$4 --/[0,-1] -rm[-2] -^[-1] $3 -*[-1,-2] # u *= f / Hu
    -done -rm[0]
  -endl -done -v +

#@gmic deblur_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }.
#@gmic : Deblur selected images using Richardson-Lucy algorithm.
#@gmic : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@gmic : $ image.jpg --blur 1 --deblur_richardsonlucy[-1] 1
###### : (contribution from Jérôme Boulanger).
deblur_richardsonlucy : -check "$1>=0 && ${2=50}>=0" -skip ${3=1}
  -e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "@{-arg\ 1+!$3,"",quasi-}"gaussian kernel."
  -v - -repeat @# -l[$>]
    [0] -repeat $2
      --b[-1] $1,1,{$3!=0} --/[0,-1] -rm[-2] -b[-1] $1,1,{$3!=0} -*[-1,-2] # u *= H ( f / Hu )
    -done -rm[0]
  -endl -done -v +

#@gmic deconvolve_fft
#@gmic : Deconvolve selected images two-by-two through fourier transforms.
deconvolve_fft :
  -e[^-1] "Deconvolve image$? two-by-two through fourier transforms."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    w2={int(@{0,w}/2)} h2={int(@{0,h}/2)} d2={int(@{0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5 -shift[1] -$w2,-$h2,-$d2,0,2
    -fft[0] -fft[1]                            # a b a' b'
    --sqr[-2] --sqr[-2] -+[-2,-1] -+[-1] 1e-5  # a b a' b' (a'^2+b'^2)
    --*[-4] [-3]                               # a b a' b' (a'^2+b'^2) ba'
    --*[-6] [-3]                               # a b a' b' (a'^2+b'^2) ba' ab'
    --[-2,-1]                                  # a b a' b' (a'^2+b'^2) ba'-ab'
    -*[-6,-4]                                  # aa' b b' (a'^2+b'^2) ba'-ab'
    -*[-4,-3]                                  # aa' bb' (a'^2+b'^2) ba'-ab'
    -+[-4,-3]                                  # aa'+bb' (a'^2+b'^2) ba'-ab'
    -/[-1] [-2] -/[-3,-2]                      # divide (aa'+bb') and (ba'-ab') by (a'^2+b'^2)
    -ifft -rm[-1]
  -endl -done -v +

#@gmic deinterlace : _method={ 0 | 1 }
#@gmic : Deinterlace selected images ('method' can be { 0=standard or 1=motion-compensated }).
#@gmic : Default value: 'method=0'.
#@gmic : $ image.jpg --rotate 3,1,1,50%,50% -resize 100%,50% -resize 100%,200%,1,3,4 -shift[-1] 0,1 -add --deinterlace 1
deinterlace : -skip ${1=0}
  -e[^-1] "Deinterlace image$? with "@{-arg\ 1+!$1,motion-compensated,standard}" method."
  -v - -repeat @# -l[$>]
    wh={w},{h}
    -s y -a[0--1:2] y -a[^0] y -r[-2] [-1],0 -r 100%,200%,1,100%,5
    -if {$1!=0} --displacement[-1] [-2],0.05 -warp[-3] [-1],1,1,1 -rm[-1] -endif
    -+ -/ 2 -c 0,255 -r $wh
  -endl -done -v +

#@gmic denoise : std_variation_s>=0,_std_variation_p>=0,_patch_size>=0,_lookup_size>=0,_smoothness,_fast_approx={ 0 | 1 } : (+)
#@gmic : Denoise selected images by non-local patch averaging.
#@gmic : Default values: 'std_variation_p=10', 'patch_size=5', 'lookup_size=6' and 'smoothness=1'.
#@gmic : $ image.jpg --denoise 5,5,8

#@gmic denoise_haar : _threshold>=0,_nb_scales>=0,_cycle_spinning>0
#@gmic : Denoise selected image using haar-wavelet thresholding with cycle spinning.
#@gmic : Set 'nb_scales==0' to automatically determine the optimal number of scales.
#@gmic : Default values: 'threshold=1.4', 'nb_scale=0' and 'cycle_spinning=10'.
#@gmic : $ image.jpg -noise 20 -c 0,255 --denoise_haar[-1] 0.8
denoise_haar : -check "${1=1.4}>=0 && isint(${2=0}) && $2>=0 && isint(${3=10}) && $3>0"
  -e[^-1] "Denoise image$? using haar-wavelet thresholding, with threshold $1, "\
          @{-arg\ 1+($2>0),auto,$2}" scales and $3 spinning cycles."
  -v - -repeat @# -l[$>] nm=@{0,n}
    nb_scales={min(if($2,$2,32),int(log2(min(w,h))-1))}
    w={w} h={h} d={d} sigma=@{-variance_noise}
    -r {round(w,2^($nb_scales+1),1)},{round(h,2^($nb_scales+1),1)},{if(d==1,1,round(d,2^($nb_scales+1),1))},100%,0,0
    --f 0
    -repeat $3
      dx={round(?(0,{4*$nb_scales}))}
      dy={round(?(0,{4*$nb_scales}))}
      dz={if($d==1,0,round(?(0,{4*$nb_scales})))}
      --shift[0] $dx,$dy,$dz,0,2
      -haar[-1] $nb_scales
      -threshold[-1] {$1*$sigma},1
      -ihaar[-1] $nb_scales
      -shift[-1] {-$dx},{-$dy},{-$dz},0,2
      -+[-2,-1]
    -done
    -rm[0] -/ $3 -r $w,$h,$d,100%,0
  -nm $nm,1 -endl -done -v +

#@gmic deriche : std_variation>=0[%],order={ 0 | 1 | 2 },axis={ x | y | z | c },_boundary : (+)
#@gmic : Apply Deriche recursive filter with specified standard deviation, order, axis and border
#@gmic : conditions on selected images.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --deriche 3,1,x
#@gmic : $ image.jpg --deriche 30,0,x -deriche[-2] 30,0,y -add

#@gmic dilate : size>=0 : size_x>=0,size_y>=0,size_z>=0 : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Dilate selected images by a rectangular or the specified structuring element.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_z=1', 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate 10

#@gmic dilate_circ : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply circular dilation of selected image by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate_circ 7
dilate_circ : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply circular dilation of image$? by size $1, boundary $2 and is_normalized $3."
  -if {$1<2} -return -endif
  -v - -_dt_circle[] $1 -dilate[^-1] [-1],$2,$3 -rm[-1] -v +

#@gmic dilate_oct : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply octagonal dilation of selected image by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --dilate_oct 7
dilate_oct : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply octagonal dilation of image$? by size $1, boundary $2 and is_normalized $3."
  -v -
  -if {$1<2} -return -endif
  -if {$1&1} ss={$1} -else ss={$1+1} -endif
  -i[0] (0,1,0;1,1,1;0,1,0) -i[1] (1,1,1;1,1,1;1,1,1)
  -repeat {@#-2}
    r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
    q={round(($ss-1)/(1+sqrt(2))/2)}
    -if {$r>0} -repeat $r -dilate[-1] [0],$2,$3 -done -endif
    -if {$q>0} -repeat $q -dilate[-1] [1],$2,$3 -done -endif
  -mv[-1] 2 -done -rm[0,1] -v +

_kr_circle :
  -if {$1%2==0} -i 2,2,1,1,1 -else -i 1,1,1,1,1 -endif -r[-1] $1,$1,1,1,0,0,0.5,0.5
  -distance[-1] 1 -round[-1] 0.5 -t2[-1] 0,{$1/2}

_jf_circle :
  {round($1)},{round($1)}
  center={0.5*(w-1)}
  -f[-1] 'sqrt((x-$center)^2+(y-$center)^2)'
  -if {!(w%2)}
    -round[-1] 0.0001,-1
    t1={sqrt(((round($1)-1)/2)^2+0.25)}
    t2={sqrt(((round($1)+1)/2)^2+0.25)}
    k={$1-round($1)+0.5}
    t={$t1+($t2-$t1)*$k}
    -t2[-1] 0,$t
  -else -t2[-1] 0,{$1/2-0.25}
  -endif

_dt_circle :
 ir={round($1)}
 -if {!$ir} 1,1
 -elif {$ir<2} $ir,$ir,1,1,1
 -else
   {int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} -=[-1] 1,100%,100%
   -distance[-1] 1 -le[-1] {(i+0.4)/sqrt(2)}
   --mirror[-1] x
   -if {$ir>1&&($ir%2)} -r[-1] {w-1},100%,1,1,0,0,1 -endif
   -a[-2,-1] x --mirror[-1] y
   -if {$ir>1&&($ir%2)} -r[-1] 100%,{h-1},1,1,0,0,0,1 -endif
   -a[-2,-1] y
 -endif

_dt_diamond :
 ir={round($1)}
 -if {$ir<2} $ir,$ir,1,1,1
 -else
   {int($ir/2)+($ir%2)},{int($ir/2)+($ir%2)} -=[-1] 1,100%,100%
   -distance[-1] 1,1 -le[-1] {i/2}
   --mirror[-1] x
   -if {$ir>1&&($ir%2)} -r[-1] {w-1},100%,1,1,0,0,1 -endif
   -a[-2,-1] x --mirror[-1] y
   -if {$ir>1&&($ir%2)} -r[-1] 100%,{h-1},1,1,0,0,0,1 -endif
   -a[-2,-1] y
 -endif

#@gmic divergence
#@gmic : Compute divergence of selected vector fields.
#@gmic : $ image.jpg -luminance --gradient -append[-2,-1] c -divergence[-1]
divergence :
  -e[^-1] "Compute divergence of vector field$?."
  -v - -repeat @# -l[$>]
    -if {s==1} -g x,0
    -elif {s==2} -s c -g[-2] x,0 -g[-1] y,0 -+
    -elif {s==3} -s c -g[-3] x,0 -g[-2] y,0 -g[-1] z,0 -+
    -else -error[] "Cannot compute divergence of image ["$>"] (has "{s}">3 channels)."
    -endif
  -endl -done -v +

#@gmic dog : _sigma1>=0[%],_sigma2>=0[%]
#@gmic : Compute difference of gaussian on selected images.
#@gmic : Default values: 'sigma1=2%' and 'sigma2=3%'.
#@gmic : $ image.jpg --dog 2,3
dog : -check "${1=2%}>=0 && ${2=3%}>=0"
  -e[^-1] "Compute difference of gaussian on image$?, with standard deviations $1 and $2."
  -v - -repeat @# -l[$>]
    [0] -parallel "-b[0] $1","-b[1] $2" -- -norm
  -endl -done -v +

#@gmic diffusiontensors : _sharpness>=0,0<=_anisotropy<=1,_alpha[%],_sigma[%],is_sqrt={ 0 | 1 }
#@gmic : Compute the diffusion tensors of selected images for edge-preserving smoothing algorithms.
#@gmic : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1' and 'is_sqrt=0'.
#@gmic : $ image.jpg -diffusiontensors 0.8 -abs -pow 0.2
diffusiontensors : -check "${1=0.7}>=0 && ${2=0.3}>=0 && $2<=1" -skip ${3=0.6},${4=1.1},${5=0}
  -e[^-1] "Compute diffusion tensors for image$?, with sharpness $1, anisotropy $2, alpha $3 and sigma $4."
  -v -
  p1={if($5,0.5,1)*max($1,1e-5)}
  p2={$p1/(1e-7+1-$2)}
  -b $3 -n 0,255 -structuretensors 2 -b $4
  -repeat @# -l[$>]
    -eigen -max[-2] 0
    -if {s==2} -s[-2] c -+[-3,-2] -+[-2] 1 --^[-2] -$p1 -^[-3] -$p2 -a[-3,-1] c                     # 2d
    -else -s[-2] c -+[-4--2] -+[-2] 1 --^[-2] -$p1 -r[-1] 100%,100%,100%,2 -^[-3] -$p2 -a[-3,-1] c  # 3d
    -endif
    -eigen2tensor
  -endl -done -v +

#@gmic edges : _threshold[%]>=0
#@gmic : Estimate contours of selected images.
#@gmic : Default value: 'edges=15%'
#@gmic : $ image.jpg --edges 15%
edges : -skip ${1=15%}
  -e[^-1] "Estimate image contours of image$?, with threshold $1."
  -v - -gradient_norm -b 0.5 -ge $1 -distance 0 -equalize -negative -c 30%,70% -n 0,1 -v +

#@gmic erode : size>=0 : size_x>=0,size_y>=0,_size_z>=0 : [mask],_boundary,_is_normalized={ 0 | 1 } : (+)
#@gmic : Erode selected images by a rectangular or the specified structuring element.
#@gmic : boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default values: 'size_z=1', 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode 10

#@gmic erode_circ : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply circular erosion of selected images by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode_circ 7
erode_circ : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply circular erosion of image$? by size $1, boundary $2 and is_normalized $3."
  -if {$1<2} -return -endif
  -v - -_dt_circle[] $1 -erode[^-1] [-1],$2,$3 -rm[-1] -v +

#@gmic erode_oct : _size>=0,_boundary,_is_normalized={ 0 | 1 }
#@gmic : Apply octagonal erosion of selected images by specified size.
#@gmic : Default values: 'boundary=1' and 'is_normalized=0'.
#@gmic : $ image.jpg --erode_oct 7
erode_oct : -check $1>=0 -skip ${2=1},${3=0}
  -e[^-1] "Apply octagonal erosion of image$? by size $1, boundary $2 and is_normalized $3."
  -v -
  -if {$1<2} -return -endif
  -if {$1&1} ss={$1} -else ss={$1+1} -endif
  -i[0] (0,1,0;1,1,1;0,1,0) -i[1] (1,1,1;1,1,1;1,1,1)
  -repeat {@#-2}
    r={round(($ss-1)*sqrt(2)/(1+sqrt(2))/2)}
    q={round(($ss-1)/(1+sqrt(2))/2)}
    -if {$r>0} -repeat $r -erode[-1] [0],$2,$3 -done -endif
    -if {$q>0} -repeat $q -erode[-1] [1],$2,$3 -done -endif
  -mv[-1] 2 -done -rm[0,1] -v +

#@gmic fft : (+)
#@gmic : Compute the direct fourier transform (real and imaginary parts) of selected images.
#@gmic : $ image.jpg -luminance --fft -append[-2,-1] c -norm[-1] -log[-1] -shift[-1] 50%,50%,0,0,2
#@gmic : $ image.jpg -fft -shift 50%,50%,0,0,2 -ellipse 50%,50%,30,30,0,1,0 -shift -50%,-50%,0,0,2 -ifft -remove[-1]

#@gmic g : eq. to '-gradient'. : (+)

#@gmic gradient : { x | y | z }..{ x | y | z },_scheme : (no args) : (+)
#@gmic : Compute the gradient components (first derivatives) of selected images.
#@gmic : (eq. to '-g').
#@gmic : 'scheme' can be { -1=backward | 0=centered | 1=forward | 2=sobel | 3=rotation-invariant (default) | 4=deriche | 5=vanvliet }.
#@gmic : (no args) compute all significant 2d/3d components.
#@gmic : Default value: 'scheme=3'.
#@gmic : $ image.jpg -gradient

#@gmic gradient_orientation : _dimension={1,2,3}
#@gmic : Compute N-d gradient orientation of selected images.
#@gmic : Default value: 'dimension=3'.
#@gmic : $ image.jpg --gradient_orientation 2
gradient_orientation : -check "${1=3}==1 || $1==2 || $1==3"
  -e[^-1] "Compute $1-d gradient orientation of image$?."
  -v - -repeat @# -l[$<]
    -if {$1==1} -g x --abs[-1] -+[-1] 1e-8 -/
    -elif {$1==2} -g xy --sqr -+[-2,-1] -+[-1] 1e-8 -sqrt[-1] -/[-3] [-1] -/[-2,-1]
    -else -g xyz --sqr -+[-3--1] -+[-1] 1e-8 -sqrt[-1] -/[-4,-3] [-1] -/[-2,-1]
    -endif
  -endl -done -v +

#@gmic gradient_norm
#@gmic : Compute gradient norm of selected images.
#@gmic : $ image.jpg --gradient_norm -equalize[-1]
gradient_norm :
  -e[^-1] "Compute gradient norm of image$?."
  -v - -repeat @# -l[$>]
    --g x -sqr[-1]
    --g[-2] y -sqr[-1] -+[-2,-1]
    -g[-2] z -sqr[-2] -+[-2,-1]
    s={s} -s[-1] c -+[-$s--1] -sqrt[-1]
  -endl -done -v +

#@gmic haar : scale>0
#@gmic : Compute the direct haar multiscale wavelet transform of selected images.
haar : -check "isint(${1=1}) && $1>=0"
  -e[^-1] "Compute haar transform of image$? with $1 scales."
  -v - -repeat @# -l[$>]
    -_haar
    -repeat {$1-1}
      w={max(0,round(w/2^(1+$>))-1)}
      h={max(0,round(h/2^(1+$>))-1)}
      d={max(0,round(d/2^(1+$>))-1)}
      --z 0,0,0,$w,$h,$d -_haar[-1] -j[-2] [-1] -rm[-1]
    -done
  -endl -done -v +

_haar : # Mono-scale direct haar transform.
  -_haar_x -_haar_y -_haar_z

_haar_x : # Direct haar transform along the x-axis.
  -if {w<=1} -return -endif
  -if {w%2} -error[0--6] "Invalid image width="{w}" (is not even)." -endif
  --shift -1 -r 50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a x

_haar_y : # Direct haar transform along the y-axis.
  -if {h<=1} -return -endif
  -if {h%2} -error[0--6] "Invalid image height="{h}" (is not even)." -endif
  --shift 0,-1 -r 100%,50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a y

_haar_z : # Direct haar transform along the z-axis.
  -if {d<=1} -return -endif
  -if {d%2} -error[0--6] "Invalid image depth="{h}" (is not even)." -endif
  --shift 0,0,-1 -r 100%,100%,50% ---[1] [0] -+[0,1] -/ {sqrt(2)} -a z

#@gmic heat_flow : _nb_iter>=0,_dt,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of the heat flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --heat_flow 20
heat_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the heat flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,laplacian,$3 -v +

#@gmic hessian : { xx | xy | xz | yy | yz | zz }..{ xx | xy | xz | yy | yz | zz } : (no args) : (+)
#@gmic : Compute the hessian components (second derivatives) of selected images.
#@gmic : (no args) compute all significant components.
#@gmic : $ image.jpg -hessian

#@gmic iee
#@gmic : Compute gradient-orthogonal-directed 2nd derivative of image(s).
#@gmic : $ image.jpg -iee
iee :
  -e[^-1] "Compute gradient-orthogonal-directed 2nd derivative of image$?."
  -v - -repeat @# -l[$>]
    -if {d==1}
      --g xy,0 -hessian[-3] xxxyyy         # ixx ixy iyy ix iy
      -*[-3] [-2] -*[-4] [-1] -*[-4] -2    # ixx -2iyixy ixiyy ix iy
      -+[-4,-3] -*[-3] [-2]                # ixx -2ixiyixy+ix^2iyy ix iy
      -sqr[-2,-1] -*[-4] [-1] -+[-4,-3]    # iy^2ixx-2ixiyixy+ix^2iyy ix^2 iy^2
      -+[-2,-1] -+[-1] 1e-8 -/             # (iy^2ixx+2ixiyixy+ix^2iyy)/(ix^2+iy^2)
    -else
      --inn -laplacian[-2] --
    -endif
  -endl -done -v +

#@gmic ifft : (+)
#@gmic : Compute the inverse fourier transform (real and imaginary parts) of selected images.

#@gmic ihaar : scale>0
#@gmic : Compute the inverse haar multiscale wavelet transform of selected images.
ihaar : -check "isint(${1=1}) && $1>=0"
  -e[^-1] "Compute inverse haar transform of image$? with $1 scales."
  -v - -repeat @# -l[$>]
    -repeat {$1-1}
      w={max(0,round(w/2^(1+$<))-1)}
      h={max(0,round(h/2^(1+$<))-1)}
      d={max(0,round(d/2^(1+$<))-1)}
      --z 0,0,0,$w,$h,$d -_ihaar[-1] -j[-2] [-1] -rm[-1]
    -done
    -_ihaar
  -endl -done -v +

_ihaar : # Mono-scale inverse haar transform.
  -_ihaar_x -_ihaar_y -_ihaar_z

_ihaar_x : # Inverse haar transform along the x-axis.
  -if {w<=1} -return -endif
  -if {w%2} -error[0--6] "Invalid image width="{w}" (is not even)." -endif
  -s x,2 -r 200% (-1,1) -*[-2,-1] -+ -/ {sqrt(2)}

_ihaar_y : # Inverse haar transform along the y-axis.
  -if {h<=1} -return -endif
  -if {h%2} -error "Invalid image height="{h}" (is not even)." -endif
  -s y,2 -r 100%,200% (-1;1) -r[-1] @{-2,w} -*[-2,-1] -+ -/ {sqrt(2)}

_ihaar_z : # Inverse haar transform along the z-axis.
  -if {d<=1} -return -endif
  -if {d%2} -error "Invalid image depth="{h}" (is not even)." -endif
  -s z,2 -r 100%,100%,200% (-1/1) -r[-1] @{-2,w},@{-2,h} -*[-2,-1] -+ -/ {sqrt(2)}

#@gmic inn
#@gmic : Compute gradient-directed 2nd derivative of image(s).
#@gmic : $ image.jpg -inn
inn :
  -e[^-1] "Compute gradient-directed 2nd derivative of image$?."
  -v - -repeat @# -l[$>]
    -if {d==1}
      --g xy,0 -hessian[-3] xxxyyy         # ixx ixy iyy ix iy
      -*[-5] [-2] -*[-4] [-1] -*[-4] 2     # ixixx 2iyixy iyy ix iy
      -+[-5,-4] -*[-4] [-2]                # ix^2ixx+2ixiyixy iyy ix iy
      -sqr[-2,-1] -*[-3] [-1] -+[-4,-3]    # ix^2ixx+2ixiyixy+iy^2iyy ix^2 iy^2
      -+[-2,-1] -+[-1] 1e-8 -/             # (ix^2ixx+2ixiyixy+iy^2iyy)/(ix^2+iy^2)
    -else
      --g xyz,0 -hessian[-4] xxxyxzyyyzzz                     # ixx ixy ixz iyy iyz izz ix iy iz
      -*[-9] [-3] -*[-8] [-2] -*[-8] 2 -*[-7] [-1] -*[-7] 2   # ixixx 2iyixy 2izixz iyy iyz izz ix iy iz
      -+[-9--7] -*[-7] [-3]                                   # ix^2ixx+2ixiyixy+2ixizixy iyy iyz izz ix iy iz
      -*[-6] [-2] -*[-5] [-1] -*[-5] 2                        # ix^2ixx+2ixiyixy+2ixizixy iyiyy 2iziyz izz ix iy iz
      -+[-6,-5] -*[-5] [-2] -+[-6,-5]                         # ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz izz ix iy iz
      -sqr[-3--1] -*[-4] [-1] -+[-5,-4]                       # ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz+iz^2izz ix^2 iy^2 iz^2
      -+[-3--1] -+[-1] 1e-8 -/                                # (ix^2ixx+2ixiyixy+2ixizixy+iy^2iyy+2iyiziyz+iz^2izz)/(ix^2+iy^2+iz^2)
    -endif
  -endl -done -v +

#@gmic inpaint : [mask] : [mask],_patch_size>=1,_lookup_size>=1,_lookup_increment>=1,_blend_size>=0,0<=_blend_threshold<=1,_blend_decay>=0,_blend_scales>=1,_is_blend_outer={ 0 | 1 } : (+)
#@gmic : Inpaint selected images by specified mask.
#@gmic : If no patch size is specified, inpainting is done using a fast averaging-algorithm.
#@gmic : Otherwise, it used a patch-based reconstruction method, that can be very time consuming.
#@gmic : Default values : 'patch_size', 'lookup_size=22', 'lookup_increment=1', 'blend_size=0', 'blend_threshold=0', 'blend_decay=0.05', 'blend_scales=10' and 'is_blend_outer=0'.
#@gmic : $ image.jpg 100%,100% -ellipse 50%,50%,30,30,0,1,255 -ellipse 20%,20%,30,10,0,1,255 --inpaint[-2] [-1] -remove[-2]
#@gmic : $ image.jpg 100%,100% -circle 30%,30%,30,1,255,0,255 -circle 70%,70%,50,1,255,0,255 --inpaint[0] [1],17,24,2,30,0 -remove[1]

#@gmic inpaint_flow : _nb_iter1>=0,_nb_iter2>=0,_dt>=0,_alpha,_sigma
#@gmic : Apply iteration of the inpainting flow on selected images.
#@gmic : Default values: 'nb_iter1=4', 'nb_iter2=15', 'dt=15', 'alpha=1' and 'sigma=3'.
#@gmic : $ image.jpg 100%,100% -ellipse[-1] 30%,30%,40,30,0,1,255 -reverse -inpaint_flow ,
inpaint_flow : -skip ${1=4},${2=15},${3=15},${4=1},${5=3}
  -e[^-1] "Apply $1 iteration of the inpainting flow on image$?."
  -v - -norm[0] -quantize[0] 2,1,1 -n[0] 0,1
  -repeat @# -if $> -l[0,$>]
    -r[0] [1] -inpaint[1] [0]
    -repeat $1 --diffusiontensors[1] 0,1,$4,$5,0 -*[2] [0] -smooth[1] [2],$2,$3,0 -rm[2] -done
  -endl -endif -done -v +

#@gmic kuwahara : size>0
#@gmic : Apply Kuwahara filter of specified size on selected images.
#@gmic : $ image.jpg --kuwahara 5
kuwahara : -check $1>0
  -e[^-1] "Apply Kuwahara filter of size $1 on image$?."
  -v - -repeat @# -l[$>]
    s={s}
    --dilate $1 -compose_channels[-1] min
    --erode[0] $1 -compose_channels[-1] max
    --[-2,-1]
    $1,1,1,1,{1/$1} -convolve[0] [-1] -transpose[-1] -convolve[0] [-1] -rm[-1]
    p={int($1/2)}
    -a[-2,-1] c
    -f "v1=i(x-"$p",y-"$p",0,"$s",0,1); \
        v2=i(x+"$p",y-"$p",0,"$s",0,1); \
        v3=i(x-"$p",y+"$p",0,"$s",0,1); \
        v4=i(x+"$p",y+"$p",0,"$s",0,1); \
        vm=min(v1,v2,v3,v4); \
        if(c>="$s",i, \
          if(vm==v1,i(x-"$p",y-"$p",0,c,0,1),
            if(vm==v2,i(x+"$p",y-"$p",0,c,0,1),
              if(vm==v3,i(x-"$p",y+"$p",0,c,0,1),
                i(x+"$p",y+"$p",0,c,0,1)))))"
    -channels 0,{s-2}
  -endl -done -v +

#@gmic laplacian
#@gmic : Compute Laplacian of selected images.
#@gmic : $ image.jpg -laplacian
laplacian :
  -e[^-1] "Compute Laplacian of image $?."
  -v - -repeat @# -l[$>]
    -hessian @{-arg\ 1+(d==1),xxyyzz,xxyy} -+
  -endl -done -v +

#@gmic lic : _amplitude>0,_channels>0
#@gmic : Render LIC representation of selected vector fields.
#@gmic : Default values: 'amplitude=30' and 'channels=1'.
#@gmic : $ 400,400,1,2,'if(c==0,x-w/2,y-h/2)' --lic 200,3 -quiver[-2] [-2],10,-13,1,1,255
lic : -skip ${1=30},${2=1}
  -e[^-1] "Render LIC representation of 2d vector field$?, with amplitude $1 and $2 channel(s)."
  -v - -repeat @# -l[$>] nm=@{0,n}
     -channels 0,1 -/ {max(abs(@{-1,m}),abs(@{-1,M}))} -vector2tensor
     100%,100%,100%,$2 -rand[-1] 0,255 -smooth[-1] [-2],$1 -rm[-2]
     -equalize
  -nm $nm,1 -endl -done -v +

#@gmic map_tones : _threshold>=0,_gamma>=0,_smoothness>=0,nb_iter>=0
#@gmic : Apply tone mapping operator on selected images, based on Poisson equation.
#@gmic : Default values: 'threshold=0.1', 'gamma=0.8', 'smoothness=0.5' and 'nb_iter=30'.
#@gmic : $ image.jpg --map_tones ,
map_tones : -skip ${1=0.1},${2=0.8},${3=0.5},${4=30}
  -e[^-1] "Apply tone mapping operator on image$?, with threshold $1, gamma $2, smoothness $3 and $4 iterations."
  -v - -repeat @# -l[$>]

    # Estimate target divergence for each channel.
    --l -s c -repeat @# -l[$>]
      -g xy,1 -a c --norm -orientation[-2]
      m={im} M={iM} -b[-1] $3 -n[-1] $m,$M
      -*[-1] 'alpha=$1*iM;(alpha/(1e-10+i))*(i/(1e-10+alpha))^$2'
      -* -s c -g[-2] x,-1 -g[-1] y,-1 -+
    -endl -done -a c -* 0.25 -endl

   # Start Poisson-PDE iterations
    -repeat $4 --laplacian[-2] -*[-1] 0.25 -+[-1] [-3] --[-1] [-2] -*[-1] 800 -+[-3,-1] -/[-2] 801 -c[-2] 0,255 -done -rm[-1]

  -endl -done  -v +

#@gmic map_tones_fast : _radius[%]>=0,_power>=0
#@gmic : Apply fast tone mapping operator on selected images.
#@gmic : Default values: 'radius=3%' and 'power=0.3'.
#@gmic : $ image.jpg --map_tones_fast ,
map_tones_fast : -check "${1=3%}>=0 && ${2=0.3}>=0"
  -e[^-1] "Apply fast tone mapping operator on image$?, with radius $1 and power $2."
  -v - -repeat @# -l[$>]
    --luminance -b[-1] $1 -n 0,1
    --*[-1] 2 --[-1] 1 -abs[-1] -*[-1] {$2*log(10)} -exp[-1]
    -le[-2] 0.5 -r[-1] [-3]
    --*[-3] -1 -+[-1] 1 -^[-1] [-2] -*[-1] -1 -+[-1] 1 -*[-1] [-3]
    -^[-4,-2] -eq[-2] 0 -*[-3,-2] -+
  -endl -done -n 0,255 -v +

#@gmic meancurvature_flow : _nb_iter>=0,_dt,_sequence_flag={ 0 | 1 }
#@gmic : Apply iterations of the mean curvature flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --meancurvature_flow 20
meancurvature_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,iee,$3 -v +

#@gmic median : radius>=0 : (+)
#@gmic : Apply median filter of specified radius on selected images.
#@gmic : $ image.jpg --median 5

#@gmic normalize_local : _amplitude>=0,_radius>0,_n_smooth>=0[%],_a_smooth>=0[%],_is_cut={ 0 | 1 },_min=0,_max=255
#@gmic : Normalize selected images locally.
#@gmic : Default values: 'amplitude=3', 'radius=16', 'n_smooth=4%', 'a_smooth=2%', 'is_cut=1', 'min=0' and 'max=255'.
#@gmic : $ image.jpg --normalize_local 8,10
normalize_local :
  -check "${1=3}>=0 && ${2=16}>0 && isbool(${5=1})" -skip ${3=4%},${4=2%},${6=0},${7=255}
  -e[^-1] "Normalize image$? locally, with amplitude $1, radius $2, neighborhood smoothness $3 and average smoothness $4."
  -v - -repeat @# -l[$>]
    --l -erode {2*$2+1} -s c -min -endl
    --l[-2] -dilate {2*$2+1} -s c -max -endl
    --b[-3] $4 -b[-3,-2] $3
    ---[-2] [-3] -+[-1] 0.01 --[-5] [-4] -/[-5,-1]
    -*[-3,-2] {$1+1} -*[-1] -$1 -+[-3] [-1] -+[-2,-1]
    -if $5 -max[-2] $6 -min[-1] $7 -endif
    --[-1] [-2] -*[-3,-1] -+
    -if $5 -c $6,$7 -endif
  -endl -done -v +

#@gmic normalized_cross_correlation
#@gmic : Compute normalized cross-correlation using two-by-two selected images.
#@gmic : $ image.jpg --shift -30,-20 -normalized_cross_correlation
normalized_cross_correlation :
  -e[^-1] "Compute normalized cross-correlation using two-by-two image$?."
  -v - -norm -repeat {int(@#/2)} -l[$>,{$>+1}]
    -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] [-2,-1] -a[-2,-1] c -norm[-1]
    -/[-3] [-1] -/[-2,-1] -ifft -rm[-1]
  -endl -done -v +

#@gmic phase_correlation
#@gmic : Estimate translation vector using two-by-two selected images.
#@gmic : $ image.jpg --shift -30,-20 --phase_correlation -unroll[-1] y
phase_correlation :
  -e[^-1] "Estimate translation vector using two-by-two image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    -normalized_cross_correlation
    (@{-1,C}) -*[-1] 2 -s[-1] x -rm[-1]
    -if {@-3>@{-4,w}} --[-3] @{-4,w} --[-3] @{-4,w} -endif
    -if {@-2>@{-4,h}} --[-2] @{-4,h} --[-2] @{-4,h} -endif
    -if {@-1>@{-4,d}} --[-1] @{-4,d} --[-1] @{-4,d} -endif
    -a[-3--1] c -rm[-2] -/ 2 -* -1
    -nm [phase\ correlation]
  -endl -done -v +

#@gmic pde_flow : _nb_iter>=0,_dt,_velocity_command,_keep_sequence={ 0 | 1 }
#@gmic : Apply iterations of a generic PDE flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30', 'velocity_command=laplacian' and 'keep_sequence=0'.
#@gmic : $ image.jpg --pde_flow 20
pde_flow : -skip ${1=10},${2=30},${3=laplacian},${4=0}
  -e[^-1] "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
  -v - -repeat @# -l[$<]
    -repeat $1
      --$3[-1] -*[-1] {$2/(0.01+max(abs(im),abs(iM)))}
      -if $4 -+[-1] [-2] -else -+[-2,-1] -endif
    -done
    -if $4 -rm[0] -endif
    -a x
  -endl -done
  -if $4 -s x,$1 -endif -v +

#@gmic red_eye : 0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1
#@gmic : Attenuate red-eye effect in selected images.
#@gmic : Default values: 'threshold=75', 'smoothness=3.5' and 'attenuation=0.1'.
#@gmic : $ image.jpg --red_eye ,
red_eye : -skip ${1=75},${2=3.5},${3=0.1}
  -e[^-1] "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
  -v - -to_rgb -rgb2ycbcr -repeat @# -l[$>]
    -s c --[-1] 128 --ge[-1] $1% -b[-1] $2 -sqrt[-1] -*[-1] -1 -+[-1] 1
    -n[-1] $3,1 -*[-2,-1] -+[-1] 128 -a c -ycbcr2rgb
  -endl -done -v +

#@gmic remove_hotpixels : _mask_size>0, _threshold[%]>0
#@gmic : Remove hot pixels in selected images.
#@gmic : Default values: 'mask_size=3' and 'threshold=10%'.
#@gmic : $ image.jpg -noise 10,2 --remove_hotpixels ,
remove_hotpixels : -check ${1=3}>0 -skip ${2=10%}
  -e[^-1] "Remove hot pixels in image$?, with mask size $1 and threshold $2."
  -v - -repeat @# -l[$>]
    --median $1 --- -abs[-1] -ge[-1] $2
    -*[-2] [-1] -==[-1] 0 -*[-3,-1] -+
  -endl -done -v +

#@gmic remove_pixels : density>=0,_pixel_sum>=0
#@gmic : Remove (i.e. set to 0) specified density (in percent) of non-zero pixels to 0.
#@gmic : Specified density is regarded against 'pixel_sum' except if it is set to '0'
#@gmic : (in this case, 'pixel_sum' has default value 'width*height').
#@gmic : Default value: 'density=10', 'pixel_sum=0'.
#@gmic : $ image.jpg --remove_pixels 50
remove_pixels : -check "${1=10}>=0 && ${2=0}>=0"
  -e[^-1] "Remove $1% of non-zero pixels of image$?."
  -v - -repeat @# -l[$>]
    --norm -gt[-1] 0
    -if $2 rate={$1*$2/max(1e-8,@{-1,+})}
    -else rate={$1*w*h/max(1e-8,@{-1,+})}
    -endif
    -rm[-1]
    100%,100% -rand[-1] 0,1 -ge[-1] $rate% -*
  -endl -done -v +

#@gmic sharpen : amplitude>=0 : amplitude>=0,edge>=0,_alpha,_sigma : (+)
#@gmic : Sharpen selected images by inverse diffusion or shock filters methods.
#@gmic : 'edge' must be specified to enable shock-filter method.
#@gmic : Default values: 'alpha=0' and 'sigma=0'.
#@gmic : $ image.jpg --sharpen 300
#@gmic : $ image.jpg -blur 5 --sharpen[-1] 300,1

#@gmic smooth : amplitude>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dl>0,_da>0,_precision>0,interpolation,_fast_approx={ 0 | 1 } : nb_iterations>=0,_sharpness>=0,_anisotropy,_alpha,_sigma,_dt>0,0 : [tensor_field],_amplitude>=0,_dl>0,_da>0,_precision>0,_interpolation,_fast_approx={ 0 | 1 } : [tensor_field],_nb_iters>=0,_dt>0,0 : (+)
#@gmic : Smooth selected images anisotropically using diffusion PDE's, with specified field of
#@gmic : diffusion tensors.
#@gmic : 'anisotropy' must be in [0,1].
#@gmic : 'interpolation' can be { 0=nearest | 1=linear | 2=runge-kutta }.
#@gmic : Default values: 'sharpness=0.7', 'anisotropy=0.3', 'alpha=0.6', 'sigma=1.1', 'dl=0.8', 'da=30', 'precision=2', 'interpolation=0' and 'fast_approx=1'.
#@gmic : $ image.jpg [0] -repeat 3 -smooth[-1] 20 -done
#@gmic : $ image.jpg 100%,100%,1,2 -rand[-1] -100,100 -repeat 2 -smooth[-1] 100,0.2,1,4,4 -done --warp[0] [-1],1,1

#@gmic split_freq : smoothness>0[%]
#@gmic : Split selected images into low and high frequency parts.
#@gmic : $ image.jpg -split_freq 2%
split_freq :
  -e[^-1] "Split image$? into low and high frequency parts, with smoothness $1."
  -v - -repeat @# -l[$>] --b $1 --[0] [1] -rv -endl -done -v +

#@gmic solidify
#@gmic : Replace transparent regions of a RGBA image by morphologically interpolated color.
#@gmic : $ image.jpg --luminance -ge[-1] 120 -*[-1] 255 -append c --solidify -display_rgba
solidify :
  -e[^-1] "Replace transparent regions of RGBA image$? by morphologically interpolated colors."
  -v - -repeat @# -l[$>] nm=@{0,n} -to_a
    [-1] -split_opacity[-2] -ge[-2] 50% -*[-1] [-2]
    -replace_color[-1] 0,0,0,0,0,0,-1,-1,-1,-1 -to_rgb[-1]
    -do
      --dilate[-1] 3
      -replace_color[-2] 0,0,-1,-1,-1,1000,1000,1000
      -erode[-2] 3
      -replace_color[-2] 0,0,1000,1000,1000,-1,-1,-1
      -+[-2,-1] -/[-1] 2
      -j[-1] [-3],0,0,0,0,1,[-2]
    -while {im<0}
    -k[-1]
  -nm $nm,1 -endl -done -v +

#@gmic solidify_linear : _sigma>=1,_dsigma>=1,0<=_precision<=1
#@gmic : Replace transparent regions of a RGBA image by linearly interpolated color.
#@gmic : Default values: 'sigma=1.5', 'dsigma=1' and 'precision=0.5'.
#@gmic : $ image.jpg --luminance -ge[-1] 120 -*[-1] 255 -append c --solidify_linear , -display_rgba
solidify_linear : -check "${1=1.5}>=1 && ${2=1}>=1 && ${3=0.5}>=0 && $3<=1"
  -e[^-1] "Replace transparent regions of RGBA image$? by linearly interpolated colors, with sigma $1, dsigma $2 and precision $3."
  -v - -repeat @# -l[$>]
    -split_opacity
    -if {@#>1}
      -ge[-1] 50% -*[-2] [-1]
      sigma=$1 -do
        N={v=round(3*$sigma);min(33,max(3,v+1-(v%2)))}
        $N,$N -=[-1] 1,50%,50% -distance[-1] 1 -*[-1] {-1/$sigma^2} -exp[-1] -normalize_sum[-1]
        --convolve[-3,-2] [-1] -rm[-3]
        -max[-1] 1e-5 -/[-2,-1]
        --dilate[-2] {v=round((1/3-$N/6)*$3+$N/2);max(3,v+1-(v%2))}
        --[-3] [-1] -*[-2] [-3] -rm[-3]
        --[-3,-2]
        sigma={$sigma*$2}
      -while {!im}
     -rm[-1]
   -endif
 -endl -done -v +

#@gmic solidify_watershed
#@gmic : Replace transparent regions of RGBA image by color propagation.
#@gmic : $ image.jpg --luminance -ge[-1] 120 -*[-1] 255 -append c --solidify_watershed -display_rgba
solidify_watershed :
  -e[^-1] "Replace transparent regions of RGBA image$? by color propagation."
  -v - -repeat @# -l[$>]
    -split_opacity
    -if {@#>1}
      -+[0] 1 -ge[1] 50% -*[0] [1] -distance[1] 1 -*[1] -1
      -watershed[0] [1] -rm[1]
    -endif
  -endl -done -v +

#@gmic solve_poisson : "laplacian_command",_nb_iterations>=0,_time_step>0,_nb_scales>=0
#@gmic : Solve Poisson equation so that applying '-laplacian[n]' is close to the result of '-laplacian_command[n]'.
#@gmic : Solving is performed using a multi-scale gradient descent algorithm.
#@gmic : If 'nb_scales=0', the number of scales is automatically determined.
#@gmic : Default values: 'nb_iterations=60', 'dt=5' and 'nb_scales=0'.
#@gmic : $ image.jpg -m "foo : -gradient x" --solve_poisson foo --foo[0] --laplacian[1]
solve_poisson : -check "${2=60}>=0 && ${3=5}>0 && ${4=0}>=0"
  -e[^-1] "Solve Poisson equation for image$?, for laplacian command '$1', with $2 iterations, time step $3 and "@{-arg\ 1+($4==0),$4,auto}" scales."
  -v - -repeat @# -l[$>]
    [0]
    -repeat {if($4,$4,int(max(log2(max(w,h))-1,1)))}
      f={2^$<}
      -r[1] @{0,max(1,w/$f)},@{0,max(1,h/$f)},1,100%,3
      --r[0] [1],2 -l[-1] -$1 -k[0] -endl
      -repeat $2 --laplacian[-2] --[-1] [-2] -*[-1] {$3/max(1e-8,abs(im),abs(iM))} -+[-3,-1] -done
      -rm[-1]
    -done
    -rm[0]
  -endl -done -v +

#@gmic split_details : _nb_scales>0,_base_scale[%]>=0,_detail_scale[%]>=0
#@gmic : Split selected images into 'nb_scales' spatial scales (gaussian pyramids).
#@gmic : Default values: 'nb_scales=4', 'base_scale=2%' and 'detail_scale=0.5%'.
#@gmic : $ image.jpg -split_details ,
split_details : -check "isint(${1=4}) && $1>0 && ${2=2%}>=0 && ${3=0.5%}>=0"
  -e[^-1] "Split image$? using $1 spatial scales with base scale $2 and detail scale $3."
  -v - -repeat @# -l[$<]
    ss={max(0.3,if(@{-is_percent\ $2},$2*max(w,h),$2))}
    se={max(0.3,if(@{-is_percent\ $3},$3*max(w,h),$3))}
    ds={$se-$ss}
    -repeat {$1-1} --b[-1] {$ss+$>*$ds/($1-2)} --[-2] [-1] -rv[-2,-1] -done
  -endl -done -v +

#@gmic structuretensors : _scheme : (+)
#@gmic : Compute the structure tensor field of selected images.
#@gmic : 'scheme' can be { 0=centered | 1=forward-backward1 | 2=forward-backward2 }.
#@gmic : Default value: 'scheme=2'.
#@gmic : $ image.jpg -structuretensors -abs -pow 0.2

#@gmic tv_flow : _nb_iter>=0,_dt,_sequence_flag={ 0 | 1 }
#@gmic : Apply iterations of the total variation flow on selected images.
#@gmic : Default values: 'nb_iter=10', 'dt=30' and 'keep_sequence=0'.
#@gmic : $ image.jpg --tv_flow 40
tv_flow : -skip ${1=10},${2=30},${3=0}
  -e[^-1] "Apply $1 iterations of the total variation flow on image$?, with time step $2."
  -v - -pde_flow $1,$2,curvature,$3 -v +

#@gmic unsharp : radius[%]>=0,_amount>=0,_threshold[%]>=0
#@gmic : Apply unsharp mask on selected images.
#@gmic : Default values: 'amount=2' and 'threshold=0'.
#@gmic : $ image.jpg -blur 3 --unsharp 1.5,15 -cut 0,255
unsharp : -check "${2=2}>=0" -skip ${3=0}
  -e[^-1] "Apply unsharp mask on image$?, with radius $1, amount $2 and threshold $3."
  -v - -repeat @#
    --b[$>] $1 --[-1] [$>]
    -if $3 --norm[-1] -ge[-1] $3 -*[-2,-1] -endif
    -*[-1] $2 --[$>,-1]
  -done -v +

#@gmic unsharp_octave : _nb_scales>0,_radius[%]>=0,_amount>=0,threshold[%]>=0
#@gmic : Apply octave sharpening on selected images.
#@gmic : Default values: 'nb_scales=4', 'radius=1', 'amount=2' and 'threshold=0'.
#@gmic : $ image.jpg -blur 3 --unsharp_octave 4,5,15 -cut 0,255
unsharp_octave : -check "${1=4}>0 && ${3=2}>=0" -skip ${2=1},${4=0}
  -e[^-1] "Apply octave sharpening on image$?, with $1 scales, radius $2, amount $3 and threshold $4."
  -v - -repeat @# -l[$>] nm=@{0,n}
    --f 0 weight=0 -repeat $1
      --unsharp[0] {$2*2^-@{<,-1}},$3,$4 -*[-1] {2^-$>} weight={$weight+2^-$>} -+[1,-1]
    -done -rm[0] -/ $weight
  -nm $nm,1 -endl -done -v +

#@gmic vanvliet : std_variation>=0[%],order={ 0 | 1 | 2 | 3 },axis={ x | y | z | c },_boundary : (+)
#@gmic : Apply Vanvliet recursive filter with specified standard deviation, order, axis and border
#@gmic : conditions on selected images.
#@gmic : 'boundary' can be { 0=dirichlet | 1=neumann }.
#@gmic : Default value: 'boundary=1'.
#@gmic : $ image.jpg --vanvliet 3,1,x
#@gmic : $ image.jpg --vanvliet 30,0,x -vanvliet[-2] 30,0,y -add

#@gmic watermark_fourier : text,_size>0
#@gmic : Add a textual watermark in the frequency domain of selected images.
#@gmic : Default value: 'size=32'.
#@gmic : $ image.jpg --watermark_fourier "Watermarked!" --display_fft -remove[-3,-1] -normalize 0,255 -append[-4,-2] y -append[-2,-1] y
watermark_fourier : -check ${2=32}>0
  -e[^-1] "Add textual watermark '$1' with size $2 in the frequency domain of image$?."
  -v - -i[0] 0 -t[0] "$1",0,0,$2,1,1 -ge[0] 0.5 -autocrop[0] 0
  -repeat {@#-1} w2={int(w/2)} h2={int(h/2)}
    -fft[-1]
    -shift[-2,-1] $w2,$h2,0,0,2
    [0],[0],1,{s}
    -j[-3,-2] [-1],3,3,0,0,1,[0]
    -mirror[0] x
    -j[-3,-2] [-1],{@{-2,w}-2-@{0,w}},3,0,0,1,[0]
    -mirror[0] y
    -j[-3,-2] [-1],{@{-2,w}-2-@{0,w}},{@{-2,h}-2-@{0,h}},0,0,1,[0]
    -mirror[0] x
    -j[-3,-2] [-1],3,{@{-2,h}-2-@{0,h}},0,0,1,[0]
    -mirror[0] y
    -rm[-1]
    -shift[-2,-1] -$w2,-$h2,0,0,2
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 1 -done
  -rm[0] -v +

#@gmic watershed : [priority_image],_fill_lines={ 0 | 1 } : (+)
#@gmic : Compute the watershed transform of selected images.
#@gmic : Default value: 'fill_lines=1'.
#@gmic : $ 400,400 -noise 0.2,2 --distance 1 -mul[-1] -1 -label[-2] -watershed[-2] [-1] -mod[-2] 256 -map[-2] 0 -reverse

#---------------------------------
#
#@gmic :: Features extraction
#
#---------------------------------

#@gmic area : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Compute area of connected components in selected images.
#@gmic : Default values: 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -stencil[-1] 1 --area 0
area : -check "$1>=0" -skip ${2=0}
  -e[^-1] "Compute area of connected components in image$?, with tolerance $1 and "@{-arg\ 1+!$2,high,low}" connectivity."
  -v - -repeat @# -l[$>] -s c
    -repeat @# -label[$>] $1,$2 nb=@{$>,1+iM} --histogram[$>] $nb,0,{$nb-1} -map[$>] [-1] -rm[-1] -done
  -a c -endl -done -v +

#@gmic area_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Compute area of connected components for non-zero values in selected images.
#@gmic : Similar to '-area' except that 0-valued pixels are not considered.
#@gmic : Default values: 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -stencil[-1] 1 --area_fg 0
area_fg : -check "$1>=0" -skip ${2=0}
  -e[^-1] "Compute area of foreground connected components in image$?, with tolerance $1 and "@{-arg\ 1+!$2,high,low}" connectivity."
  -v - -repeat @# -l[$>] -s c
    -repeat @# -label_fg[$>] $1,$2 nb=@{$>,1+iM} --histogram[$>] $nb,0,{$nb-1} -=[-1] 0 -map[$>] [-1] -rm[-1] -done
  -a c -endl -done -v +

#@gmic at_line : x0[%],y0[%],z0[%],x1[%],y1[%],z1[%]
#@gmic : Retrieve pixels of the selected images belonging to the specified line (x0,y0,z0)-(x1,y1,z1).
#@gmic : $ image.jpg --at_line 0,0,0,100%,100%,0
at_line : -check ${7=100%}>=0
  -e[^-1] "Retrieve pixels of image$?, belonging to line ($1,$2,$3)-($4,$5,$6)."
  -v - -repeat @# -l[$>]
    x0={if(@{-is_percent\ $1},(w-1)*$1,$1)}
    y0={if(@{-is_percent\ $2},(h-1)*$2,$2)}
    z0={if(@{-is_percent\ $3},(d-1)*$3,$3)}
    x1={if(@{-is_percent\ $4},(w-1)*$4,$4)}
    y1={if(@{-is_percent\ $5},(h-1)*$5,$5)}
    z1={if(@{-is_percent\ $6},(d-1)*$6,$6)}
    ($x0,$x1^$y0,$y1^$z0,$z1)
    -r[-1] {1+max(abs($x1-$x0),abs($y1-$y0),abs($z1-$z0))},1,1,3,3
    -round[-1] 1 -warp[0] [-1],0,0,0 -rm[-1]
  -endl -done -v +

#@gmic barycenter
#@gmic : Compute the barycenter vector of pixel values.
#@gmic : $ 256,256 -ellipse 50%,50%,20%,20%,0,1,1 -deform 20 --barycenter --ellipse[-2] @{-1,0,1},5,5,0,10
barycenter :
  -e[^-1] "Compute the barycenter vector of pixel values of image$?."
  -v - -norm -repeat @# -l[$>] nm=@{0,b}
    sum=@{-1,+}
    -if {$sum>0}
      -if {d>1} --* 'z' z=@{-1,+} -rm[-1] -else z=0 -endif
      -if {h>1} --* 'y' y=@{-1,+} -rm[-1] -else y=0 -endif
      -* 'x' x=@{-1,+} -rm[-1]
      ({$x/$sum};{$y/$sum};{$z/$sum})
    -else ({w/2},{h/2},{d/2}) -rm[-2]
    -endif
  -nm "[barycenter of '"$nm"']" -endl -done -v +

#@gmic detect_skin : 0<=tolerance<=1,_skin_x,_skin_y,_skin_radius>=0
#@gmic : Detect skin in selected color images and output an appartenance probability map.
#@gmic : Detection is performed using CbCr chromaticity data of skin pixels.
#@gmic : If arguments 'skin_x', 'skin_y' and 'skin_radius' are provided, skin pixels are learnt
#@gmic : from the sample pixels inside the circle located at ('skin_x','skin_y') with radius 'skin_radius'.
#@gmic : Default value: 'tolerance=0.5' and 'skin_x=skiny=radius=-1'.
detect_skin : -check "${1=0.5}>=0 && $1<=1" -skip ${2=-1},${3=-1},${4=-1}
  -if {$2<0||$3<=0||$4<=0}
    -e[0--3] "Detect skin in image$?, using tolerance $1."
    -v -
    m0=120.9292108800069
    m1=142.5745272918084
    A=0.09749985486268997
    B=0.06388871371746063
    C=0.05250053107738495
    -to_rgb -srgb2rgb -rgb2ycbcr -channels 1,2
    -repeat @# -l[$>]
      whd={w},{h},{d} -r {w*h*d},2,1,1,-1
      -s y --[0] $m0 --[1] $m1 -a y
      -i[0] ($A,$B;$B,$C) --** -rm[0]
      -* -s y -+ -*[-1] {$1-1} -exp[-1]
      -r $whd,1,-1
    -endl -done
  -else
    -e[0--3] "Detect skin in image$?, using tolerance $1 and target circle at ($2,$3) with radius $4."
    -v -
    -to_rgb -srgb2rgb -rgb2ycbcr -channels 1,2
    -repeat @# -l[$>]
      100%,100% -circle[1] $2,$3,$4,1,1 --f[1] 'if(i,y,-1)' -f[1] 'if(i,x,-1)' -discard[1,2] -1 -a[1,2] c
      --warp[0] [1],0,0 -rm[1]
      -s[1] c
      m0=@{1,ia} --[1] $m0
      m1=@{2,ia} --[2] $m1
      M={h} -a[1,2] x --transpose[1] -rv[1,2] -**[1,2] -/[1] $M -invert[1]
      -rv whd={w},{h},{d} -r[1] {w*h*d},2,1,1,-1
      -s[1] y --[1] $m0 --[2] $m1 -a[1,2] y --** -rm[0]
      -* -s y -+ -*[-1] {$1-1} -exp[-1]
      -r $whd,1,-1
    -endl -done
  -endif
  -v +

#@gmic displacement : [source_image],_smoothness,_precision>=0,_nb_scales>=0,iteration_max>=0,is_backward={ 0 | 1 } : (+)
#@gmic : Estimate displacement field between specified source and selected images.
#@gmic : If 'smoothness>=0', regularization type is set to isotropic, else to anisotropic.
#@gmic : If 'nbscales==0', the number of needed scales is estimated from the image size.
#@gmic : Default values: 'smoothness=0.1', 'precision=5', 'nb_scales=0', 'iteration_max=10000' and 'is_backward=1'.
#@gmic : $ image.jpg --rotate 3,1,0,50%,50%,0.9 --displacement[-1] [-2] -quiver[-1] [-1],15,-20,1,1,{1.5*iM}

#@gmic distance : isovalue[%],_metric : isovalue[%],[metric],_method : (+)
#@gmic : Compute the unsigned distance function to specified isovalue, opt. according to a custom metric.
#@gmic : 'metric' can be { 0=chebyshev | 1=manhattan | 2=euclidean | 3=squared-euclidean }.
#@gmic : 'method' can be { 0=fast-marching | 1=low-connectivity dijkstra | 2=high-connectivity dijkstra | 3=1+return path | 4=2+return path }.
#@gmic : Default value: 'metric=2' and 'method=0'.
#@gmic : $ image.jpg -threshold 20% -distance 0 -pow 0.3
#@gmic : $ 400,400 -set 1,50%,50% --distance[0] 1,2 --distance[0] 1,1 -distance[0] 1,0 -mod 32 -threshold 16 -append c

#@gmic float2fft8
#@gmic : Convert selected float-valued images to 8bits fourier representations.
float2fft8 :
  -e[^-1] "Convert float-valued image$? to 8bits fourier representations."
  -v - -repeat @# -l[$>]
    -fftpolar -+[-2] 1 -log[-2] -float2int8[-2,-1] -a y
  -endl -done -v +

#@gmic fft82float
#@gmic : Convert selected 8bits fourier representations to float-valued images.
fft82float :
  -e[^-1] "Convert float-valued image$? to 8bits fourier representations."
  -v - -repeat @# -l[$>]
    -s y,2 -int82float -exp[-2] --[-2] 1 -ifftpolar
  -endl -done -v +

#@gmic fftpolar
#@gmic : Compute fourier transform of selected images, as centered magnitude/phase images.
#@gmic : $ image.jpg -fftpolar -ellipse 50%,50%,10,10,0,1,0 -ifftpolar
fftpolar :
  -e[^-1] "Compute fourier transform of image$?, as centered magnitude/phase images."
  -v - -repeat @# -l[$<]
    -fft -complex2polar -shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
  -endl -done -v +

#@gmic histogram : _nb_levels>0[%],_value0[%],_value1[%] : (+)
#@gmic : Compute the histogram of selected images.
#@gmic : If value range is set, the histogram is estimated only for pixels in the specified
#@gmic : value range. Argument 'value1' must be specified if 'value0' is set.
#@gmic : Default values: 'nb_levels=256', 'value0=0%' and 'value1=100%'.
#@gmic : $ image.jpg --histogram 64 -display_graph[-1] 400,300,3

#@gmic histogram3 : nb_levels>0[%],_value0[%],_value1[%]
#@gmic : Compute the 1d,2d or 3d histogram of selected multi-channels images (having 1,2 or 3 channels).
#@gmic : If value range is set, the histogram is estimated only for pixels in the specified
#@gmic : value range.
#@gmic : Default values: 'value0=0%' and 'value1=100%'.
histogram3 : -check $1>0 -skip ${2=0%},${3=100%}
  -e[^-1] "Compute histogram of multi-channels image$?, using $1 levels in range [$1,$2]."
  -v - -repeat @# -l[$>]
    -r {w*h*d},{min(3,s)},1,1,-1 -round[-1] 1
    vmin={if(@{-is_percent\ $2},$2*im,$2)} vmax={if(@{-is_percent\ $3},$3*iM,$3)}
    -- $vmin -* {($1-1)/($vmax-$vmin)}
    nb_levels={if(@{-is_percent\ $1},$1*($vmax-$vmin)+1,$1)}
    -pointcloud 1,$nb_levels,$nb_levels,$nb_levels
  -endl -done -v +

#@gmic histogram_cumul : _nb_levels>0,_is_normalized={ 0 | 1 },_val0[%],_val1[%]
#@gmic : Compute cumulative histogram of selected images.
#@gmic : Default values: 'nb_levels=256', 'is_normalized=0' and 'val0=val1=0'.
#@gmic : $ image.jpg --histogram_cumul 256 -histogram[0] 256 -display_graph 400,300,3
histogram_cumul : -check ${1=256}>0 -skip ${2=0} -skip ${3=0},${4=0}
  -arg 1+!$2,"normalized ",""
  -e[^-1] "Compute "@{}"cumulative histogram of image$?, using $1 levels."
  -v - -histogram $1,$3,$4 -cumul -if $2 -repeat @# -/[$>] @{$>,M} -done -endif -v +

#@gmic histogram_pointwise : nb_levels>0[%],_value0[%],_value1[%]
#@gmic : Compute the histogram of each vector-valued point of selected images.
#@gmic : If value range is set, the histogram is estimated only for values in the specified
#@gmic : value range.
#@gmic : Default values: 'value0=0%' and 'value1=100%'.
histogram_pointwise : -skip ${2=0%},${3=100%}
  -e[^-1] "Compute the pointwise histogram of vector-valued points in image$?, with $1 levels."
  -v - -repeat @# -l[$>] nm=@{0,n}
    nb_levels={round(if(@{-is_percent\ $1},(iM-im)*$1,$1))}
    value0={if(@{-is_percent\ $2},im+(iM-im)*$2,$2)}
    value1={if(@{-is_percent\ $3},im+(iM-im)*$3,$3)}
    -- $value0 -* {$nb_levels/max(1,abs($value1-$value0))} -c 0,{$nb_levels-1} -round
    w={w} h={h} d={d} -r {w*h*d},{s},1,1,-1
    -i[-2] (0,{w-1}) -r[-2] [-1],[-1],1,1,3 -round[-2]
    -r[-2,-1] 300%,100%,1,1,4 -shift[-1] 1 -+[-2,-1] -y[-1]
    -i[-2] ({'CImg3d'},{h/3},{h/3})
    (1,0;1,{h/3-1}) -r[-1] 2,@{-2,h/3},1,1,3 -round[-1]
    3,100%,1,1,1 1,100%,1,1,-1 -y[-5,-3,-2] -a[-5--1] y
    {$w*$h*$d},$nb_levels -object3d[-1] [-2],0,0,0,1,0,0,0 -rm[-2]
    -r $w,$h,$d,$nb_levels,-1
  -nm $nm,1 -endl -done -v +

#@gmic hough : _width>0,_height>0,gradient_norm_voting={ 0 | 1 }
#@gmic : Compute hough transform (theta,rho) of selected images.
#@gmic : Default values: 'width=512', 'height=width' and 'gradient_norm_voting=1'.
#@gmic : $ image.jpg --blur[-1] 1.5 -hough[-1] 400,400 -blur[-1] 0.5 -+[-1] 1 -log[-1]
hough : -check "${1=512}>0 && ${2=$1}>0" -skip ${3=1}
  -e[^-1] "Compute $1x$2 hough transform of image$?, "@{-arg\ 1+!$3,with,without}" gradient norm voting."
  -v - -slices 50% -luminance -repeat @# -l[$>] nm=@{0,n}
    rhomax={sqrt(w^2+h^2)/2}
    -g (0,{w-1}) (0;{@{-2,h}-1}) -r[-2,-1] @{-3,w},@{-3,h},1,1,3 --[-2] {w/2} --[-1] {h/2}
    -complex2polar[-4--1] --[-1] [-3] -polar2complex[-2,-1] -rm[-1]
    --lt[-1] 0 -*[-1] {pi} -+[-3,-1] -abs[-1] -%[-2] {2*pi}
    -*[-1] {$2/$rhomax} -*[-2] {0.5*$1/pi}
    -y[-3--1] x {w} -mv[-4] @# -if {!$3} -f[-1] 1 -endif
    -a y -pointcloud 1 -r $1,$2,1,1,0
  -nm $nm,1 -endl -done -v +

#@gmic ifftpolar
#@gmic : Compute inverse fourier transform of selected images, from centered magnitude/phase images.
ifftpolar :
  -e[^-1] "Compute inverse fourier transform of image$?, from centered magnitude/phase images."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    -shift {int(w/2)},{int(h/2)},{int(d/2)},0,2 -polar2complex -ifft -rm[-1]
  -endl -done -v +

#@gmic isophotes : _nb_levels>0
#@gmic : Render isophotes of selected images on a transparent background.
#@gmic : Default value: 'nb_levels=64'
#@gmic : $ image.jpg -blur 2 -isophotes 6 -dilate_circ 5 -display_rgba
isophotes : -skip ${1=64}
  -e[^-1] "Render isophote maps from images$?, with $1 levels."
  -v - -to_rgba -repeat @# -l[$>]
    --luminance -repeat $1 --isoline3d[1] {$>*255/($1-1)} -done -rm[1] -+3d[^0] -col3d[-1] 1
    [0],[0] -object3d[-1] [-2],0,0,0,1,0,0,0 -rm[-2] -*
  -endl -done -v +

#@gmic label : tolerance>=0,is_high_connectivity={ 0 | 1 } : (+)
#@gmic : Label connected components in selected images.
#@gmic : Default values: 'tolerance=0' and 'is_high_connectivity=0'.
#@gmic : $ image.jpg -luminance -threshold 60% -label -normalize 0,255 -map 0
#@gmic : $ 400,400 -set 1,50%,50% -distance 1 -mod 16 -threshold 8 -label -mod 255 -map 2

#@gmic label_fg : tolerance>=0,is_high_connectivity={ 0 | 1 }
#@gmic : Label connected components for non-zero values (foreground) in selected images.
#@gmic : Similar to '-label' except that 0-valued pixels are not labeled.
#@gmic : Default value: 'is_high_connectivity=0'.
label_fg : -check "$1>=0" -skip ${2=0}
  -e[^-1] "Label foreground connected components on image [1], with tolerance $1 and "@{-arg\ 1+!$2,high,low}" connectivity."
  -v - -repeat @# -l[$>]
    -if {d>1} --z -1,-1,-1,{w-1},{h-1},{d-1} -label[-1] $1,$2 -z[-1] 1,1,1,{w-1},{h-1},{d-1}
    -else --z -1,-1,{w-1},{h-1} -label[-1] $1,$2 -z[-1] 1,1,{w-1},{h-1}
    -endif
    -neq[-2] 0 -*
    --histogram {1+iM} -neq[-1] 0 -*[-1] 'x' -rows[-1] -1,0 -label[-1] -rows[-1] 1,1
    -map[-2] [-1] -rm[-1]
  -endl -done -v +

#@gmic max_patch : _patch_size>=1
#@gmic : Return locations of maximal values in local patch-based neighborhood of given size for selected images.
#@gmic : Default value: 'patch_size=16'.
#@gmic : $ image.jpg -norm --max_patch 16
max_patch : -check "isint(${1=16}) && $1>=1"
  -e[^-1] "Return locations of maximal values in local patch neighborhood of size $1, in image$?."
  -v - -repeat @# --dilate[$>] $1 -==[$>,-1] -done -v +

#@gmic min_patch : _patch_size>=1
#@gmic : Return locations of minimal values in local patch-based neighborhood of given size for selected images.
#@gmic : Default value: 'patch_size=16'.
#@gmic : $ image.jpg -norm --min_patch 16
min_patch : -check "isint(${1=16}) && $1>=1"
  -e[^-1] "Return locations of minimal values in local patch neighborhood of size $1, in image$?."
  -v - -repeat @# --erode[$>] $1 -==[$>,-1] -done -v +

#@gmic minimal_path : x0[%]>=0,y0[%]>=0,z0[%]>=0,x1[%]>=0,y1[%]>=0,z1[%]>=0,_is_high_connectivity={ 0 | 1 }
#@gmic : Compute minimal path between two points on selected potential maps.
#@gmic : Default value: 'is_high_connectivity=0'.
#@gmic : $ image.jpg --gradient_norm -fill[-1] 1/(1+i) -minimal_path[-1] 0,0,0,100%,100%,0 -pointcloud[-1] 0 -*[-1] 280 -to_rgb[-1] -resize[-1] [-2],0 -or
minimal_path : -check "$1>=0 && $2>=0 && $3>=0" -skip ${7=0}
  -e[^-1] "Compute minimal path between points ($1,$2,$3) and ($4,$5,$6) for potential map$?, with "@{-arg\ 1+$7,low,high}" connectivity."
  -v - -repeat @# -l[$>] nm=@{0,n}
    100%,100% -= 1,${4-6} -distance[-1] 1,[0],{if($7,4,3)} -k[-1]
    x={round(if(@{-is_percent\ $1},$1*(w-1),$1))}
    y={round(if(@{-is_percent\ $2},$2*(h-1),$2))}
    z={round(if(@{-is_percent\ $3},$3*(d-1),$3))}
    ($x;$y;$z)
    -do
      p=@{0,($x,$y,$z)}
      -if {$p&1} x={$x-1}
      -elif {$p&2} x={$x+1}
      -endif
      -if {$p&4} y={$y-1}
      -elif {$p&8} y={$y+1}
      -endif
      -if {$p&16} z={$z-1}
      -elif {$p&32} z={$z+1}
      -endif
      ($x;$y;$z)
    -while $p
    -rm[0,-1] -a x
  -nm $nm,1 -endl -done -v +

#@gmic mse : : (*)
#@gmic : Compute MSE (Mean-Squared Error) matrix between selected images.
#@gmic : $ image.jpg --noise 30 --noise[0] 35 --noise[0] 38 -cut[-1] 0,255 -mse

#@gmic patches : patch_width>0,patch_height>0,patch_depth>0,x0,y0,z0,_x1,_y1,_z1,...,_xN,_yN,_zN
#@gmic : Extract N+1 patches from selected images, centered at specified locations.
#@gmic : $ image.jpg --patches 64,64,1,153,124,0,184,240,0,217,126,0,275,38,0
patches : -check "isint($1) && $1>0 && isint($2) && $2>0 && isint($3) && $3>0"
  -e[^-1] "Extract $1x$2x$3 patches from image$?, at locations (${4--1})."
  -v -
  (${4--1}) -r[-1] 3,{w/3},1,1,-1 -permute[-1] yzcx N={w}
  H={int(sqrt(w))} W={round(w/$H,1,1)} -r[-1] {$W*$H},1,1,3,0 -r[-1] $W,$H,1,3,-1
  -r[-1] {w*$1},{h*$2},{d*$3}
  $1,$2,$3,1,x-{int($1/2)} --f[-1] y-{int($2/2)} --f[-1] z-{int($3/2)} -a[-3--1] c -r[-1] [-2],0,2 -+[-2,-1]
  -repeat {@#-1} -warp[$>] [-1],0,0,0 -done -rm[-1]
  -repeat @# -l[$<] -s y,$H -s x,$W -k[0-{$N-1}] -endl -done
  -v +

#@gmic plot2value
#@gmic : Retrieve values from selected 2d graph plots.
#@gmic : $ 400,300,1,1,'if(y>300*abs(cos(x/10+2*?)),1,0)' --plot2value --display_graph[-1] 400,300
plot2value :
  -e[^-1] "Retrieve values from 2d graph plot$?."
  -v - -repeat @# -l[$>]
    -s c -ge 50%
    -repeat @# -l[$>] (1,{w}) -r[1] [0],3 -* -histogram {w},1,{w} -endl -done
    -a c
  -endl -done -v +

#@gmic pointcloud : _type = { -X=-X-opacity | 0=binary | 1=cumulative | 2=label },_width,_height>0,_depth>0
#@gmic : Convert a Nx1, Nx2, Nx3 or NxM image as a point cloud in a 1d/2d or 3d binary image.
#@gmic : If 'M'>3, the 3-to-M lines sets the (M-3)-dimensional color at each point.
#@gmic : Parameters 'width','height' and 'depth' are related to the size of the final image :
#@gmic :   - If set to 0, the size is automatically set along the specified axis.
#@gmic :   - If set to N>0, the size along the specified axis is N.
#@gmic :   - If set to N<0, the size along the specified axis is at most N.
#@gmic : Points with coordinates that are negative or higher than specified ('width','height','depth')
#@gmic : are not plotted.
#@gmic : Default values: 'type=0' and 'max_width=max_height=max_depth=0'.
#@gmic : $ 3000,2 -rand 0,400 --pointcloud 0 -dilate[-1] 3
#@gmic : $ 3000,2 -rand 0,400 {w} {w},3 -rand[-1] 0,255 -append y --pointcloud 0 -dilate[-1] 3
pointcloud : -check "${1=0}<3" -skip ${2=0},${3=0},${4=0}
  -e[^-1] "Convert image$? to point clouds, in "@{-arg\ 2+($1>=0)*$1-($1<0),{-$1}-opacity,binary,cumulative,labeling}" mode,"\
          "with ($2,$3,$4) as maximal dimensions."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -if {"d>1 || s>1"} -error "Invalid input image "{w}x{h}x{d}x{s}". Should be NxMx1x1." -endif

    # Retrieve coordinates and color infos.
    -rows 0,{max(2,h-1)}
    -sh[-1] 0,0,0,0 -round[-1] dx={round(if($2==0,iM+1,if($2<0,min(iM+1,-$2),$2)))}
    -sh[-2] 1,1,0,0 -round[-1] dy={round(if($3==0,iM+1,if($3<0,min(iM+1,-$3),$3)))}
    -sh[-3] 2,2,0,0 -round[-1] dz={round(if($4==0,iM+1,if($4<0,min(iM+1,-$4),$4)))}
    -*[-1] $dy -+[-2] [-1] -f[-1] 0 -rm[-3--1]

    # Create corresponding 3d object (manage large point clouds).
    -s x,-1000000
    -repeat @# -l[$>]
      nbp={w}
      -if {h>3} --rows 3,100% -rows[-2] 0,2 -else 100%,1,1,1,1 -if {$1==2} -f[-1] 1+x -endif -endif
      spectrum={h} -i[-2] (-128;1;1;{h}) -r[-2] {w} -a[-2,-1] y
      -i[-3] ({'CImg3d'}) -transpose[-3--1] -i[-3] ($nbp;$nbp) # Header
      -i[-2] 1,$nbp,1,1,1 -i[-2] 1,$nbp,1,1,y -a[-3,-2] x      # Vertices and primitives.
      1,$nbp,1,1,{if($1<0,-$1,if($1==1,-1,1))}                 # Opacities.
      -y[-4--2] -a y                                           # Merge object attributes.
    -endl -done
    -+3d

    # Draw corresponding point cloud.
    $dx,{$dy*$dz},1,$spectrum -object3d[-1] [-2],0,0,0,1,0,0,0 -rm[-2] -r[-1] $dx,$dy,$dz,100%,-1
  -nm $nm,1 -endl -done -v +

#@gmic psnr : _max_value : (+)
#@gmic : Compute PSNR (Peak Signal-to-Noise Ratio) matrix between selected images.
#@gmic : Default value: 'max_value=255'.
#@gmic : $ image.jpg --noise 30 --noise[0] 35 --noise[0] 38 -cut[-1] 0,255 -psnr 255 -replace_inf 0
psnr : -skip ${1=255}
  -e[^-1] "Compute the "@#x@#" matrix of PSNR values, from image$? with maximum value $1."
  -v - -mse -log10 -- {log10($1*$1)} -* -10 -nm[-1] [PSNR] -v +

#@gmic segment_watershed : _threshold>=0,_fill_lines={ 0 | 1 }
#@gmic : Apply watershed segmentation on selected images.
#@gmic : Default values: 'threshold=2' and 'fill_lines=1'.
#@gmic : $ image.jpg --segment_watershed 2,0
segment_watershed : -check "${1=2}>=0" -skip ${2=1}
  -e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
  -v - -repeat @# -l[$>]
    -+ {1+@{-1,m}} --gradient_norm
    -if {d>1} --f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
    -else --f[-1] "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    -endif
    -*[-3,-1] -*[-1] -1 -watershed[-2] [-1],$2 -rm[-1]
  -endl -done -v +

#@gmic skeleton : _smoothness[%]>=0
#@gmic : Compute skeleton of binary shapes using distance transform.
#@gmic : Default value: 'smoothness=0'.
#@gmic : $ image.jpg -threshold 50% --skeleton 0
skeleton : -check ${1=0}>=0
  -e[^-1] "Compute skeleton of binary image$?."
  -v - -ge 50% -distance 0 -b $1 -sharpen 1e10 -ge 100%
  -repeat @# --erode[$>] 2 --[$>,-1] -done -v +

#@gmic ssd_patch : _use_fourier={ 0 | 1 },_boundary_conditions={ 0=dirichlet | 1=neumann }
#@gmic : Compute field of SSD between an image and a patch, taken as consecutive selected images.
#@gmic : Argument 'boundary_conditions' is valid only when 'use_fourier=0'.
#@gmic : Default value: 'use_fourier=0' and 'boundary_conditions=0'.
#@gmic : $ image.jpg --crop 20%,20%,35%,35% --ssd_patch 0,0
ssd_patch : -skip ${1=0},${2=0}
  -e[^-1] "Compute field of SSD between images and patchs using "@{-arg\ 1+!$1,fourier,spatial}" mode, in image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    -r 100%,100%,100%,@{-max_s} -s c
    -repeat {@#/2} -l[$>,{-1-$<}]
      --sqr[1] val=@{-1,+} -rm[-1]        # Sum J(p,q)^2
      --sqr[0] --f[1] 1
      -if $1
        -convolve_fft[-2,-1]               # Sum I(x+p,y+q)^2
        -mirror[1] xyz -convolve_fft[0,1]  # Sum I(x+p,y+q).J(p,q)
      -else
        -correlate[-2] [-1],$2 -rm[-1]    # Sum I(x+p,y+q)^2
        -correlate[0] [1],$2 -rm[1]       # Sum I(x+p,y+q).J(p,q)
      -endif
      -*[0] -2 -+[0,1] -+ $val
    -endl -done -+
  -endl -done -v +

#@gmic thinning
#@gmic : Compute skeleton of binary shapes using morphological thinning
#@gmic : (This is a quite slow iterative proces)
#@gmic : $ image.jpg -threshold 50% --thinning
thinning :
  -e[^-1] "Compute skeleton of binary image$?, using morphological thinning."
  -v - -ge 50% -* 2 -- 1
  (-1,-1,-1;0,1,0;1,1,1) (0,-1,-1;1,1,-1;0,1,0) --rotate[-2,-1] 90 --rotate[-2,-1] 90 --rotate[-2,-1] 90
  -repeat {@#-8}  # Start skeleton refinement.
    bavg=@{-9,+}
    -repeat 99999
      --correlate[-9] [-8] -ge[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-7] -ge[-1] 6 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-6] -ge[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-5] -ge[-1] 6 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-4] -ge[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-3] -ge[-1] 6 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-2] -ge[-1] 7 -*[-1] 2 --[-10,-1]
      --correlate[-9] [-1] -ge[-1] 6 -*[-1] 2 --[-10,-1]
      aavg=@{-9,+} -if {$aavg==$bavg} -break -endif bavg=$aavg
    -done
  -mv[-9] 0 -done -rm[-8--1] -+ 1 -/ 2 -v +

#@gmic tones : N>0
#@gmic : Get N tones masks from selected images.
#@gmic : $ image.jpg --tones 3
tones : -check $1>0
  -e[^-1] "Get $1 tones masks from image$?."
  -v - -norm -n 0,{$1-1} -round 1 -repeat @# -l[$<]
    -repeat {$1-1} --==[0] {1+$>} -done -==[0] 0
  -endl -done -v +

#@gmic topographic_map : _nb_levels>0,_smoothness
#@gmic : Render selected images as topographic maps.
#@gmic : Default values: 'nb_levels=16' and 'smoothness=2'.
#@gmic : $ image.jpg --topographic_map 10
topographic_map : -check "isint(${1=16}) && $1>0" -skip ${2=2}
  -e[^-1] "Render topographic maps from image$?, with $1 levels and smoothness $2."
  -v - -repeat @# -l[$>]
    --b $2 -isophotes[-1] $1 -compose_channels[-1] + -==[-1] 0 -blend shapeaverage0
  -endl -done -v +

#---------------------------------
#
#@gmic :: Image drawing
#
#---------------------------------

#@gmic axes : x0,x1,y0,y1,_font_height>=0,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw xy-axes on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : To draw only one x-axis at row Y, set both 'y0' and 'y1' to Y.
#@gmic : To draw only one y-axis at column X, set both 'x0' and 'x1' to X.
#@gmic : Default values: 'font_height=13', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ 400,400,1,3,255 -axes -1,1,1,-1

#@gmic ball : _size>0, _R,_G,_B,0<=_specular_light<=8,0<=_specular_size<=8,_shadow>=0
#@gmic : Input a 2d RGBA colored ball sprite.
#@gmic : Default values: 'size=64', 'R=255', 'G=R', 'B=R', 'specular_light=0.8', 'specular_size=1' and 'shading=1.5'.
#@gmic : $ -repeat 9 -ball {1.5^($>+2)},@{-RGB} -done -append x
ball : -check "${1=64}>0 && ${5=0.8}>=0 && $5<=8 && ${6=1}>=0 $6<=8 && ${7=1.5}>=0" -skip ${2=255},${3=$2},${4=$3}
  -e[^-1] "Input $1x$1 ball with color (${2-4}), specular light $5, specular size $6 and shadow factor $7."
  -v - -l[]
  {2*$1},{2*$1} -= 1,65%,30% -distance 1 -* -1
  --n 0,1 -pow[1] $7 -*[1] 1.4 --*[1] $3 --*[1] $4 -*[1] $2 -a[^0] c
  -ge[0] {100-10*$6}% -b[0] {3*$6}% -n[0] 0,{$5*255} -rv -+ -c 0,255
  100%,100% -circle[1] 50%,50%,34%,1,1 -*[0] [1] -*[-1] 255 -a c
  -r $1,$1,1,4,2
  -endl -v +

#@gmic chessboard : size1>0,_size2>0,_offset1,_offset2,_angle,_opacity,_color1,..,_color2,..
#@gmic : Draw chessboard on selected images.
#@gmic : Default values: 'size2=size1', 'offset1=offset2=0', 'angle=0', 'opacity=1', 'color1=0' and 'color2=255'.
#@gmic : $ image.jpg -chessboard 32,32,0,0,25,0.3,255,128,0,0,128,255
chessboard : -check "$1>0 && ${2=$1}>0" -skip ${3=0},${4=0},${5=0},${6=1},${7=0},${8=255}
  -e[^-1] "Draw chessboard on image$?, with sizes ($1,$2), offsets ($3,$4), angle $5 deg., opacity $6 and colors (${7--1})."
  -v - -i[0] (${7--1}) -r[0] {@{0,w}/2},1,1,2,-1 -permute[0] cyzx
  -repeat {@#-1}
    w={w} h={h} theta={$5*pi/180}
    ($3,{$3+$w-1};$3,{$3+$w-1}^$4,$4;{$4+$h-1},{$4+$h-1}) -r[-1] $w,$h,1,2,3
    -r[-1] {$w*$h},2,1,1,-1
    -i[-2] ({cos($theta)},{-sin($theta)};{sin($theta)},{cos($theta)}) -**[-2,-1]
    -r[-1] $w,$h,1,2,-1
    -%[-1] {$1+$2} ->=[-1] $1 -s[-1] c -xor[-2,-1] -map[-1] [0] -r[-1] 100%,100%,1,[-2]
    -j[-2] [-1],0,0,0,0,$6 -rm[-1]
  -mv[-1] 1 -done -rm[0] -v +

#@gmic cie1931
#@gmic : Draw CIE-1931 chromaticity diagram on selected images.
#@gmic : $ 500,400,1,3 -cie1931
cie1931 :
  -e[^-1] "Draw CIE-1931 chromaticity diagram on image$?."
  -v -

  # Generate convex hull of visible colors, as a 3d object.
  (67.5;73.5;109.5;103.5;51.5;100.5;37;36)  # Header
  (280,420,0;171,829,0;158,820,0;153,816,0;147,811,0;140,804,0;132,794,0;121,776,0;106,747,0;88,701,0;\  # Vertices.
  65,633,0;42,539,0;20,421,0;5,295,0;0,179,0;4,115,0;10,83,0;16,61,0;25,38,0;35,21,0;47,10,0;58,3,0;\
  71,0,0;92,1,0;111,7,0;151,28,0;189,52,0;226,79,0;262,109,0;298,141,0;334,175,0;370,209,0;405,244,0;\
  441,279,0;475,313,0;509,347,0;731,568,0)
  xM=731 yM=829
  2,{h-1},1,1,3,0 1,{h},1,1,'y' --+[-1] 1 -%[-1] {h} -+[-2,-1] 1 -a[-3--1] x  # Primitives.
  3,{h},1,1,160 1,{h},1,1,1  # Colors + opacities.
  -y[-4--2] -a[-5--1] y -mv[-1] 0

  # Generate RGB triangle of displayable colors.
  xR=636 yR=504 xG=297 yG=234 xB=147 yB=774
  512,512,1,3 -triangle_shade[-1] 0,0,{w-1},0,0,{h-1},""255,0,0,""0,255,0,""0,0,255 -rgb2srgb[-1]
  --compose_channels[-1] max -+[-1] 1e-8 -/[-2,-1] -*[-1] 255
  -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;3;1;$xR;$yR;-0.01;$xG;$yG;-0.01;$xB;$yB;-0.01;9;0;1;2;0;0;511;0;0;511;-128;512;512;3)
  -y[-1] (1) -a[-3--1] y -mv[-1] 1

  # Draw chroma diagram.
  -repeat {@#-2}
    -to_rgb[-1] -fc[-1] 255,255,255 -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,1,0
    100%,100%,1,3
    --*3d[0,1] {(w-8)/$xM},{(h-32)/$yM}
    -object3d[-3] [-1],2,30,0,1,2
    --neq[-3] 0 -distance[-1] 1 -*[-1] -1 -watershed[-4] [-1] -rm[-1] -/[-3] 1.5
    -object3d[-3] [-1],2,30,0,1,2
    -p3d[-1] 1 -p3d[-1] 2 -col3d[-1] 128 -object3d[-3] [-1],2,30,0,1,1 -rm[-1]
    @{-2,w},@{-2,h} -object3d[-1] [-2],2,30,0,1,2 -rm[-2]
    --erode[-1] 4 --[-1] [-2] -eq[-1] 0 -*[-3,-1]
    -a[-2,-1] c -blend[-2,-1] alpha
    100%,100%,1,1,255 -axes[-1] 0,0.75,0.85,0,13,1 --erode[-1] 3 -negative[-1] -to_rgb[-2]
    -j[-3] [-2],0,0,0,0,1,[-1],400 -rm[-2,-1]
  -mv[-1] 2 -done -rm[0,1] -v +

#@gmic circle : x[%],y[%],R[%],_opacity,_pattern,_color1,..
#@gmic : Draw specified colored circle on selected images.
#@gmic : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the circle is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 300 -circle {?(100)}%,{?(100)}%,{?(30)},0.3,@{-RGB} -done -circle 50%,50%,100,0.7,255
circle : -skip ${4=1},${5=0}
  -v - ({'"$5"'}) is_pattern={@{-1,0-1}'=='{'0x'}} -rm[-1] -v +
  -if $is_pattern
    -e[0--3] "Draw outlined circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${6--1})."
  -else
    -e[0--3] "Draw filled circle at ($1,$2) with radius $3 on image$?, with opacity $4 and color (${5--1})."
  -endif
  -v - -ellipse $1,$2,$3,$3,0,${4--1} -v +

#@gmic ellipse : x[%],y[%],R[%],r[%],_angle,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored ellipse on selected images.
#@gmic : A radius of '100%' stands for 'sqrt(width^2+height^2)'.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the ellipse is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 300 -ellipse {?(100)}%,{?(100)}%,{?(30)},{?(30)},{?(180)},0.3,@{-RGB} -done -ellipse 50%,50%,100,100,0,0.7,255

#@gmic flood : x[%],_y[%],_z[%],_tolerance>=0,_is_high_connectivity={ 0 | 1 },_opacity,_color1,.. : (+)
#@gmic : Flood-fill selected images using specified value and tolerance.
#@gmic : Default values: 'y=z=0', 'tolerance=0', 'is_high_connectivity=0', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 1000 -flood {?(100)}%,{?(100)}%,0,20,0,1,@{-RGB} -done

#@gmic gaussian : _sigma1[%],_sigma2[%],_angle
#@gmic : Draw a centered gaussian on selected images, with specified standard deviations and orientation.
#@gmic : Default values: 'sigma1=3', 'sigma2=sigma1' and 'angle=0'.
#@gmic : $ 400,400 -gaussian 100,30,45
gaussian : -skip ${1=3},${2=$1},${3=0}
  -e[^-1] "Draw centered gaussian on image$? with standard deviations ($1,$2) and angle $3 deg."
  -v -
  u={cos($3*pi/180)}
  v={sin($3*pi/180)}
  dmax={max(w,h)}
  -if {isval($1)} l1=$1 -else l1={${1}10000*$dmax/100} -endif
  -if {isval($2)} l2=$2 -else l2={${2}10000*$dmax/100} -endif
  l1={1/(2*max(1/3,$l1)^2)}
  l2={1/(2*max(1/3,$l2)^2)}
  A={$l1*$u*$u+$l2*$v*$v}
  B={($l1-$l2)*$u*$v}
  C={$l1*$v*$v+$l2*$u*$u}
  -repeat @# -l[$>] nm=@{0,n}
    w={w} h={h} ds={d},{s} -rm
    ({-$w/2},{$w/2}) -r $w,$h,1,1,3
    -f[-1] "Y=y-"{$h/2};$A"*i*i+2*"$B"*i*Y+"$C*"Y*Y"
    -* -1 -exp -r $w,$h,$ds
  -nm $nm,1 -endl -done -v +

#@gmic graph : [function_image],_plot_type,_vertex_type,_ymin,_ymax,_opacity,_pattern,_color1,.. : 'formula',_resolution>=0,_plot_type,_vertex_type,_xmin,xmax,_ymin,_ymax,_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified function graph on selected images.
#@gmic : 'plot_type' can be { 0=none | 1=lines | 2=splines | 3=bar }.
#@gmic : 'vertex_type' can be { 0=none | 1=points | 2,3=crosses | 4,5=circles | 6,7=squares }.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'plot_type=1', 'vertex_type=1', 'ymin=ymax=0 (auto)', 'opacity=1', 'pattern=(undefined)'
#@gmic : and 'color1=0'.
#@gmic : $ image.jpg --rows 50% -blur[-1] 3 -split[-1] c -div[0] 1.5 -graph[0] [1],2,0,0,0,1,255,0,0 -graph[0] [2],2,0,0,0,1,0,255,0 -graph[0] [3],2,0,0,0,1,0,0,255 -keep[0]

#@gmic grid : size_x[%]>=0,size_y[%]>=0,_offset_x[%],_offset_y[%],_opacity,_pattern,_color1,..
#@gmic : Draw xy-grid on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'offset_x=offset_y=0', 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -grid 10%,10%,0,0,0.5,255
#@gmic : $ 400,400,1,3,255 -grid 10%,10%,0,0,0.3,0xCCCCCCCC,128,32,16
grid : -check "$1>=0 && $2>=0" -skip ${3=0},${4=0},${5=1},${6=0}
  -v - ({'"$6"'}) is_pattern={@{-1,0-1}'=='{'0x'}} -rm[-1] -v +
  -if $is_pattern
    -e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, pattern $6 and color (${7--1})."
    -v - pattern=$6 color=${7--1}
  -else
    -e[0--3] "Draw xy-grid on image$?, with sizes ($1,$2), offsets ($3,$4), opacity $5, and color (${6--1})."
    -v - pattern=0xFFFFFFFF color=${6--1}
  -endif
  is_percentsx=@{-is_percent\ $1} is_percentsy=@{-is_percent\ $2}
  is_percentox=@{-is_percent\ $3} is_percentoy=@{-is_percent\ $4}

  -repeat @# -l[$>]
    w={w} h={h} s={s}

    # Draw grid along x-axis.
    size={if($is_percentsx,max(1,w*$1),$1)}
    -if {$size>=1}
      offset={if($is_percentox,$size*$3,$3)}
      ({'CImg3d'}) -+[-1] 0.5 # Header
      1,{1+int($w/$size)},1,1,'y' -*[-1] $size -+[-1] {$offset%$size} # Points
      1,{h},1,1,{$h/2} -a[-2,-1] x -z[-1] 0,2 n={h} -i[-2] ($n;$n)
      (1,0;1,{$n-1}) -r[-1] 2,$n,1,1,3 -round[-1] # Primitives
      (-128;1;$h;$s) 1,$h,1,$s -line[-1] 0,0,0,100%,1,$pattern,$color # Colors.
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      (-128;1;$h;1) 1,$h,1,1 -line[-1] 0,0,0,100%,1,$pattern,1 # Opacities.
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      -y[^0] -a[^0] y -object3d[0] [1],0,0,0,$5,0,0,0 -rm[1] # Merge and draw.
    -endif

    # Draw grid along y-axis.
    size={if($is_percentsy,max(1,h*$2),$2)}
    -if {$size>=1}
      offset={if($is_percentoy,$size*$4,$4)}
      ({'CImg3d'}) -+[-1] 0.5 # Header
      1,{1+int($h/$size)},1,1,'y' -*[-1] $size -+[-1] {$offset%$size} # Points.
      -i[-2] 1,{h},1,1,{$w/2} -a[-2,-1] x -z[-1] 0,2 n={h} -i[-2] ($n;$n)
      (1,0;1,{$n-1}) -r[-1] 2,$n,1,1,3 -round[-1] # Primitives.
      (-128;$w;1;$s) $w,1,1,$s -line[-1] 0,0,100%,0,1,$pattern,$color # Colors.
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      (-128;$w;1;1) $w,1,1,1 -line[-1] 0,0,100%,0,1,$pattern,1 # Opacities
      -if {$n>1} 1,{4*($n-1)},1,1,-128,0,0,0 -endif
      -y[^0] -a[^0] y -object3d[-2] [-1],0,0,0,$5,0,0,0 -rm[-1]  # Merge and draw.
    -endif

  -endl -done -v +

#@gmic j : eq. to '-image'. : (+)

#@gmic image : [sprite],_x[%],_y[%],_z[%],_c[%],_opacity,_[sprite_mask],_max_opacity_mask : (+)
#@gmic : Draw specified sprite image on selected images.
#@gmic : (eq. to '-j').
#@gmic : Default values: 'x=y=z=c=0', 'opacity=1', 'sprite_mask=(undefined)' and 'max_opacity_mask=1'.
#@gmic : $ image.jpg --crop 40%,40%,60%,60% -resize[-1] 200%,200%,1,3,5 -frame[-1] 2,2,0 -image[0] [-1],30%,30% -keep[0]

#@gmic line : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored line on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 500 -line 50%,50%,{?(w)},{?(h)},0.5,@{-RGB} -done -line 0,0,100%,100%,1,0xCCCCCCCC,255 -line 100%,0,0,100%,1,0xCCCCCCCC,255

#@gmic mandelbrot : z0r,z0i,z1r,z1i,_iteration_max>=0,_is_julia={ 0 | 1 },_c0r,_c0i,_opacity : (+)
#@gmic : Draw mandelbrot/julia fractal on selected images.
#@gmic : Default values: 'iteration_max=100', 'is_julia=0', 'c0r=c0i=0' and 'opacity=1'.
#@gmic : $ 400,400 -mandelbrot -2.5,-2,2,2,1024 -map 0 --blur 2 -elevation3d[-1] -0.2

#@gmic marble : _image_weight,_pattern_weight,_angle,_amplitude,_sharpness>=0,_anisotropy>=0,_alpha,_sigma,_cut_low>=0,_cut_high>=0
#@gmic : Render marble like pattern on selected images.
#@gmic : Default values: 'image_weight=0.2', 'pattern_weight=0.1', 'angle=45', 'amplitude=0', 'sharpness=0.4', 'anisotropy=0.8',
#@gmic : 'alpha=0.6', 'sigma=1.1' and 'cut_low=cut_high=0'.
#@gmic : $ image.jpg --marble ,
marble : -skip ${1=0.2},${2=0.1},${3=45},${4=0},${5=0.4},${6=0.8},${7=0.6},${8=1.1},${9=0%},${10=100%}
  -e[^-1] "Render marble like pattern on image$?, with image weight $1, pattern weight $2, angle $3 deg., amplitude $4, "\
          "sharpness $5, anisotropy $6, alpha $7, sigma $8, and cut ($9,$10)."
  -v - sx={$2*sin($3*pi/180)} sy={$2*cos($3*pi/180)} -f sin(x*$sx+y*$sy+i*$1)
  -if {$4} -smooth $4,$5,$6,$7,$8 -endif
  -c $9,$10 -n 0,255
  -v +

#@gmic maze : _width>0,_height>0,_cell_size>0
#@gmic : Input maze with specified size.
#@gmic : $ -maze 30,20 -negative -normalize 0,255
maze : -check "isint(${1=15}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=24}) && $3>0"
  -e[^-1] "Input $1x$2 maze."
  -v -
  ({round(?($1-1))},{round(?($2-1))})  # Starting cell.
  $1,$2,1,1,15 --f[-1] 0 -a[-2,-1] c   # Starting maze data.
  -_generate_maze $1,$2
  -_render_maze[-1] $3 -nm[-1] [maze]
  -v +

_generate_maze :

  # Start opening walls.
  -do
    x=@{-2,-2} y=@{-2,-1}  # Coords of the current cell.
    -=[-1] 1,$x,$y,0,1     # Mark current cell as visited.

    # Check for neighboring cells that are candidate for opening wall, and select one random.
    is_candidate=0
    up=-1 -if {i($x,$y)&8" && "$y>0" && "!i($x,$y-1,0,1)} up=$x,{$y-1},8 is_candidate=1 -endif          # Up.
    down=-1 -if {i($x,$y)&4" && "$y<$2-1" && "!i($x,$y+1,0,1)} down=$x,{$y+1},4 is_candidate=1 -endif   # Down.
    left=-1 -if {i($x,$y)&2" && "$x>0" && "!i($x-1,$y,0,1)} left={$x-1},$y,2 is_candidate=1 -endif      # Left.
    right=-1 -if {i($x,$y)&1" && "$x<$1-1" && "!i($x+1,$y,0,1)} right={$x+1},$y,1 is_candidate=1 -endif # Right.
    -if $is_candidate
      ($up,$down,$left,$right) -discard[-1] -1 -r[-1] 3,{h/3},1,1,-1 -shift[-1] 0,{?(4)},0,0,2 -rows[-1] 0,0 -mv[-1] -2
    -endif

    # Remove wall between the current and chosen neighboring cells.
    -if $is_candidate
      -if {@{-2,-1}==8}   -=[-1] {i($x,$y)&7},$x,$y -=[-1] {i($x,$y-1)&11},$x,{$y-1}   # Remove up wall.
      -elif {@{-2,-1}==4} -=[-1] {i($x,$y)&11},$x,$y -=[-1] {i($x,$y+1)&7},$x,{$y+1}   # Remove down wall.
      -elif {@{-2,-1}==2} -=[-1] {i($x,$y)&13},$x,$y -=[-1] {i($x-1,$y)&14},{$x-1},$y  # Remove left wall.
      -else               -=[-1] {i($x,$y)&14},$x,$y -=[-1] {i($x+1,$y)&13},{$x+1},$y  # Remove right wall.
      -endif
      -z[-2] 0,1 -a[-3,-2] y  # Add neighboring cell to stack of cells to explore.
    -else # No candidate : remove current cell from cells to explore.
      -if {@{-2,h}==1} -break -endif
      -rows[-2] 0,{@{-2,h}-2}
    -endif
  -while 1
  -rm[-2] -channels[-1] 0

_render_maze :
  # Create the 16 configurations of walls.
  -i[0] $1,$1 -i[1] [0]x15
  -line[8-15] 0,0,100%,0,1,1
  -line[4-7,12-15] 0,100%,100%,100%,1,1
  -line[2-3,6-7,10-11,14-15] 0,0,0,100%,1,1
  -line[1-15:2] 100%,0,100%,100%,1,1
  # Map the wall data with them.
  -a[0-15] x -r[-1] {w*$1},{h*$1} -*[-1] $1 -channels[-1] 0,1
  $1,$1,1,1,x $1,$1,1,1,y -a[-2,-1] c -r[-1] [-2],[-2],1,2,0,2 -+[-2,-1]
  -warp[-2] [-1],0,0,0 -rm[-1]

#@gmic maze_mask : _cellsize>0
#@gmic : Input maze according to size and shape of selected mask images.
#@gmic : Mask may contain disconnected shapes.
#@gmic : $ 0 -text "G'MIC",0,0,57,1,1 -dilate 3 -autocrop 0 -frame 1,1,0 -maze_mask 8 -dilate 3 -negative -* 255
maze_mask : -check "isint(${1=24}) && $1>0"
  -e[^-1] "Input masked maze from image$? with cell size $1."
  -v - -norm -ge 50% -repeat @# -l[$>]
    -do
      --rand[0] 0,1 -*[-1] [0] ({xM},{yM}) -rm[-2]  # Select one starting point in the mask.
      --flood[0] @-1,0,0,0,1,2 -ge[-1] 2 --negative[-1] -*[-2] 15 -a[-2,-1] c
      -flood[0] @-2,0,0,0,1,0
      -_generate_maze {w},{h}
    -while @{0,M}
    -rm[0] -+ -_render_maze[-1] $1 -nm[-1] [maze]
  -endl -done -v +

#@gmic object3d : [object3d],_x[%],_y[%],_z,_opacity,_rendering_mode,_is_double_sided={ 0 | 1 },_is_zbuffer={ 0 | 1 },_focale,_light_x,_light_y,_light_z,_specular_lightness,_specular_shininess : (+)
#@gmic : Draw specified 3d object on selected images.
#@gmic : 'rendering_mode' can be { 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@gmic : Default values: 'x=y=z=0', 'opacity=1' and 'is_zbuffer=1'. All other arguments take their default values from the 3d environment variables.
#@gmic : $ image.jpg -torus3d 100,10 -cone3d 30,-120 -add3d[-2,-1] -rotate3d[-1] 1,1,0,60 -object3d[0] [-1],50%,50% -keep[0]

#@gmic pack_sprites : _nb_scales>=0,0<=_min_scale<=100,_allow_rotation={ 0=0 deg. | 1=180 deg. | 2=90 deg. | 3=any },_spacing,_precision>=0,,max_iterations>=0
#@gmic : Try to randomly pack as many sprites as possible onto the 'empty' areas of an image.
#@gmic : Sprites can be eventually rotated and scaled during the packing process.
#@gmic : First selected image is the canvas that will be filled with the sprites.
#@gmic : Its last channel must be a binary mask whose zero values represent potential locations for drawing the sprites.
#@gmic : All other selected images represent the sprites considered for packing.
#@gmic : Their last channel must be a binary mask that represents the sprite shape (i.e. a 8-connected component).
#@gmic : The order of sprite packing follows the order of specified sprites in the image list.
#@gmic : Sprite packing is done on random locations and iteratively with decreasing scales.
#@gmic : 'nb_scales' sets the number of decreasing scales considered for all specified sprites to be packed.
#@gmic : 'min_scale' (in %) sets the minimal size considered for packing (specified as a percentage of the original sprite size).
#@gmic : 'spacing' can be positive or negative.
#@gmic : 'precision' tells about the desired number of failed trials before ending the filling process.
#@gmic : Default values: 'nb_scales=5', 'min_scale=25', 'allow_rotation=3', 'spacing=1', 'precision=7' and 'max_iterations=256'.
#@gmic : $ 512,512,1,3,"min(255,y*c/2)" 100%,100% -circle 50%,50%,100,1,255 -append c image.jpg -resize2dy[-1] 24 -to_rgba -pack_sprites 3,25
pack_sprites : -check "isint(${1=5}) && $1>=0 && ${2=25}>=0 && $2<=100 && isint(${3=3}) && $3>=0 && $3<=3 && isint(${4=1}) && isint(${5=7}) && $5>=0 && isint(${6=256}) && $6>=0"
  -e[^-1] "Randomly pack image$? with $1 scales, minimum scale $2%, "@{-arg\ 1+$3,no,180\"\ \"deg.,90\"\ \"deg.,any}" rotation, spacing $4, precision $5 and $6 maximum iterations."
  -v - N={@#-1} is_first_time=1
  -repeat @# -r[$>] 100%,100%,1,{max(2,@{$>,s})} -done   # Ensure all images have a binary shape mask.

  # Start iterations over scales.
  -repeat $1
    -rprogress {$>*100/$1}
    nb_attempts=0

    # Generate all sprites for current scale.
    ratio={if($1>1,$2+(100-$2)*$</($1-1),100)}%
    -repeat $N --l[{1+$>}]
      w={w*$ratio} h={h*$ratio}
      -if {$w<1||$h<1} -rm
      -else -r $w,$h,1,100%,2 -sh[-1] 100%,100% -neq[-1] 0 area{1+$>}=@{-1,+} -rm[-1]
      -endif
    -endl -done

    # Pack rescaled sprites together.
    -l[0,{$N+1}--1] -repeat $6

      # Compute reference sprite.
      ind={1+($>%$N)} area=${area$ind}
      -if {$3==0} [$ind]
      -elif {$3==1} --rotate[$ind] {round(?)*180}
      -elif {$3==2} --rotate[$ind] {round(?(3))*90}
      -else --rotate[$ind] {?*360} -sh[-1] 100%,100% -neq[-1] 0 area=@{-1,+} -rm[-1]
      -endif

      # Get binary map of possible locations.
      --channels[0] 100% -eq[-1] 0
      -if {$4>1} -erode[-1] {2*$4-1}
      -elif {$4<1} -dilate[-1] {-2*$4+3}
      -endif

      # Generate random skeleton-oriented point cloud.
      --rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,0
      -if $is_first_time -noise[-1] 0.1,2 -endif
      -distance[-1] 0 -noise[-1] 1,1
      -max_patch[-1] {round(1.5*@{$ind,max(w,h)})}
      -*[-1] [-2] -pointcloud3d[-1]

      # Subdivide point cloud if multiple sprites.
      -if {$N>1} -l[-1]
        -s3d -/[1] $N -round[1] -max[1] 1 n=@{1,0}
        -r[2] 3,{@{2,h}/3},1,1,-1
        -i[2] 1,@{2,h} -rand[2] 0,1 -a[2,3] x -sort[2] +,y -z[2] 1,3 -r[2] 3,$n,1,1 -y[2]
        -r[3] 1,{2*$n},1,1,0 -r[4] 1,{3*$n},1,1,0 -r[5] 1,$n,1,1,0 -a y
      -endl -endif

      # Create 3d cloud of sprites.
      n=@{-1,7}
      -if $n
        -s3d[-1] -rm[-2,-1]
        -if {$3==0} # No rotation allowed.
          [-6] -i[-2] (-128;{w};{h};{s})
          -if {$n>1} 4,{$n-1},1,1,-128,0,0,0 -endif
          --channels[-2] 100% -i[-2] (-128;{w};{h};{s})
          -if {$n>1} [-3] -endif
        -elif {$3==1} # 180 deg. rotation allowed.
          --rotate[-6] {round(?(1))*180} -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --rotate[-1] 180 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} 4,{$n-2},1,1,-128,0,0,0 1,100% -rand[-1] 0,1 -round[-1] 1 -j[-2] [-1],1 -rm[-1] -endif
          --channels[-4] 100% -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --channels[-4] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} [-5] -endif
        -else # 90 deg. rotation (or more) allowed.
          --rotate[-6] {round(?(3))*90} -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --rotate[-1] 90 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} --rotate[-1] 90 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>3} --rotate[-1] 90 -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>4} 4,{$n-4},1,1,-128,0,0,0 1,100% -rand[-1] 0,3 -round[-1] 1 -j[-2] [-1],1 -rm[-1] -endif
          --channels[-8] 100% -i[-2] (-128;{w};{h};{s})
          -if {$n>1} --channels[-8] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>2} --channels[-8] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>3} --channels[-8] 100% -i[-2] (-128;{w};{h};{s}) -endif
          -if {$n>4} [-9] -endif
        -endif
        -y[{$N+3}--1] -a[{$N+3}--1] y
      -endif
      -rm[-3] # Delete reference sprite.

      # Draw cloud and detect non-intersecting sprites.
      [0] -sh[-1] 100%,100% -f[-1] 1 --[-1] [-4]
      -object3d[-2] [-3],0,0,0,1,2,0,0 -rm[-3,-1]
      -sh[-1] 100%,100% -area_fg[-1] 0,1 -eq[-1] $area
      -*[-1] [-3] -rm[-3] -sh[-2] 0,@{-2,s-2} -*[-1] [-2] -rm[-1]

      # Draw selected sprites on rendering image.
      -if {iM} -j[0] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
      -else
        -rm[-2,-1]
        nb_attempts={$nb_attempts+1}
        -if {$nb_attempts>$5} -break -else -continue -endif
      -endif

    -done -k[0] -endl

  -done -k[0] -v +

#@gmic piechart : label_height>=0,label_R,label_G,label_B,"label1",value1,R1,G1,B1,...,"labelN",valueN,RN,GN,BN
#@gmic : Draw pie chart on selected (RGB) images.
#@gmic : $ image.jpg -piechart 25,0,0,0,"Red",55,255,0,0,"Green",40,0,255,0,"Blue",30,128,128,255,"Other",5,128,128,128
piechart : -check $1>=0
  -e[^-1] "Draw pie chart on image$?, with label height $1 and color ($2,$3,$4)."
  -v - $=arg -repeat @# -l[$>]
    -ellipse 50%,50%,{w/2-1},{h/2-1},0,1,1
    -ellipse 50%,50%,{w/2-1},{h/2-1},0,1,0xFFFFFFFF
    (${6--1:5}) -normalize_sum[-1]
    theta=0
    -if {w>1} -repeat {w}
      xe={0.5*@{-2,w}*(1+cos($theta))}
      ye={0.5*@{-2,h}*(1+sin($theta))}
      -line[-2] 50%,50%,$xe,$ye
      theta={$theta-2*pi*i($>)}
    -done -endif
    theta=0
    -repeat {w} -if {i($>)}
      ntheta={$theta-2*pi*i($>)}
      xc={0.5*@{-2,w}*(1+0.5*cos(0.5*($ntheta+$theta)))}
      yc={0.5*@{-2,h}*(1+0.5*sin(0.5*($ntheta+$theta)))}
      xf={0.5*@{-2,w}*(1+0.8*cos(0.5*($ntheta+$theta)))}
      yf={0.5*@{-2,h}*(1+0.8*sin(0.5*($ntheta+$theta)))}
      -flood[-2] $xf,$yf,0,0,0,1,${arg{7+5*$>}},${arg{8+5*$>}},${arg{9+5*$>}}
      -if {abs($ntheta-$theta)>0.1}
        0 -t[-1] ${arg{5+5*$>}},0,0,$1,1,1
        ($2^$3^$4) -r[-1] [-2],[-2],1,3 -*[-1] [-2]
        -j[-4] [-1],{$xc-w/2},{$yc-h/2},0,0,1,[-2]
        -rm[-2,-1]
      -endif
      theta=$ntheta
    -endif -done
    -rm[-1]
  -endl -done -v +

#@gmic plasma : _alpha,__beta,_scale>=0 : (+)
#@gmic : Draw a random colored plasma fractal on selected images.
#@gmic : This command implements the so-called 'Diamond-Square' algorithm.
#@gmic : Default values: 'alpha=1', 'beta=1' and 'scale=8'.
#@gmic : $ 400,400,1,3 -plasma

#@gmic point : x[%],y[%],_z[%],_opacity,_color1,.. : (+)
#@gmic : Set specified colored pixel on selected images.
#@gmic : Default values: 'z=0', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 10000 -point {?(100)}%,{?(100)}%,0,1,@{-RGB} -done

#@gmic polka_dots : diameter>=0,_density,_offset1,_offset2,_angle,_aliasing,_shading,_opacity,_color,...
#@gmic : Draw dots pattern on selected images.
#@gmic : Default values: 'density=20', 'offset1=offset2=50', 'angle=0', 'aliasing=10', 'shading=1', 'opacity=1' and 'color=255'.
#@gmic : $ image.jpg -polka_dots 10,15,0,0,20,10,1,0.5,0,128,255
polka_dots : -check $1>=0 -skip ${2=20},${3=50},${4=50},${5=0},${6=10},${7=1},${8=1},${9=255}
  -e[^-1] "Draw polka dots on image$?, with diameter $1, density $2, angle $3 deg., shift ($4,$5), aliasing $6 and shading $7."
  -v - theta={$5*pi/180} ct={cos($theta)} st={sin($theta)} mid1={$1/2} mid2={$2/2}
  -i[0] (${9--1}) -y[0] c
  -repeat {@#-1}
    WH={max(w,h)}
    100%,100%,100%,1,"xn = 100*x/"$WH"-$3; yn = 100*y/"$WH"-$4; \
                      xr = xn*"$ct"-yn*"$st"; yr = xn*"$st"+yn*"$ct"; \
                      xc = xr%$2-"$mid2"; yc = yr%$2-"$mid2"; \
                      "$mid1"-sqrt(xc*xc+yc*yc)"
    -*[-1] $6 -c[-1] 0,$7 -n[-1] 0,$8 (${9--1}) -y[-1] c -r[-1] [-2],[-2],[-2]
    -j[-3] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
  -mv[-1] 1 -done -rm[0] -v +

#@gmic polygon : N>=1,x1[%],y1[%],..,xN[%],yN[%],_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified colored N-vertices polygon on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the polygon is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,0.3,0,255,0 -polygon 4,20%,20%,80%,30%,80%,70%,20%,80%,1,0xCCCCCCCC,255
#@gmic : $ image.jpg 2,16,1,1,'?(if(x,@{-1,h},@{-1,w}))' -polygon[-2] {h},@-1,0.6,255,0,255 -remove[-1]

#@gmic quiver : [function_image],_sampling>0,_factor,_is_arrow={ 0 | 1 },_opacity,_pattern,_color1,.. : (+)
#@gmic : Draw specified 2d vector/orientation field on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified.
#@gmic : Default values: 'sampling=25', 'factor=-20', 'is_arrow=1', 'opacity=1', 'pattern=(undefined)'
#@gmic : and 'color1=0'.
#@gmic : $ 100,100,1,2,'if(c==0,x-w/2,y-h/2)' 500,500,1,3,255 -quiver[-1] [-2],10
#@gmic : $ image.jpg --resize2dy 600 -luminance[0] -gradient[0] -mul[1] -1 -reverse[0,1] -append[0,1] c -blur[0] 8 -orientation[0] -quiver[1] [0],10,10,1,0.8,255

#@gmic rectangle : x0[%],y0[%],x1[%],y1[%],_opacity,_pattern,_color1,..
#@gmic : Draw specified colored rectangle on selected images.
#@gmic : 'pattern' is an hexadecimal number starting with '0x' which can be omitted
#@gmic : even if a color is specified. If a pattern is specified, the rectangle is
#@gmic : drawn outlined instead of filled.
#@gmic : Default values: 'opacity=1', 'pattern=(undefined)' and 'color1=0'.
#@gmic : $ image.jpg -repeat 30 -rectangle {?(100)}%,{?(100)}%,{?(100)}%,{?(100)}%,0.3,@{-RGB} -done
rectangle : -skip ${5=1},${6=0}
  -v - ({'"$5"'}) is_pattern={@{-1,0-1}'=='{'0x'}} -rm[-1] -v +
  -if $is_pattern
    -e[0--3] "Draw outlined rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${7--1})."
  -else
    -e[0--3] "Draw filled rectangle from ($1,$2) to ($3,$4) on image$?, with opacity $5 and color (${6--1})."
  -endif
  -v - -polygon 4,$1,$2,$3,$2,$3,$4,$1,$4,${5--1} -v +

#@gmic rorschach : 'smoothness[%]>=0','mirroring={ 0=none | 1=x | 2=y | 3=xy }
#@gmic : Render rorschach-like inkblots on selected images.
#@gmic : Default values: 'smoothness=5%' and 'mirroring=1'.
#@gmic : $ 400,400 -rorschach 3%
rorschach : -check "${1=5%}>=0 && isint(${2=1}) && $2>=0 && $2<=3"
  -e[^-1] "Render rorschach-like inkblots on image$?, with smoothness $1 and "@{-arg\ 1+$2,no,x,y,xy}"-mirroring."
  -v -
  -if {$2==0} # No mirroring.
   -rand -1,1 -b $1 -ge 0
  -elif {$2==1} # X-mirroring.
    -repeat @# -l[$>]
      w={w}
      -columns 0,{w/2-1} -rand -1,1 -b $1 -ge 0
      --mirror x -if {$w%2} -columns[-1] 1,100% -endif -a x
    -endl -done
  -elif {$2==2} # Y-mirroring.
    -repeat @# -l[$>]
      h={h}
      -rows 0,{h/2-1} -rand -1,1 -b $1 -ge 0
      --mirror y -if {$h%2} -rows[-1] 1,100% -endif -a y
    -endl -done
  -elif {$2==3} # XY-mirroring.
    -repeat @# -l[$>]
      w={w} h={h}
      -z 0,0,{w/2-1},{h/2-1} -rand -1,1 -b $1 -ge 0
      --mirror x -if {$w%2} -columns[-1] 1,100% -endif -a x
      --mirror y -if {$h%2} -rows[-1] 1,100% -endif -a y
    -endl -done
  -endif
  -v +

#@gmic sierpinski : recursion_level>=0
#@gmic : Draw Sierpinski triangle on selected images.
#@gmic : Default value: 'recursion_level=7'.
#@gmic : $ image.jpg -sierpinski 7
sierpinski : -check ${1=7}>=0 -skip ${2=50},${3=0},${4=0},${5=100},${6=100},${7=100}
  -e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
  -v - -_sierpinski ${2-7},$1  -v +

_sierpinski :
  -if {$7<=0} -polygon 3,$1%,$2%,$3%,$4%,$5%,$6%,1,255 -return -endif
  -_sierpinski $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},{$7-1}
  -_sierpinski {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},{$7-1}
  -_sierpinski {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},{$7-1}

#@gmic snowflake : _recursion>=0,_x0,_y0,_x1,_y1,_x2,_y2,_opacity,_col1,..._colN
#@gmic : Draw a Koch snowflake on selected images.
#@gmic : Default values: 'recursion=4', 'x0=20', 'y0=70', 'x1=80', 'y1=70', 'x2=50', 'y2=10', 'opacity=1' and 'col1=255'.
#@gmic : $ image.jpg -snowflake 4
snowflake : -check ${1=4}>=0 -skip ${2=20},${3=70},${4=80},${5=70},${6=50},${7=10},${8=1},${9=255}
  -v -
  -polygon 3,$2%,$3%,$4%,$5%,$6%,$7%,${8--1}
  -_snowflake $1,$2,$3,$6,$7,${8--1}
  -_snowflake $1,$6,$7,$4,$5,${8--1}
  -_snowflake $1,$4,$5,$2,$3,${8--1}
  -v +

_snowflake :
  x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
  x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
  c={cos(-pi/3)} s={sin(-pi/3)}
  x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
  -polygon 3,$x0%,$y0%,$x1%,$y1%,$x2%,$y2%,${6--1}
  -if $1
    -_snowflake {$1-1},$2,$3,$x0,$y0,${6--1}
    -_snowflake {$1-1},$x0,$y0,$x2,$y2,${6--1}
    -_snowflake {$1-1},$x2,$y2,$x1,$y1,${6--1}
    -_snowflake {$1-1},$x1,$y1,$4,$5,${6--1}
  -endif

#@gmic spiralbw
#@gmic : Draw (squared) spiral on selected images.
#@gmic : $ 16,16 -spiralbw
spiralbw :
  -e[^-1] "Draw (squared) black and white spiral on image$?."
  -v - -channels 0
  -f "r=min(x,y,w-1-x,h-1-y); 2*r*(w+h-2*r-1) + if(min(x,h-1-y)>=min(w-1-x,y),x+y,2*(w+h-2-2*r)-x-y)"
  -v +

#@gmic spline : x0[%],y0[%],u0[%],v0[%],x1[%],y1[%],u1[%],v1[%],_nb_vertices>=2,_opacity,_color1,..
#@gmic : Draw specified colored spline curve on selected images (cubic hermite spline).
#@gmic : Default values: 'nb_vertices=256', 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -repeat 30 -spline {?(100)}%,{?(100)}%,{?(-600,600)},{?(-600,600)},{?(100)}%,{?(100)}%,{?(-600,600)},{?(-600,600)},256,0.3,255 -done
spline : -skip ${9=256},${10=1},${11=0}
  -e[^-1] "Draw spline from ($1,$2) [$3,$4] to ($5,$6) [$7,$8] on image$?, with $9 vertices, opacity $10 and color (${11--1})."
  -v - -repeat @# -l[$>]
    x0={if(@{"-is_percent $1"},$1*(w-1),$1)}
    y0={if(@{"-is_percent $2"},$2*(h-1),$2)}
    u0={if(@{"-is_percent $3"},$3*(w-1),$3)}
    v0={if(@{"-is_percent $4"},$4*(h-1),$4)}
    x1={if(@{"-is_percent $5"},$5*(w-1),$5)}
    y1={if(@{"-is_percent $6"},$6*(h-1),$6)}
    u1={if(@{"-is_percent $7"},$7*(w-1),$7)}
    v1={if(@{"-is_percent $8"},$8*(h-1),$8)}
    -spline3d $x0,$y0,0,$u0,$v0,0,$x1,$y1,0,$u1,$v1,0,$9
    -sh[-1] 8,{8+3*$9-1},0,0 -round[-1] -rm[-1]
    -col3d[1] ${11--1} -object3d[0] [1],0,0,0,$10,1,0,0 -rm[1]
  -endl -done -v +

#@gmic t : eq. to '-text'. : (+)

#@gmic text : text,_x[%],_y[%],_font_height>=0,_opacity,_color1,.. : (+)
#@gmic : Draw specified colored text string on selected images.
#@gmic : (eq. to '-t').
#@gmic : Exact pre-defined sizes are '13','24','32' and '57'. Any other size is interpolated.
#@gmic : Specifying an empty target image resizes it to new dimensions such that the image contains
#@gmic : the entire text string.
#@gmic : Default values: 'opacity=1' and 'color1=0'.
#@gmic : $ image.jpg -resize2dy 600 y=0 -repeat 30 -text {2*$>}" : This is a nice text, isn't it ?",10,$y,{2*$>},0.9,255 y={$y+2*$>} -done
#@gmic : $ 0 -text "G'MIC",0,0,24,1,255

#@gmic text_outline : text,_x[%],_y[%],_font_height>0,_outline>=0,_opacity,_color1,..
#@gmic : Draw specified colored and outlined text string on selected images.
#@gmic : Default values: 'x=y=2', 'font_height=13', 'outline=2', 'opacity=1' and 'color1=255'.
#@gmic : $ image.jpg -text_outline "Hi there!",10,10,52,3
text_outline : -skip ${2=2},${3=2},${4=13},${5=2},${6=1},${7=255},${8=$-1},${9=$-1}
  -e[^-1] "Draw outlined text '$1' at position ($2,$3) on image$?, with font height $4, outline $5, opacity $6 and color ${7--1}."
  -v -
  -if $5
    0 -t[-1] "$1",0,0,$4,1,1 -expand_xy[-1] {1+$5},0 --dilate[-1] {2*$5+1}
    (${7--1}) -y[-1] c -r[-1] 2,1,1,100%,0,0,1 -map[-3] [-1] -rm[-1]
    -repeat {@#-2} -if @{$>,w} -j[$>] [-2],$2,$3,0,0,$6,[-1] -else -rm[$>] -i[$>] [-2] -endif -done -rm[-2,-1]
  -else
    -t "$1",${2-4},${6--1}
  -endif
  -v +

#@gmic triangle_shade : x0,y0,x1,y0,x2,y2,R0,G0,B0,...,R1,G1,B1,...,R2,G2,B2,....
#@gmic : Draw triangle with interpolated colors on selected images.
#@gmic : $ image.jpg -triangle_shade 20,20,400,100,120,200,255,0,0,0,255,0,0,0,255
triangle_shade :
  -e[^-1] "Draw triangle ($1,$2)-($3,$4)-($5,$6) with interpolated colors on image$?."
  -v -
  # Find mapping coefficients for each color.
  -l[] ($1,$2,1;$3,$4,1;$5,$6,1) (${7--1}) -r[-1] {w/3},3,1,1,-1 -s[-1] x -solve[^0] [0] -rm[0] -a c -endl
  -polygon[^-1] 3,${1-6},1,-65535 # Mask images with triangle.
  -repeat {@#-1} -l[$>,-1] -repeat @{0,s}
    a={i(0,0,0,$>)} b={i(0,1,0,$>)} c={i(0,2,0,$>)}
    -sh[0] $>,$> -f[-1] 'if(i==-65535,$a*x+$b*y+$c,i)' -rm[-1]
  -done -endl -done
  -rm[-1] -v +

#@gmic truchet : _scale>0,_radius>=0,_pattern_type={ 0=straight | 1=curved }
#@gmic : Fill selected images with random truchet patterns.
#@gmic : Default values: 'scale=32', 'radius=5' and 'pattern_type=1'.
#@gmic : $ 400,300 -truchet ,
truchet : -check "isint(${1=32}) && $1>0 && ${2=3}>=0" -skip ${3=1}
  -e[^-1] "Render "@{-arg\ 1+!$3,curved,straight}" truchet patterns in image$?, with scale $1 and radius $2."
  -v - -repeat @# -l[$>] nm=@{0,n}
    w={w} h={h} s={s} -rm
    $1,$1 -= 1,0,0 -= 1,100%,100% -distance 1,{1+$3} M={int(iM/2)} # Generate truchet pattern and its mirrored version.
    -t2 {$M-$2/2-($1%2)},{$M+$2/2} --mirror y -a x
    {round($w/$1,1,1)},{round($h/$1,1,1)} -rand[-1] 0,1 -ge[-1] 50% -r[-1] {w*$1},{h*$1} -*[-1] $1
    -channels[-1] 0,1 (0,{$1-1}) -r[-1] $1,$1,1,1,3 --transpose[-1] -a[-2,-1] c -r[-1] [-2],0,2 -+[-2,-1]
    -warp[-2] [-1] -rm[-1] -ge 50% -r $w,$h,1,1,0 -r 100%,100%,1,$s
  -nm $nm,1 -endl -done -v +

#@gmic turbulence : _radius>0,_octaves={1,2,3...,12},_alpha>0,_difference={-10,10},_mode={0,1,2,3}
#@gmic : Render fractal noise or turbulence on selected images.
#@gmic : Default values: 'radius=32', 'octaves=6', 'alpha=3', 'difference=0' and 'mode=0'.
#@gmic : $ 400,400,1,3 -turbulence 16
turbulence : -check "${1=32}>0 && ${2=6}>0" -skip ${3=3},${4=0},${5=0}
  -e[^-1] "Render fractal noise or turbulence on image$?, with radius $1, octaves $2, damping per octave $3, difference $4 and mode $5."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -if {$4} [-1] -endif
    -f[-1] 0 --noise[-1] 10,0 -b[-1] $1,0
    -if {$5==0||$5==1} --[-1] @{-1,a} -abs[-1]
    -elif {$5==3||$5==4} -^[-1] 2
    -elif {$5==5} -^[-1] 3
    -endif
    -repeat {$2-1}
      --noise[-2] 10,0 -b[-1] {$1/2^$>},0
      -if {$5==0} --[-1] @{-1,a} -abs[-1]
      -elif {$5==4} -^[-1] 2
      -elif {$5==5} -^[-1] 3
      -endif
      -*[-2] $3 -+[-2--1]
    -done
    -n[-1] 0,255
    -rm[-2]
    -if {$4} -*[-1] $4 -mv[-2] 2 -- -n[-1] 0,255 -endif
  -nm $nm,1 -endl -done -v +

#@gmic yinyang
#@gmic : Draw a yin-yang symbol on selected images.
#@gmic : $ 400,400 -yinyang
yinyang :
  -e[^-1] "Draw yin-yang symbol on image$?."
  -v - -f 0 -repeat @# -l[$>]
    s={s} -channels 0
    r={round(0.95*min(w,h)/4)}
    --line 50%,0,50%,50%,1,2 -ellipse[-1] 50%,{h/2-$r},$r,$r,0,1,2
    -line[-1] 50%,50%,50%,100%,1,1 -ellipse[-1] 50%,{h/2+$r},$r,$r,0,1,1
    -flood[-1] {w/2-$r},50%,0,0,0,1,2
    -flood[-1] {w/2+$r},50%,0,0,0,1,1
    -ellipse[-2] 50%,50%,{2*$r},{2*$r},0,1,1
    -*
    -ellipse[-1] 50%,{h/2-$r},{$r/3},{$r/3},0,1,1
    -ellipse[-1] 50%,{h/2+$r},{$r/3},{$r/3},0,1,2
    -r 100%,100%,1,$s
  -endl -done -v +

#---------------------------------
#
#@gmic :: Matrix computation
#
#---------------------------------

#@gmic dijkstra : starting_node>=0,ending_node>=0 : (+)
#@gmic : Compute minimal distances and pathes from specified adjacency matrices by the Dijkstra algorithm.

#@gmic eigen : (+)
#@gmic : Compute the eigenvalues and eigenvectors of selected symmetric matrices or matrix fields.
#@gmic : If one selected image has 3 or 6 channels, it is regarded as a field of 2x2 or 3x3 symmetric matrices,
#@gmic : whose eigen elements are computed at each point of the field.
#@gmic : $ (1,0,0;0,2,0;0,0,3) --eigen
#@gmic : $ image.jpg -structuretensors -blur 2 -eigen -split[0] c

#@gmic invert : (+)
#@gmic : Compute the inverse of the selected matrices.
#@gmic : $ (0,1,0;0,0,1;1,0,0) --invert

#@gmic solve : [image] : (+)
#@gmic : Solve linear system AX = B for selected B-vectors and specified A-matrix.
#@gmic : If the system is under- or over-determined, least square solution is returned.
#@gmic : $ (0,1,0;1,0,0;0,0,1) (1;2;3) --solve[-1] [-2]

#@gmic svd : (+)
#@gmic : Compute SVD decomposition of selected matrices.
#@gmic : $ 10,10,1,1,'if(x==y,x+?(-0.2,0.2),0)' --svd

#@gmic transpose
#@gmic : Transpose selected matrices.
#@gmic : $ image.jpg --transpose
transpose :
  -e[^-1] "Transpose image$?."
  -v - -permute yxzc -v +

#@gmic trisolve : [image] : (+)
#@gmic : Solve tridiagonal system AX = B for selected B-vectors and specified tridiagonal A-matrix.
#@gmic : Tridiagonal matrix must be stored as a 3 column vector, where 2nd column contains the
#@gmic : diagonal coefficients, while 1st and 3rd columns contain the left and right coefficients.
#@gmic : $ (0,0,1;1,0,0;0,1,0) (1;2;3) --trisolve[-1] [-2]

#---------------------------------
#
#@gmic :: 3d rendering
#
#---------------------------------

#@gmic +3d : eq. to '-add3d'. : (+)

#@gmic add3d : tx,_ty,_tz : [object3d] : (noargs) : (+)
#@gmic : Shift selected 3d objects with specified displacement vector, or merge them with specified
#@gmic : 3d object, or merge all selected 3d objects together.
#@gmic : (eq. to '-+3d').
#@gmic : Default values: 'ty=tz=0'.
#@gmic : $ -sphere3d 10 -repeat 5 --add3d[-1] 10,{?(-10,10)},0 -color3d[-1] @{-RGB} -done -add3d
#@gmic : $ -repeat 20 -torus3d 15,2 -color3d[-1] @{-RGB} -mul3d[-1] 0.5,1 -if {$>%2} -rotate3d[-1] 0,1,0,90 -endif -add3d[-1] 70 -add3d -rotate3d[-1] 0,0,1,18 -done -double3d 0

#@gmic animate3d : _width>0,_height>0,_dx,_dy,_dz,_zoom>=0,_filename
#@gmic : Animate selected 3d objects in a window.
animate3d : -skip ${1=640},${2=480},${3=0},${4=10},${5=0},"${7=""}" -check ${6=1}>=0
  -e[^-1] "Animate 3d object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
  -v - -repeat @# --l[$>]
    -n3d -*3d {$6*min($1,$2)/1.5} -c3d
    ax=0 ay=0 az=0 frame=0
    -do
       --r3d 1,0,0,$ax -r3d[-1] 0,1,0,$ay -r3d[-1] 0,0,1,$az
       ax={$ax+$3} ay={$ay+$4} az={$az+$5}
       $1,$2,1,3,-1 -object3d[-1] [-2],50%,50%,0,1
       -if {narg("$7")}
         -to_rgba[-1] -replace_color[-1] 0,0,-1,-1,-1,255,64,64,64,0
         -o[-1] @{-filename\ "$7",$>,$frame} frame={$frame+1}
       -else
         -replace[-1] -1,64
       -endif
       -w[-1] {w},{h},0,0,-1,-1,@{0,n} -wait 20 -k[0]
    -while {@!" && "!@{!,ESC}" && "!@{!,Q}} -rm -w 0
  -endl -done -v +

#@gmic apply_camera3d : pos_x,pos_y,pos_z,target_x,target_y,target_z,up_x,up_y,up_z
#@gmic : Apply 3d camera matrix to selected 3d objects.
#@gmic : Default values: 'target_x=0', 'target_y=0', 'target_z=0', 'up_x=0', 'up_y=-1' and 'up_z=0'.
apply_camera3d : -skip ${4=0},${5=0},${6=0},${7=0},${8=-1},${9=0}
  -e[^-1] "Apply 3d camera matrix to 3d object$?, with camera position ($1,$2,$3), target position ($4,$5,$6) and up-vector ($7,$8,$9)."
  -v -
  ({$4-$1}^{$5-$2}^{$6-$3})  # f.
  ($7^$8^$9)                 # up.
  -orientation[-2,-1]        # f/|f| and up/|up|.
  -_cross3d @-2,@-1          # s = f x up
  -_cross3d @-1,@-3          # u = s x f
  -rm[-3] -y[-3--1] x -mv[-2,-1] -3
  -a[-3--1] y -z[-1] 0,3  # Rotation matrix R.
  --3d[^-1] $1,$2,$3 -apply_pose3d[^-1] @-1 -rm[-1] --3d 0,0,800
  -v +

_cross3d :
  ({$2*$6-$3*$5}^{$3*$4-$1*$6}^{$1*$5-$2*$4}) -orientation[-1] -y[-1]

#@gmic apply_pose3d : p1,..,p12
#@gmic : Apply 3d pose matrix to selected 3d objects.
#@gmic : $ -torus3d 100,20 -apply_pose3d 0.152437,1.20666,-0.546366,0,-0.535962,0.559129,1.08531,0,1.21132,0.0955431,0.548966,0,0,0,-206,1 -snapshot3d 400
apply_pose3d :
  -e[^-1] "Apply 3d pose matrix [ $1,$2,$3,$4; $5,$6,$7,$8; $9,$10,$11,$12 ] to 3d object$?."
  -v - -repeat @# -l[$>] -if @{-is_3d}
    -s3d -r[2] 3,@{2,h/3},1,1,-1 -i[3] 1,@{2,h},1,1,1 -a[2,3] x
    -i[3] ($1,$5,$9;$2,$6,$10;$3,$7,$11;$4,$8,$12) -**[2,3]
    -r[2] 1,@{2,3*h},1,1,-1 -a y
  -else -error "Image ["{@#-$>-1}"] does not represent a 3d object."
  -endif -endl -done -v +

#@gmic arrow3d : x0,y0,z0,x1,y1,z1,_radius[%]>=0,_head_length[%]>=0,_head_radius[%]>=0
#@gmic : Input 3d arrow with specified starting and ending 3d points.
#@gmic : Default values: 'radius=5%', 'head_length=25%' and 'head_radius=15%'.
#@gmic : $ -repeat 10 a={$>*2*pi/10} -arrow3d 0,0,0,{cos($a)},{sin($a)},-0.5 -done -+3d
arrow3d : -check "${7=5%}>=0 && ${8=25%}>=0 && ${9=15%}>=0"
  -e[^-1] "Input 3d arrow, from (${1-3}) to (${4-6}), with radius $7, head length $8 and head radius $9."
  -v -

  # Create 3d object.
  L={sqrt(($4-$1)^2+($5-$2)^2+($6-$3)^2)}
  R={if(@{-is_percent\ $7},$7*$L,$7)}
  l={if(@{-is_percent\ $8},$8*$L,$8)}
  r={if(@{-is_percent\ $9},$9*$L,$9)}
  L={$L-$l} -cylinder3d $R,$L -cone3d $r,$l -+3d[-1] 0,0,$L -+3d[-2,-1]

  # Compute rotation matrix for arrow orientation.
  ({$4-$1}^{$5-$2}^{$6-$3}) (0.01^-0.02^0.03) -orientation[-2,-1]
  -_cross3d @-2,@-1 -_cross3d @-1,@-3 -rm[-3] -y[-3--1] x -mv[-2,-1] -3
  -a[-3--1] y

  # Rotate and translate the arrow at specified coordinates.
  -s3d[-2] -r[-5] 3,@{-5,h/3},1,1,-1 -**[-5,-1]
  -y[-4] -a[-6--1] y -+3d[-1] ${1-3} -rv3d[-1]
  -v +

#@gmic axes3d : _size_x,_size_y,_size_z,_font_size>0,_label_x,_label_y,_label_z
#@gmic : Input 3d axes with specified sizes along the x,y and z orientations.
#@gmic : Default values: 'size_x=size_y=size_z=1', 'font_size=24', 'label_x=X', 'label_y=Y' and 'label_z=Z'.
#@gmic : $ -axes3d ,
axes3d : -check ${4=24}>0 -skip ${1=1},${2=$1},${3=$2},"${5=X},${6=Y},${7=Z}"
  -e[^-1] "Input 3d axes with sizes ($1,$2,$3)."
  -v - -l[]
  m={max(abs($1),abs($2),abs($3))/40} m2={2*$m} m3={1.2*$m2}
  -_axes3d "O",$4 --3d[-1] $m3,$m3,$m3
  -if $1
    -line3d 0,0,0,$1,0,0
    -cone3d $m,{2*$m},16 -r3d[-1] 0,1,0,-90 -+3d[-1] {$1-$m2},0,0
    -_axes3d "$5",$4 -+3d[-1] {$1+$m3},0,0
  -endif
  -if $2
    -line3d 0,0,0,0,$2,0
    -cone3d $m,{2*$m},16 -r3d[-1] 1,0,0,90 -+3d[-1] 0,{$2-$m2},0
    -_axes3d "$6",$4 -+3d[-1] 0,{$2+$m3},0
  -endif
  -if $3
    -line3d 0,0,0,0,0,$3
    -cone3d $m,{2*$m},16 -+3d[-1] 0,0,{$3-$m2}
    -_axes3d "$7",$4 -+3d[-1] 0,0,{$3+$m3}
  -endif
  -+3d -nm [3d\ axes]
  -endl -v +

_axes3d :
  0 -t[-1] "$1",2,0,$2,1,1 --dilate[-1] 3 -*[-2] 255 -r[-2] 100%,100%,1,3
  -i[-3] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};3)
  -i[-2] (-128;{w};{h};1) -y[-3,-1] -a[-4--1] y

#@gmic b3d : eq. to '-background3d'. : (+)

#@gmic background3d : R,_G,_B : [image] : (no args) : (+)
#@gmic : Define background from specified color or existing image for interactive 3d viewer.
#@gmic : (eq. to '-b3d').
#@gmic : (no args) resets the background to default.

#@gmic box3d : _size_x,_size_y,_size_z
#@gmic : Input 3d box at (0,0,0), with specified geometry.
#@gmic : Default values: 'size_x=1' and 'size_z=size_y=size_x'.
#@gmic : $ -box3d 100,40,30 --primitives3d 1 -color3d[-2] @{-RGB}
box3d : -skip ${1=1},${2=$1},${3=$2}
  -e[^-1] "Input 3d box, with size ($1,$2,$3)."
  -v -
  1,86,1,1,\
  67.5,73.5,109.5,103.5,51.5,100.5,8,6,\
  0,0,0,$1,0,0,$1,$2,0,0,$2,0,\
  0,0,$3,$1,0,$3,$1,$2,$3,0,$2,$3,\
  4,0,3,2,1,4,4,5,6,7,4,0,1,5,4,4,3,7,6,2,4,0,4,7,3,4,1,2,6,5,\
  200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,200,\
  1,1,1,1,1,1
  -nm[-1] [3d\ box]
  -v +

#@gmic c3d : eq. to '-center3d'.
c3d :
  -_center3d

#@gmic center3d
#@gmic : Center selected 3d objects at (0,0,0).
#@gmic : (eq. to '-c3d').
#@gmic : $ -repeat 100 -circle3d {?(100)},{?(100)},{?(100)},2 -done -add3d -color3d[-1] 255,0,0 --center3d -color3d[-1] 0,255,0 -add3d
center3d :
  -_$0

_center3d :
  -e[0--3] "Center 3d object$?."
  -v - -check3d 0 -repeat @# -l[$>]
    n={i[6]}
    -if {$n>0}
      -sh 8,{7+3*$n},0,0 -r[-1] 3,{h/3},1,1,-1 -s[-1] x
      --[-3] @{-3,(iM+im)/2} --[-2] @{-2,(iM+im)/2} --[-1] {(iM+im)/2}
      -a[-3--1] x -y[-1] -j[-2] [-1],0,8 -rm[-1]
    -endif
  -endl -done -v +

#@gmic circle3d : _x0,_y0,_z0,_radius>=0
#@gmic : Input 3d circle at specified coordinates.
#@gmic : Default values: 'x0=y0=z0=0' and 'radius=1'.
#@gmic : $ -repeat 500 a={$>*pi/250} -circle3d {cos(3*$a)},{sin(2*$a)},0,{$a/50} -color3d[-1] @{-RGB},0.4 -done -add3d
circle3d : -skip ${1=0},${2=0},${3=0},${4=1}
  -e[^-1] "Input 3d circle at position ($1,$2,$3) with radius $4."
  -v -
  r={$4/sqrt(3)}
  1,24,1,1,\
  67.5,73.5,109.5,103.5,51.5,100.5,2,1,\
  {$1-$r},{$2-$r},{$3-$r},\
  {$1+$r},{$2+$r},{$3+$r},\
  5,0,1,0,0,0,200,200,200,1
  -nm[-1] [3d\ circle]
  -v +

#@gmic circles3d : _radius>=0
#@gmic : Convert specified 3d objects to sets of 3d circles with specified radius.
#@gmic : Default value: 'radius=1'.
#@gmic : $ image.jpg -luminance -resize2dy 40 -threshold 50% -* 255 -pointcloud3d -color3d[-1] 255,255,255 -circles3d 0.7
circles3d : -check ${1=1}>=0
  -e[^-1] "Convert 3d object$? to sets of 3d circles with radius $1."
  -v - -p3d 0 -repeat @# -l[$>]
    nbv=@{-1,6} nbp=@{-1,7}
    -if {$nbv&&$nbp}
      --3d {$1/2},0,0 --+3d $1,0,0 -+3d nbp2=@{-1,7}
      -s3d -=[1] $nbp,0,1
      -r[3] 2,$nbp2,1,1,-1 -columns[3] 1,1 -s[3] y,2 -i[3] 1,$nbp,1,1,5 -a[3-5] x -columns[3] 0,5 -y[3]
      -rows[4] 0,{3*$nbp-1} -rows[5] 0,{$nbp-1} -a y
    -endif
  -endl -done -v +

#@gmic col3d : eq. to '-color3d'. : (+)

#@gmic color3d : R,_G,_B,_opacity : (+)
#@gmic : Set color and opacity of selected 3d objects.
#@gmic : (eq. to '-col3d').
#@gmic : Default value: 'B=G=R' and 'opacity=(undefined)'.
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d[-1] 1,0,0,20 -color3d[-1] @{-RGB} -done -add3d

#@gmic colorcube3d
#@gmic : Input 3d color cube.
#@gmic : $ -colorcube3d -mode3d 2 --primitives3d 1
colorcube3d :
  -e[^-1] "Input 3d RGB-color cube."
  -v -
  (67.5;73.5;109.5;103.5;51.5;100.5;8;6)
  (0;0;0;\
   255;0;0;\
   255;255;0;\
   0;255;0;\
   0;0;255;\
   255;0;255;\
   255;255;255;\
   0;255;255)
  (12;0;3;2;1;0;0;0;63;63;63;63;0;\
   12;1;2;6;5;0;0;0;63;63;63;63;0;\
   12;0;4;7;3;0;0;63;0;63;63;0;63;\
   12;4;5;6;7;0;0;63;0;63;63;0;63;\
   12;0;1;5;4;0;0;63;0;63;63;0;63;\
   12;3;7;6;2;0;0;0;63;63;63;63;0)
  (0,255;0,255^0,0;255,255^0,0;0,0)
  (255,255;255,255^0,0;255,255^0,255;0,255)
  (0,0;0,0^0,0;255,255^0,255;0,255)
  (0,255;0,255^0,0;255,255^255,255;255,255)
  (0,255;0,255^0,0;0,0^0,0;255,255)
  (0,255;0,255^255,255;255,255^0,0;255,255)
  -r[-6--1] 64,64,1,3,3 -y[-6--1] -i[-7--2] (-128;64;64;3)
  (1;1;1;1;1;1)
  -a[-16--1] y -nm[-1] [3d\ colorcube]
  -v +

#@gmic cone3d : _radius,_height,_nb_subdivisions>0
#@gmic : Input 3d cone at (0,0,0), with specified geometry.
#@gmic : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@gmic : $ -cone3d 10,40 --primitives3d 1 -color3d[-2] @{-RGB}
cone3d : -check ${3=24}>0 -skip ${1=1},${2=1}
  -e[^-1] "Input 3d cone, with radius $1, height $2 and $3 subdivisions."
  -v -
  # Header.
  (67.5;73.5;109.5;103.5;51.5;100.5)
  ({$3+2};{2*$3})

  # Vertices.
  (0,0,0;0,0,$2)
  (0;{2*pi}) -r[-1] 1,{$3+1},1,1,3 -rows[-1] 0,{$3-1} --sin[-1] -cos[-2] -*[-2,-1] $1 -a[-2,-1] x -z[-1] 0,2 -a[-2,-1] y

  # Primitives.
  1,$3,1,1,'y' --shift[-1] 0,-1 -+[-2,-1] 2
  2,$3,1,1,3,0 [-2] [-4] -a[-3--1] x
  -i[-4] 2,$3,1,1,3,1 -a[-4--2] x
  -a[-2,-1] y

  # Colors / opacities.
  3,{h},1,1,200
  1,{h},1,1,1
  -y[-4--2] -a[-6--1] y -nm[-1] [3d\ cone]
  -v +

#@gmic cubes3d : _size>=0
#@gmic : Convert specified 3d objects to sets of 3d cubes with specified size.
#@gmic : Default value: 'size=1'.
#@gmic : $ image.jpg -luminance -resize2dy 40 -threshold 50% -* 255 -pointcloud3d -color3d[-1] 255,255,255 -cubes3d 1
cubes3d : -check ${1=1}>=0
  -e[^-1] "Convert 3d object$? to sets of 3d cubes with size $1."
  -v - -p3d 0 -repeat @# -l[$>]
    nbv=@{-1,6} nbp=@{-1,7}
    -if {$nbv&&$nbp}
      -s3d
      -l[1] -= {8*i[0]} -= {6*i[1]},0,1 -endl  # Header.
      -l[2] -r 3,{h/3},1,1,-1                  # Vertices.
      half={$1/2}
      -- '$half,0,0' --+ '$1,0,0' -a x
      -- '0,$half,0' --+ '0,$1,0' -a x
      -- '0,0,$half' --+ '0,0,$1' -a x
      -endl
      -l[3] -r 2,{h/2},1,1,-1                  # Primitives.
      -z 1,1 -* 8 -r 4,100% -i[0] 1,100%,1,1,4 -a x [-1]x5 -a x
      -+ '"0,0,2,3,1, 0,4,5,7,6, 0,0,1,5,4, 0,2,6,7,3, 0,0,4,6,2, 0,1,3,7,5"'
      -endl
      -l[4] -r 3,{h/3},1,1,-1 -r 18,100%,1,1,0,2 -endl -r[5] 6,100% # Colors & opacities.
      -y -a y
    -endif
  -endl -done -v +

#@gmic cup3d : _resolution>0
#@gmic : Input 3d cup object.
#@gmic : $ -cup3d ,
cup3d : -check ${1=128}>0
  -e[^-1] "Input 3d cup, with resolution $1."
  -v -
  100,200
  -ellipse[-1] 0%,0%,40%,40%,0,1,1
  -ellipse[-1] 0,0,35%,35%,0,1,0
  -polygon[-1] 4,0,45%,8%,45%,20%,90%,0,90%,1,1
  -ellipse[-1] 0%,100%,30%,10%,0,1,1 -b[-1] 0.1%
  -lathe3d[-1] $1,2 -nm[-1] [3d\ cup]
  -v +

#@gmic cylinder3d : _radius,_height,_nb_subdivisions>0
#@gmic : Input 3d cylinder at (0,0,0), with specified geometry.
#@gmic : Default value: 'radius=1','height=1' and 'nb_subdivisions=24'.
#@gmic : $ -cylinder3d 10,40 --primitives3d 1 -color3d[-2] @{-RGB}
cylinder3d : -check ${3=24}>0 -skip ${1=1},${2=1}
  -e[^-1] "Input 3d cylinder, with radius $1, height $2 and $3 subdivisions."
  -v -
  # Header.
  (67.5;73.5;109.5;103.5;51.5;100.5)
  ({2*$3+2};{3*$3})

  # Vertices.
  (0,0,0;0,0,$2)
  (0;{2*pi}) -r[-1] 1,{$3+1},1,1,3 -rows[-1] 0,{$3-1} --sin[-1] -cos[-2] -*[-2,-1] $1 -a[-2,-1] x
  --z[-1] 0,2 1,$3,1,1,$2 -a[-3,-1] x
  -a[-3--1] y

  # Primitives.
  1,$3,1,1,'y' --shift[-1] 0,-1 -+[-2,-1] 2
  2,$3,1,1,3,1 [-3] [-3] -a[-3--1] x
  2,$3,1,1,3,0 [-3] [-5] -+[-2,-1] $3 -a[-3--1] x
  --+[-4,-3] $3 -i[-7] 1,$3,1,1,4 -rv[-6,-5] -a[-7--5,-2,-1] x

  # Colors / opacities.
  3,{3*$3},1,1,200
  1,{h},1,1,1
  -y[-6--2] -a[-8--1] y -nm[-1] [3d\ cylinder]
  -v +

#@gmic distribution3d
#@gmic : Get 3d color distribution of selected images.
#@gmic : $ image.jpg -distribution3d -colorcube3d -primitives3d[-1] 1 -add3d
distribution3d :
  -e[^-1] "Get 3d color distribution of image$?."
  -v - -to_rgb -permute "cxyz" -y
  -repeat @# -l[$>]
    nbp={h/3}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\               # Magick number for CImg3d.
            $nbp;$nbp)                                       # Number of vertices and primitives.
    (1,0;1,{$nbp-1}) -r[-1] 2,$nbp,1,1,3 -round[-1] 1 -y[-1] # Primitives.
    [-2]                                                     # Colors.
    1,$nbp,1,1,1                                             # Opacities.
    -a y -nm[-1] [3d\ distribution]                          # Build 3d object.
  -endl -done -v +

#@gmic /3d : eq. to '-div3d'. : (+)

#@gmic div3d : factor : factor_x,factor_y,_factor_z : (+)
#@gmic : Scale selected 3d objects isotropically or anisotropically, with the inverse of specified
#@gmic : factors.
#@gmic : (eq. to '-/3d').
#@gmic : Default value: 'factor_z=0'.
#@gmic : $ -torus3d 5,2 -repeat 5 --add3d[-1] 12,0,0 -div3d[-1] 1.2 -color3d[-1] @{-RGB} -done -add3d

#@gmic db3d : eq. to '-double3d'. : (+)

#@gmic double3d : _is_double_sided={ 0 | 1 } : (+)
#@gmic : Enable/disable double-sided mode for 3d rendering.
#@gmic : (eq. to '-db3d').
#@gmic : Default value: 'is_double_sided=1'.
#@gmic : $ -mode3d 1 -repeat 2 -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -double3d $> -snapshot3d[-1] 400 -done

#@gmic elevation3d : z-factor : [elevation_map] : 'formula' : (no args) : (+)
#@gmic : Build 3d elevation of selected images, with a specified elevation map.
#@gmic : When invoked with (no args) or 'z-factor', the elevation map is computed as the pointwise L2 norm of the
#@gmic : pixel values. Otherwise, the elevation map is taken from the specified image or formula.
#@gmic : $ image.jpg -blur 5 -elevation3d 0.5
#@gmic : $ 128,128,1,3,?(255) -plasma 10,3 -blur 4 -sharpen 10000 -elevation3d[-1] 'X=(x-64)/6;Y=(y-64)/6;100*exp(-(X^2+Y^2)/30)*abs(cos(X)*sin(Y))'

#@gmic empty3d
#@gmic : Input empty 3d object.
#@gmic : $ -empty3d
empty3d :
  -e[^-1] "Input empty 3d object."
  -v - (67.5;73.5;109.5;103.5;51.5;100.5;0;0) -nm[-1] [3d\ empty] -v +

#@gmic extrude3d : _depth>0,_resolution>0,_smoothness[%]>=0
#@gmic : Generate extruded 3d object from selected binary XY-profiles.
#@gmic : Default values: 'depth=16', 'resolution=1024' and 'smoothness=0.5%'.
#@gmic : $ image.jpg -threshold 50% -extrude3d 16
extrude3d : -check "${1=16}>0 && ${2=1024}>0 && ${3=0.5%}>=0"
  -e[^-1] "Generate extruded 3d object from XY-profile$?, with depth $1, resolution $2 and smoothness $3."
  -v - -norm -n 0,1 -autocrop 0 -repeat @# -l[$>] nm=@{0,n}
    wr={round(max(1,if(w>h,min($2,w),min($2,h)*w/h)))}
    hr={round(max(1,if(w>h,min($2,w)*h/w,min($2,h))))}
    fact={$1/max(w/$wr,h/$hr)}
    -b $3,0 -r $wr,$hr,1,1,2 -expand_xyz 1,0
    -isosurface3d 50% -*3d 1,1,$fact -rv3d
  -nm $nm,1 -endl -done -v +

#@gmic f3d : eq. to '-focale3d'. : (+)

#@gmic focale3d : focale : (+)
#@gmic : Set 3d focale.
#@gmic : (eq. to '-f3d').
#@gmic : Set 'focale' to 0 to enable parallel projection (instead of perspective).
#@gmic : Set negative 'focale' will disable 3d sprite zooming.
#@gmic : Default value: 'focale=700'.
#@gmic : $ -repeat 5 -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -focale3d {$<*90} -snapshot3d[-1] 400 -done -remove[0]

#@gmic gaussians3d : _size>0,_opacity
#@gmic : Convert selected 3d objects into set of 3d gaussian-shaped sprites.
#@gmic : $ image.jpg -r2dy 32 -distribution3d -gaussians3d 20 -colorcube3d -primitives3d[-1] 1 -+3d
gaussians3d : -check "${1=32}>0" -skip ${2=0.3}
  -e[^-1] "Convert 3d object$? into sets of gaussian-shaped 3d sprites, with size $1 and opacity $2."
  -v - -p3d 2 -p3d 0 -repeat @# -l[$>] nm=@{0,n} -s3d
    nbv={h} -rm[-1] (-128;$1;$1;1)
    $1,$1 -gaussian[-1] 35%,35%,0 -c[-1] 30%,100% -n[-1] 0,$2 -y[-1] -a[-2,-1] y  # First opacity is generated.
    -if {$nbv>1} 4,{$nbv-1},1,1,-128,0,0,0 -y[-2,-1] -a[-2,-1] y -endif           # Other ones are shared copies of the first one.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic gmic3d
#@gmic : Input a 3d G'MIC logo.
#@gmic : $ -gmic3d --primitives3d 1
gmic3d :
  -e[^-1] "Input 3d G'MIC logo."
  -v -
  -text3d G,60,20,2 -col3d[-1] 16,64,255
  -text3d \',60,20,2 -+3d[-1] 30 -col3d[-1] 64,128,255
  -text3d M,60,20,2 -+3d[-1] 40 -col3d[-1] 96,196,255
  -text3d I,60,20,2 -+3d[-1] 70 -col3d[-1] 64,128,255
  -text3d C,60,20,2 -+3d[-1] 95 -col3d[-1] 16,64,255
  -sphere3d 8 -+3d[-1] 85,-10,15 -col3d[-1] 192,128,255
  -+3d[-6--1] -c3d[-1]
  -repeat 30
    -box3d {min(3+@{<,-1}/2,10)} -col3d[-1] {30*$>},{20+80*$>},{10*$>},0.5
    -r3d[-1] 1,1,1,{$>*12}
    -+3d[-1] {80*cos(0.5+1.02*$>*12*pi/180)},{30*sin(0.8+$>*12*pi/180)},{2*$>-75}
  -done
  -+3d[-30--1] -+3d[-1] 0,5,30 -+3d[-2--1] -nm[-1] [3d\ gmic]
  -v +

#@gmic gyroid3d : _resolution>0,_zoom
#@gmic : Input 3d gyroid at (0,0,0), with specified resolution.
#@gmic : Default values: 'resolution=32' and 'zoom=5'.
#@gmic : $ -gyroid3d 48 --primitives3d 1
gyroid3d : -check ${1=32}>0 -skip ${2=5}
  -e[^-1] "Input 3d gyroid, with resolution $1 and range $2."
  -v -
  -isosurface3d "'0.49*(\
    cos( 2*x + y + z - pi) + cos( 2*x - y + z - pi)\
    + cos(- 2*x + y - z - pi) + cos(- 2*x - y - z - pi)\
    + cos( x + 2*y + z - pi) + cos( x + 2*y - z - pi)\
    + cos(- x - 2*y + z - pi) + cos(- x - 2*y - z - pi)\
    + cos( x + y + 2*z - pi) + cos(- x + y + 2*z - pi)\
    + cos( x - y - 2*z - pi) + cos(- x - y - 2*z - pi)\
    + cos(- 2*x + y + z) + cos( 2*x + y - z)\
    + cos(- 2*x - y + z) + cos( 2*x - y - z)\
    + cos(- x + 2*y + z) + cos( x - 2*y + z)\
    + cos(- x + 2*y - z) + cos( x - 2*y - z)\
    + cos( x - y + 2*z) + cos( x + y - 2*z)\
    + cos(- x - y + 2*z) + cos(- x + y - 2*z)\
    ) + 0.27*( \
    cos(- 2*x + 2*y - pi) + cos( 2*x - 2*y - pi)\
    + cos( 2*x + 2*y - pi) + cos(- 2*x - 2*y - pi)\
    + cos(- 2*y + 2*z - pi) + cos( 2*y - 2*z - pi)\
    + cos( 2*y + 2*z - pi) + cos(- 2*y - 2*z - pi)\
    + cos(- 2*z + 2*x - pi) + cos( 2*z - 2*x - pi)\
    + cos( 2*z + 2*x - pi) + cos(- 2*z - 2*x - pi)\
    ) - 0.69'",0,{-$2},{-$2},{-$2},$2,$2,$2,$1,$1,$1
  -c3d[-1] -n3d[-1] -nm[-1] [3d\ gyroid]
  -v +

#@gmic histogram3d
#@gmic : Get 3d color histogram of selected images.
#@gmic : $ image.jpg -histogram3d -colorcube3d -primitives3d[-1] 1 -add3d
histogram3d :
  -e[^-1] "Get 3d color histogram of image$?."
  -v - -to_rgb -repeat @# -l[$>]
    -r {w*h},3,1,1,-1 -pointcloud 1 -n 0,255 -map 3 -pointcloud3d -nm "[3d histogram]"
  -endl -done -v +

#@gmic image6cube3d
#@gmic : Generate 3d mapped cubes from 6-sets of selected images.
#@gmic : $ image.jpg -animate flower,"30,0","30,5",6 -image6cube3d
image6cube3d :
  -e[^-1] "Generate 3d mapped cubes from image$?."
  -v - M={max(@{-max_wh})} -r $M,$M,1,3 -imageplane3d -n3d -c3d -repeat {int(@#/6)}
    -+3d[-6] 0,0,-0.5
    -r3d[-5] 1,0,0,180 -+3d[-5] 0,0,0.5
    -r3d[-4] 0,1,0,-90 -+3d[-4] -0.5,0,0
    -r3d[-3] 0,1,0,90 -+3d[-3] 0.5,0,0
    -r3d[-2] 1,0,0,90 -+3d[-2] 0,-0.5,0
    -r3d[-1] 1,0,0,-90 -+3d[-1] 0,0.5,0
    -+3d[-6--1] -nm[-1] "[3d image cube]"
  -mv[-1] 0 -done -v +

#@gmic imagecube3d
#@gmic : Generate 3d mapped cubes from selected images.
#@gmic : $ image.jpg -imagecube3d
imagecube3d :
  -e[^-1] "Generate 3d mapped cubes from image$?."
  -v - -slices 50% -to_rgb -repeat @# -l[$>] nm=@{0,n}
    w1={w-1} h1={h-1}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
            8;6;\                               # Number of vertices and primitives.
            -0.5;-0.5;-0.5;\                    # Vertex coordinates.
            0.5;-0.5;-0.5;\
            0.5;0.5;-0.5;\
            -0.5;0.5;-0.5;\
            -0.5;-0.5;0.5;\
            0.5;-0.5;0.5;\
            0.5;0.5;0.5;\
            -0.5;0.5;0.5;\
            12;0;3;2;1;0;0;0;$h1;$w1;$h1;$w1;0;\    # Primitives description.
            12;1;2;6;5;0;0;0;$h1;$w1;$h1;$w1;0;\
            12;5;6;7;4;0;0;0;$h1;$w1;$h1;$w1;0;\
            12;4;7;3;0;0;0;0;$h1;$w1;$h1;$w1;0;\
            12;4;0;1;5;0;0;0;$h1;$w1;$h1;$w1;0;\
            12;3;7;6;2;0;0;0;$h1;$w1;$h1;$w1;0;\
            -128;{w};{h};{s})       # Texture map for the first face.
    -y[-1]
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1;1)  # Other faces and opacities.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic imageplane3d
#@gmic : Generate 3d mapped planes from selected images.
#@gmic : $ image.jpg -imageplane3d
imageplane3d :
  -e[^-1] "Generate 3d mapped planes from image$?."
  -v - -slices 50% -to_rgb -repeat @# -l[$>] nm=@{0,n}
    w1={w-1} h1={h-1}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\   # Magick number for CImg3d.
            4;1;\                                # Number of vertices and primitives.
            0;0;0;\                              # Vertex coordinates.
            {w};0;0;\
            {w};{h};0;\
            {0};{h};0;\
            12;0;3;2;1;0;0;0;$h1;$w1;$h1;$w1;0;\ # Primitives description.
            -128;{w};{h};{s})                    # Texture map.
    -y[-1]
    (1)  # Opacity.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic imagepyramid3d
#@gmic : Generate 3d mapped pyramides from selected images.
#@gmic : $ image.jpg -imagepyramid3d
imagepyramid3d :
  -e[^-1] "Generate 3d mapped pyramids from image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    w1={w-1} h1={h-1} w2={w/2}
    -i[-2] (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
            5;5;\                               # Number of vertices and primitives.
            -0.5;-0.5;-0.5;\                    # Vertex coordinates.
            0.5;-0.5;-0.5;\
            0.5;0.5;-0.5;\
            -0.5;0.5;-0.5;\
            0;0;0.5;\
            12;0;3;2;1;0;0;0;$h1;$w1;$h1;$w1;0;\    # Primitives description.
            9;0;4;3;0;$h1;$w2;0;$w1;$h1;\
            9;1;4;0;0;$h1;$w2;0;$w1;$h1;\
            9;2;4;1;0;$h1;$w2;0;$w1;$h1;\
            9;3;4;2;0;$h1;$w2;0;$w1;$h1;\
            -128;{w};{h};{s})                   # Texture map for the first face.
    -y[-1]
    (-128;0;0;0;-128;0;0;0;-128;0;0;0;-128;0;0;0;1;1;1;1;1)  # Other faces and opacities.
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic imagerubik3d : _xy_tiles>=1,0<=xy_shift<=100,0<=z_shift<=100
#@gmic : Generate 3d mapped rubik's cubes from selected images.
#@gmic : Default values: 'xy_tiles=3', 'xy_shift=5' and 'z_shift=5'.
#@gmic : $ image.jpg -imagerubik3d ,
imagerubik3d : -check "${1=3}>=1 && ${2=5}>=0 && $2<=100 && ${3=5}>=0 && $3<=100"
  -e[^-1] "Generate 3d mapped rubik's cubes from image$? with $1 xy-tiles, xy-shift $2 and z-shift $3."
  -v - -repeat @# -l[$>] nm=@{0,n}
    # Generate primary 3d side.
    ({'CImg3d'}) -+[-1] 0.5
    (8,5)
    (0,0,0;\
     100,0,0;\
     100,100,0;\
     0,100,0;\
     $2,$2,{-$3};\
     {100-$2},$2,{-$3};\
     {100-$2},{100-$2},{-$3};\
     $2,{100-$2},{-$3})
    (4,4,7,6,5;\
     4,0,4,5,1;\
     4,3,2,6,7;\
     4,0,3,7,4;\
     4,1,5,6,2)
    3,5,1,1,200
    1,5,1,1,1
    -y[-6--1] -a[-6--1] y
    -repeat {$1-1} --+3d[-1] 100 -done -+3d[-$1--1]   # Duplicate along X
    -repeat {$1-1} --+3d[-1] 0,100 -done -+3d[-$1--1] # Duplicate along Y
    -t3d[-1] [-2] -rm[-2]
    -/3d[-1] $1 --3d[-1] 50,50,50
    --r3d[-1] 0,1,0,-90 --r3d[-1] 0,1,0,-90 --r3d[-1] 0,1,0,-90  # Generate the 5 other sides.
    --r3d[-1] 0,0,1,-90 --r3d[-1] 0,0,1,180
    -+3d
  -nm $nm,1 -endl -done -v +

#@gmic imagesphere3d : _resolution1>=3,_resolution2>=3
#@gmic : Generate 3d mapped sphere from selected images.
#@gmic : Default values: 'resolution1=32' and 'resolutions2=16'.
#@gmic : $ image.jpg -imagesphere3d 32,16
imagesphere3d : -check "${1=32}>=3 && ${2=16}>=3"
  -e[^-1] "Generate 3d mapped sphere from image$?, with resolutions ($1,$2)."
  -v - -to_rgb -repeat @# -l[$>] nm=@{0,n}

    # Generate object header.
    tw={w-1} th={h-1}                    # Maximum texture xy-coordinates.
    nbv={2+$1*($2-2)}                    # Number of vertices.
    nbp={$1*($2-1)}                      # Number of primitives.
    (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
     $nbv;$nbp)                          # Number of vertices and primitives.

    # Define sphere vertices.
    (0;0;1) (0;0;-1) (0,{2*pi};0,{2*pi}^0,0;{pi},{pi})
    -r[-1] {$1+1},$2,1,2,3 -z[-1] 0,1,{w-2},{h-2} -s[-1] c
    --sin[-1] --sin[-3] -*[-2,-1] --cos[-2] -sin[-3] -cos[-4] -*[-4,-3]
    -a[-3--1] c -permute[-1] cxyz -y[-1] -a[-3--1] y

    # Define sphere primitives (triangles and quadrangles).
    -repeat $1
      tx0={$>*$tw/$1} tx1={($>+1)*$tw/$1} ty1={$th/($2-1)}
      (9;0;{2+$>};{2+($>+1)%$1};{$tw/2};0;$tx0;$ty1;$tx1;$ty1) # Textured triangle from 1st pole.
      -repeat {$2-3}
        ty0=$ty1 ty1={($>+2)*$th/($2-1)} i0={2+$>*$1+@{>,-2}} i1={2+$>*$1+(@{>,-2}+1)%$1}
        (12;$i0;{$i0+$1};{$i1+$1};$i1;$tx0;$ty0;$tx0;$ty1;$tx1;$ty1;$tx1;$ty0) # Textured quadrangle.
      -done
      (9;1;{2+$1*($2-3)+($>+1)%$1};{2+$1*($2-3)+$>};{$tw/2};$th;$tx1;$ty1;$tx0;$ty1) # Textured triangle from 2nd pole.
    -done
    -a[-$nbp--1] y

    # Define sphere textures, opacities and generate object.
    -mv[-4] @# -i[-2] (-128;{w};{h};3) -y[-1] 1,{4*($nbp-1)},1,1,-128,0,0,0 1,$nbp,1,1,1 -a y
  -nm $nm,1 -endl -done -v +

#@gmic isoline3d : isovalue[%] : 'formula',value,_x0,_y0,_x1,_y1,_size_x>0[%],_size_y>0[%] : (+)
#@gmic : Extract 3d isolines with specified value from selected images or from specified formula.
#@gmic : Default values: 'x0=y0=-3', 'x1=y1=3' and 'size_x=size_y=256'.
#@gmic : $ image.jpg -blur 1 -isoline3d 50%
#@gmic : $ -isoline3d 'X=x-w/2;Y=y-h/2;(X^2+Y^2)%20',10,-10,-10,10,10

#@gmic isosurface3d : isovalue[%] : 'formula',value,_x0,_y0,_z0,_x1,_y1,_z1,_size_x>0[%],_size_y>0[%],_size_z>0[%] : (+)
#@gmic : Extract 3d isosurfaces with specified value from selected images or from specified formula.
#@gmic : Default values: 'x0=y0=z0=-3', 'x1=y1=z1=3' and 'size_x=size_y=size_z=32'.
#@gmic : $ image.jpg -resize2dy 128 -luminance -threshold 50% -expand_z 2,0 -blur 1 -isosurface3d 50% -mul3d 1,1,30
#@gmic : $ -isosurface3d 'x^2+y^2+abs(z)^abs(4*cos(x*y*z*3))',3

#@gmic label_points3d : _label_size>0,_opacity
#@gmic : Add a numbered label to all vertices of selected 3d objects.
#@gmic : Default values: 'label_size=13' and 'opacity=0.8'.
#@gmic : $ -torus3d 100,40,6,6 -label_points3d 24,1 -mode3d 1
label_points3d : -check ${1=13}>0 -skip ${2=0.8}
  -e[^-1] "Label vertices of 3d object$?."
  -v - -repeat @#
    --p3d[$>] 0 -l[-1] -s3d -rm[-3--1]
    nbp=@{-2,0} -=[-2] $nbp,0,1                                 # Set correct number of primitives
    (1,0;1,{$nbp-1}) -r[-1] 2,$nbp,1,1,3 -r[-1] 1,{2*h},1,1,-1  # Create new primitive data
    -repeat $nbp                                                # Create texture labels as primitive colors.
      0 -t[-1] $>,0,0,$1,1,255,255,255 -autocrop[-1] 0
      -i[-2] (-128;{w};{h};3) -y[-1]
    -done
    -repeat $nbp                                                # Create texture masks as primitive opacities.
      0 -t[-1] $>,0,0,$1,1,$2 -autocrop[-1] 0
      -i[-2] (-128;{w};{h};1) -y[-1]
    -done
    -a y  # Merge final object data.
    -endl
    -+3d[$>,-1]
  -done -v +

#@gmic lathe3d : _resolution>0,_smoothness[%]>=0,_max_angle>=0
#@gmic : Generate 3d object from selected binary XY-profiles.
#@gmic : Default values: 'resolution=128', 'smoothness=0.5%' and 'max_angle=361'.
#@gmic : $ 300,300 -rand -1,1 -blur 40 -sign -normalize 0,255 -lathe3d ,
lathe3d : -check "${1=128}>0 && ${2=0.5%}>=0 && ${3=361}>=0"
  -e[^-1] "Generate lathed 3d object from XY-profile$?, with resolution $1, smoothness $2 and maximum angle $3 deg."
  -v - tmax={($3-180)*pi/180} -norm -n 0,1 -autocrop 0 -repeat @# -l[$>]
    wr={max(1,w2=2*w;if(w2>h,min($1,w2),min($1,h)*w2/h))}
    hr={max(1,w2=2*w;if(w2>h,min($1,w2)*h/w2,min($1,h)))}
    rmax={sqrt(($wr)^2+($hr)^2)/2}
    $wr,1,$wr,1,"xc=x-w/2; zc=z-d/2; t=atan2(zc,xc); if(t>"$tmax","$rmax",sqrt(xc*xc+zc*zc))"
    -*[-1] {2*(@{-2,w}-1)/(w-1)} -r[-1] $wr,$hr,$wr
    (0;{@{-2,h}-1}) -r[-1] $wr,$hr,$wr,1,3 -a[-2--1] c
    -warp[-2] [-1],0,1,0 -rm[-1]
    -expand_xyz 10,0 -b $2 -isosurface3d 50% -rv3d
  -endl -done -v +

#@gmic l3d : eq. to '-light3d'. : (+)

#@gmic light3d : position_x,position_y,position_z : [texture] : (no args) : (+)
#@gmic : Set the light coordinates or the light texture for 3d rendering.
#@gmic : (eq. to '-l3d').
#@gmic : (noargs) resets the 3d light to default.
#@gmic : $ -torus3d 100,30 -double3d 0 -specs3d 1.2 -repeat 5 -light3d {$>*100},0,-300 --snapshot3d[0] 400 -done -remove[0]

#@gmic line3d : x0,y0,z0,x1,y1,z1
#@gmic : Input 3d line at specified coordinates.
#@gmic : $ -repeat 100 a={$>*pi/50} -line3d 0,0,0,{cos(3*$a)},{sin(2*$a)},0 -color3d[-1] @{-RGB} -done -add3d
line3d :
  -e[^-1] "Input 3d line (${1-3})-(${4-6})."
  -v - 1,21,1,1,67.5,73.5,109.5,103.5,51.5,100.5,2,1,${1-6},2,0,1,200,200,200,1 -nm[-1] [3d\ line] -v +

#@gmic lissajous3d : resolution>1,a,A,b,B,c,C
#@gmic : Input 3d lissajous curves (x(t)=sin(a*t+A*2*pi),y(t)=sin(b*t+B*2*pi),z(t)=sin(c*t+C*2*pi)).
#@gmic : Default values: 'resolution=1024', 'a=2', 'A=0', 'b=1', 'B=0', 'c=0' and 'C=0'.
#@gmic : $ -lissajous3d ,
lissajous3d : -check ${1=1024}>1 -skip ${2=2},${3=0},${4=1},${5=0},${6=0},${7=0}
  -e[^-1] "Input 3d lissajous curve, with resolution $1, (a,A)=($2,$3), (b,B)=($4,$5) and (c,C)=($6,$7)."
  -v -
  res={round($1)}

  # Define object header and vertices.
  (67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
  (0,{2*pi}) -r[-1] $res,1,1,1,3 [-1]x2
  -*[-3] $2 -+[-3] {$3*2*pi} -*[-2] $4 -+[-2] {$5*2*pi} -*[-1] $6 -+[-1] {$7*2*pi}
  -a[-3--1] y -sin[-1] -transpose[-1] -r[-1] 1,{w*h},1,1,-1

  # Define object primitives, colors and opacities.
  1,{$res-1},1,1,2 (0;{$res-2}) -r[-1] 1,{$res-1},1,1,3 --+[-1] 1 -a[-3--1] x -round[-1] 1 -r[-1] 1,{w*h},1,1,-1
  1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 -a[-5--1] y -nm[-1] [3d\ lissajou]
  -v +

#@gmic m3d : eq. to '-mode3d'. : (+)

#@gmic mode3d : _mode : (+)
#@gmic : Set static 3d rendering mode.
#@gmic : (eq. to '-m3d').
#@gmic : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.");
#@gmic : Bounding-box mode ('mode==-1') is active only for the interactive 3d viewer.
#@gmic : Default value: 'mode=4'.
#@gmic : $ (0,1,2,3,4,5) -double3d 0 -repeat {w} -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -mode3d @{0,$>} -snapshot3d[-1] 300 -done -remove[0]

#@gmic md3d : eq. to '-moded3d'. : (+)

#@gmic moded3d : _mode : (+)
#@gmic : Set dynamic 3d rendering mode for interactive 3d viewer.
#@gmic : (eq. to '-md3d').
#@gmic : 'mode' can be { -1=bounding-box | 0=dots | 1=wireframe | 2=flat | 3=flat-shaded | 4=gouraud-shaded | 5=phong-shaded }.
#@gmic : Default value: 'mode=-1'.

#@gmic *3d : eq. to '-mul3d'. : (+)

#@gmic mul3d : factor : factor_x,factor_y,_factor_z : (+)
#@gmic : Scale selected 3d objects isotropically or anisotropically, with specified factors.
#@gmic : (eq. to '-*3d').
#@gmic : Default value: 'factor_z=0'.
#@gmic : $ -torus3d 5,2 -repeat 5 --add3d[-1] 10,0,0 -mul3d[-1] 1.2 -color3d[-1] @{-RGB} -done -add3d

#@gmic n3d : eq. to '-normalize3d'.
n3d :
  -_normalize3d

#@gmic normalize3d
#@gmic : Normalize selected 3d objects to unit size.
#@gmic : (eq. to '-n3d').
#@gmic : $ -repeat 100 -circle3d {?(3)},{?(3)},{?(3)},0.1 -done -add3d -color3d[-1] 255,0,0 --normalize3d[-1] -color3d[-1] 0,255,0 -add3d
normalize3d :
  -_$0

_normalize3d :
  -e[0--3] "Normalize size of 3d object$?."
  -v - -check3d 0 -repeat @# -l[$>]
    n={i[6]}
    -if {$n>0}
      -sh 8,{7+3*$n},0,0 -r[-1] 3,{h/3},1,1,-1 -s[-1] x
      -sh[-4] 8,{7+3*$n},0,0 -/[-1] {val=max(@{-3,iM}-@{-3,im},@{-2,iM}-@{-2,im},iM-im);if(val,val,1)}
      -rm[-4--1]
    -endif
  -nm @{0,n},1 -endl -done -v +

#@gmic o3d : eq. to '-opacity3d'. : (+)

#@gmic opacity3d : _opacity : (+)
#@gmic : Set opacity of selected 3d objects.
#@gmic : (eq. to '-o3d').
#@gmic : Default value: 'opacity=1'.
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d[-1] 1,0,0,20 -opacity3d[-1] {?} -done -add3d

#@gmic parametric3d : _x(a,b),_y(a,b),_z(a,b),_amin,_amax,_bmin,_bmax,_res_a>0,_res_b>0,_res_x>0,_res_y>0,_res_z>0,_smoothness>=0,_isovalue>=0
#@gmic : Input 3d object from specified parametric surface (x(a,b),y(a,b),z(a,b)).
#@gmic : Default values: 'x=(2+cos(b))*sin(a)', 'y=(2+cos(b))*cos(a)', 'c=sin(b)', 'amin=-pi', 'amax='pi', 'bmin=-pi', 'bmax='pi',
#@gmic : 'res_a=512', 'res_b=res_a', 'res_x=64', 'res_y=res_x', 'res_z=res_y', 'smoothness=2%' and 'isovalue=10%'.
#@gmic : $ -parametric3d ,
parametric3d : -skip "${1=(2+cos(b))*sin(a)}","${2=(2+cos(b))*cos(a)}","${3=sin(b)}"
               -skip ${4={-pi}},${5={pi}},${6={-pi}},${7={pi}}
               -check "${8=512}>0 && ${9=$8}>0 && ${10=64}>0 && ${11=$10}>0 && ${12=$11}>0 && \
                       ${13=2%}>=0 && ${14=10%}>=0"
  -e[^-1] "Input 3d object from parametric surface ($1,$2,$3)."
  -v -
  # Compute (x(a,b),y(a,b),z(a,b)) and normalize it.
  ($4,$5;$4,$5^$6,$6;$7,$7) -r[-1] $8,$9,1,2,3 -channels[-1] 0,2
  -f[-1] "a=i(x,y,0,0);b=i(x,y,0,1);if(c==0,$1,if(c==1,$2,$3))"
  -sh[-1] 0,0 xmin={im} xmax={iM} -n[-1] 16,{$10-17} -rm[-1]
  -sh[-1] 1,1 ymin={im} ymax={iM} -n[-1] 16,{$11-17} -rm[-1]
  -sh[-1] 2,2 zmin={im} zmax={iM} -n[-1] 16,{$12-17} -rm[-1]
  -r[-1] {w*h},3,1,1,-1

  # Extract 3d surface.
  -pointcloud[-1] 1 -r[-1] $10,$11,$12,1,0 -b[-1] $13,0
  -isosurface3d[-1] $14
  -c3d[-1] -n3d[-1] -*3d[-1] {$xmax-$xmin},{$ymax-$ymin},{$zmax-$zmin} -nm[-1] [3d\ parametric]
  -v +

#@gmic pca_patch3d : _patch_size>0,_M>0,_N>0,_normalize_input={ 0 | 1 },_normalize_output={ 0 | 1 },_lambda_xy
#@gmic : Get 3d patch-pca representation of selected images.
#@gmic : The 3d patch-pca is estimated from M patches on the input image, and displayed as a cloud of N 3d points.
#@gmic : Default values: 'patch_size=7', 'M=1000', 'N=3000', 'normalize_input=1', 'normalize_output=0', and 'lambda_xy=0'.
#@gmic : $ image.jpg -pca_patch3d 7
pca_patch3d : -check "isint(${1=7}) && $1>0 && isint(${2=1000}) && $2>0 && isint(${3=3000}) && $3>0" -skip ${4=1},${5=0},${6=0}
  -e[^-1] "Get 3d patch-pca representation"@{-arg\ 1+(@#>1),s,""}" of image$?, from $2 $1x$1 input patchs,
           with $3 output patchs, input normalization "@{-arg\ 1+!$4,enabled,disabled}", output normalization
          "@{-arg\ 1+!$5,enabled,disabled}" and lambda_xy $6."
  -v -
  P1={int($1/2)}       # Backward half-patch size.
  P2={$1-$P1-1}        # Forward half-patch size.

  -n 0,255 -round 1
  -repeat @# -l[$>] nm=@{0,n}
    s={s}

    # Pick set of M random located patchs.
    1,$2 -rand[-1] 0,@{0,w-1} --rand[-1] 0,@{0,h-1} --f[-1] 0 -a[-3--1] x -round[-1] 1 --patches[0] $1,$1,1,@-1 -y[2--1] -a[2--1] x
    -z[1] 0,1 -transpose[1] -*[1] $6 -a[1,2] y -s[^0] x

    # Normalize patch coordinates by using average and standard deviation.
    --+[^0] -/[-1] $2 --[1--2] [-1] -rm[-1]
    -a[^0] x
    -if $4 -l[-1] -s y -/ 'sqrt(1e-8+iv)' -a y -endl -endif

    # Do PCA for dimension reduction.
    --transpose[-1] -**[-2,-1]
    -eigen[-1] -rows[-2] 0,2 -columns[-1] 0,2 -transpose[-1]
    -if $5 -sqrt[-2] -/[-2] @{-2,M} -r[-2] [-1] -/[-1] [-2] -endif
    -rm[-2]

    # Pick set of N random located patchs.
    -repeat $3
      x={round(?(@{0,w}))}
      y={round(?(@{0,h}))}
      ({$6*$x};{$6*$y})
      --z[0] {$x-$P1},{$y-$P1},{$x+$P2},{$y+$P2},1
      -y[-1] -a[-2,-1] y
    -done

    # Generate 3d representation of the projected patch set.
    --a[2--1] x -**[1,-1] -transpose[1]                    # Vertex coordinates.
    -rows[2--1] 2,100%                                     # Colors
    -if {$s!=3}
      -r[2--1] $1,$1,1,{min(3,$s)},-1
      -r[2--1] $1,$1,1,3,{if($s!=1,0,1)}
      -y[2--1]
    -endif
    -i[2--2] (-128;$1;$1;3) -a[2--1] y
    -rm[0]                                                 # Remove input image (now useless).
    -i[0] ({'CImg3d'})                                     # Header.
    -i[1] ($3;$3)                                          # Geometry.
    -i[3] 2,$3,1,1,if(x==0,1,y)                            # Primitives.
    1,$3,1,1,1                                             # Opacities.
    -y -a[-6--1] y                                         # Merge as a 3d object.

  -nm $nm,1 -endl -done -v +

#@gmic plane3d : _size_x,_size_y,_nb_subdivisions_x>0,_nb_subdisivions_y>0
#@gmic : Input 3d plane at (0,0,0), with specified geometry.
#@gmic : Default values: 'size_x=1', 'size_y=size_x' and 'nb_subdivisions_x=nb_subdivisions_y=24'.
#@gmic : $ -plane3d 50,30 --primitives3d 1 -color3d[-2] @{-RGB}
plane3d : -check "${3=24}>0 && ${4=24}>0" -skip ${1=1},${2=$1}
  -e[^-1] "Input 3d plane, with size (${1,2}) and subdivisions (${3,4})."
  -v - {$3+1},{$4+1} -elevation3d[-1] 0 -*3d[-1] {$1/$3},{$2/$4} -col3d[-1] 200 -nm[-1] [3d\ plane] -v +

#@gmic point3d : x0,y0,z0
#@gmic : Input 3d point at specified coordinates.
#@gmic : $ -repeat 1000 a={$>*pi/500} -point3d {cos(3*$a)},{sin(2*$a)},0 -color3d[-1] @{-RGB} -done -add3d
point3d :
  -e[^-1] "Input 3d point ($1,$2,$3)."
  -v - 1,17,1,1,67.5,73.5,109.5,103.5,51.5,100.5,1,1,${1-3},1,0,200,200,200,1 -nm[-1] [3d\ point] -v +

#@gmic pointcloud3d
#@gmic : Convert selected planar or volumetric images to 3d point clouds.
#@gmic : $ image.jpg -luminance -resize2dy 100 -threshold 50% -* 255 -pointcloud3d -color3d[-1] 255,255,255
pointcloud3d :
  -e[^-1] "Convert image$? to 3d point clouds."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -s z -repeat @# -l[$>]
      --norm -!=[-1] 0
      -i[-2] (1,{w};1,{w}^1,1;{h},{h}) -r[-2] [-1],[-1],1,2,3 -*[-2,-1] -round[-1] -permute[-1] cxyz
      -l[-1] -s -,0 -a y is_points=@# -endl
      -if $is_points
        --[-1] 1 -r[-1] 2,{h/2},1,1,-1 -permute[-1] cyzx --warp[-2] [-1],0,0 -rm[-3]
        -permute[-2] cyzx -i[-2] 1,{h},1,1,$> -a[-3,-2] x    # Coordinates.
        -i[-3] ({'CImg3d'}) -i[-3] ({h},{h})                 # Header and size.
        -i[-2] 1,{h},1,1,1 -i[-2] 1,{h},1,1,y -a[-3,-2] x    # Primitives.
        -permute[-1] cyzx                                    # Colors.
        -if {w==1} -r[-1] 3,{h},1,1
        -elif {w>3} -i[-2] 4,{h},1,1,-128,1,1,{w} -a[-2,-1] x
        -else -r[-1] 3,{h},1,1,0
        -endif
        1,{h},1,1,1                                          # Opacities.
        -y[-6--1] -a[-6--1] y
      -else -rm -empty3d
      -endif
      -endl -done
    -+3d
  -nm $nm,1 -endl -done -v +

#@gmic pose3d : value1,..,value16 : (noargs) : (+)
#@gmic : Set the coefficients of the 3d pose matrix.
#@gmic : (noargs) resets the 3d pose matrix to default.

#@gmic p3d : eq. to '-primitives3d'. : (+)

#@gmic primitives3d : mode : (+)
#@gmic : Convert primitives of selected 3d objects.
#@gmic : (eq. to '-p3d').
#@gmic : 'mode' can be { 0=points | 1=segments | 2=non-textured }.
#@gmic : $ -sphere3d 30 -primitives3d 1 -torus3d 50,10 -color3d[-1] @{-RGB} -add3d

#@gmic projections3d : _x[%],_y[%],_z[%],_is_bounding_box={ 0 | 1 }
#@gmic : Generate 3d xy,xz,yz projection planes from specified volumetric images.
projections3d : -skip ${1=50%},${2=50%},${3=50%},${4=1}
  -e[^-1] "Generate 3d xy,xz,yz projection planes from image$?."
  -v - -n 0,255 -repeat @# -l[$>]
    w={w} h={h} d={d}
    x={if(@{-is_percent\ $1},$1*w,$1)}
    y={if(@{-is_percent\ $2},$2*h,$2)}
    z={if(@{-is_percent\ $3},$3*d,$3)}
    --rows $2,$2 -r[-1] {w},{d},1,100%,-1
    --columns[-2] $1,$1 -permute[-1] zyxc
    -slices[-3] $3,$3 -r[-3--1] 100%,100%,1,3
    -imageplane3d[-3--1]
    -r3d[-1] 0,1,0,90 -r3d[-2] 1,0,0,-90
    -+3d[-3] 0,0,$z -+3d[-2] 0,$y,0 -+3d[-1] $x,0,0
    -+3d[-3--1] -o3d[-1] 0.8
    -if $4 -box3d $w,$h,$d -p3d[-1] 1 -o3d[-1] 0.4 -+3d[-2,-1] -endif
  -endl -done -v +

#@gmic pyramid3d : width,height
#@gmic : Input 3d pyramid at (0,0,0), with specified geometry.
#@gmic : $ -pyramid3d 100,100 --primitives3d 1 -color3d[-2] @{-RGB}
pyramid3d :
  -e[^-1] "Input new 3d pyramid, with width $1 and height $2."
  -v -
  (67.5;73.5;109.5;103.5;51.5;100.5;\  # Magick number for CImg3d.
   5;5;\                               # Number of vertices and primitives.
   {-$1/2};{-$1/2};{-$2/2};\           # Vertex coordinates.
   {$1/2};{-$1/2};{-$2/2};\
   {$1/2};{$1/2};{-$2/2};\
   {-$1/2};{$1/2};{-$2/2};\
   0;0;{$2/2};\
   4;0;3;2;1;\                         # Primitives description.
   3;0;4;3;\
   3;1;4;0;\
   3;2;4;1;\
   3;3;4;2)
  1,15,1,1,200 1,5,1,1,1 -a[-3--1] y -nm[-1] [3d\ pyramid]
  -v +

#@gmic quadrangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3
#@gmic : Input 3d quadrangle at specified coordinates.
#@gmic : $ -quadrangle3d -10,-10,10,10,-10,10,10,10,10,-10,10,10 -repeat 10 --rotate3d[-1] 0,1,0,30 -color3d[-1] @{-RGB},0.6 -done -add3d -mode3d 2
quadrangle3d :
  -e[^-1] "Input 3d quadrangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)-($10,$11,$12)."
  -v - 1,29,1,1,67.5,73.5,109.5,103.5,51.5,100.5,4,1,${1-12},4,0,1,2,3,200,200,200,1 -nm[-1] [3d\ quadrangle] -v +

#@gmic rv3d : eq. to '-reverse3d'. : (+)

#@gmic reverse3d : (+)
#@gmic : Reverse primitive orientations of selected 3d objects.
#@gmic : (eq. to '-rv3d').
#@gmic : $ -torus3d 100,40 -double3d 0 --reverse3d

#@gmic r3d : eq. to '-rotate3d'. : (+)

#@gmic rotate3d : u,v,w,angle : (+)
#@gmic : Rotate selected 3d objects around specified axis with specified angle (in deg.).
#@gmic : (eq. to '-r3d').
#@gmic : $ -torus3d 100,10 -double3d 0 -repeat 7 --rotate3d[-1] 1,0,0,20 -done -add3d

#@gmic rotation3d : u,v,w,angle
#@gmic : Input 3x3 rotation matrix with specified axis and angle (in deg).
#@gmic : $ -rotation3d 1,0,0,0 -rotation3d 1,0,0,90 -rotation3d 1,0,0,180
rotation3d :
  -e[^-1] "Input 3d rotation matrix around axis ($1,$2,$3) with angle $4 deg."
  -v -
  ($1^$2^$3^0) -orientation[-1] -y[-1] x -*[-1] {sin($4*pi/360)} -=[-1] {cos($4*pi/360)},3
  xx={i(0)*i(0)} xy={i(0)*i(1)} xz={i(0)*i(2)} xw={i(0)*i(3)}
  yy={i(1)*i(1)} yz={i(1)*i(2)} yw={i(1)*i(3)}
  zz={i(2)*i(2)} zw={i(2)*i(3)}
  -rm[-1]
  ({1-2*($yy+$zz)},{2*($xy+$zw)},{2*($xz-$yw)};\
   {2*($xy-$zw)},{1-2*($xx+$zz)},{2*($yz+$xw)};\
   {2*($xz+$yw)},{2*($yz-$xw)},{1-2*($xx+$yy)})
  -nm[-1] [3d\ rotation]
  -v +

#@gmic sierpinski3d : _recursion_level>=0,_width,_height
#@gmic : Input 3d Sierpinski pyramid.
#@gmic : $ -sierpinski3d 3 --primitives3d 1 -color3d[-2] @{-RGB}
sierpinski3d : -check ${1=4}>=0 -skip ${2=1},${3=1}
-e[^-1] "Input 3d Sierpinski pyramid of degree $1, with width $2 and height $3."
  -v - -l[] -_sierpinski3d {-$2/2},{-$2/2},{-$3/2},{$2/2},{-$2/2},{-$3/2},{$2/2},{$2/2},{-$3/2},{-$2/2},{$2/2},{-$3/2},0,0,{$3/2},$1 -+3d -endl
  -nm[-1] [3d\ sierpinski] -v +

_sierpinski3d :
  -if {$16<=0}
    (67.5;73.5;109.5;103.5;51.5;100.5;\
     5;5;\
     $1;$2;$3;\
     $4;$5;$6;\
     $7;$8;$9;\
     $10;$11;$12;\
     $13;$14;$15;\
     4;0;3;2;1;\
     3;0;4;3;\
     3;1;4;0;\
     3;2;4;1;\
     3;3;4;2)
    1,15,1,1,200 1,5,1,1,1 -a[-3--1] y
  -return -endif
  -_sierpinski3d $1,$2,$3,\
                 {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
                 {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$4)/2},{($2+$5)/2},{($3+$6)/2},\
                 $4,$5,$6,\
                 {($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($4+$7)/2},{($5+$8)/2},{($6+$9)/2},\
                 $7,$8,$9,\
                 {($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
                 {($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$10)/2},{($2+$11)/2},{($3+$12)/2},\
                 {($1+$4+$7+$10)/4},{($2+$5+$8+$11)/4},{($3+$6+$9+$12)/4},\
                 {($7+$10)/2},{($8+$11)/2},{($9+$12)/2},\
                 $10,$11,$12,\
                 {($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
                 {$16-1}
  -_sierpinski3d {($1+$13)/2},{($2+$14)/2},{($3+$15)/2},\
                 {($4+$13)/2},{($5+$14)/2},{($6+$15)/2},\
                 {($7+$13)/2},{($8+$14)/2},{($9+$15)/2},\
                 {($10+$13)/2},{($11+$14)/2},{($12+$15)/2},\
                 $13,$14,$15,\
                 {$16-1}

#@gmic snapshot3d : _size>0,_zoom>=0,_backgroundR,_backgroundG,_backgroundB
#@gmic : Take 2d snapshots of selected 3d objects.
#@gmic : Set 'zoom' to 0 to disable object auto-scaling.
#@gmic : Default values: 'size=512', 'zoom=1' and 'backgroundR=backgroundG=backgroundB=(undefined)'.
#@gmic : $ -torus3d 100,20 -snapshot3d 400,1.2,128,64,32
snapshot3d : -check "${1=512}>0 && ${2=1}>=0" -skip ${3=""}
  -if {narg($3)}
    -e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2 and background color ${3--1}."
  -else
    -e[0--3] "Take $1x$1 snapshot$? of 3d object$?, with zoom factor $2."
  -endif
  -v - -repeat @# -l[$>]
    -if {$2!=0} -c3d -n3d -*3d {3*$1*$2/4} -endif
    -if {narg($3)} (${3--1}) -y[-1] c -else 1,2,1,3,32,64,32,116,64,96 -endif -r[-1] $1,$1,1,3,3
    -object3d[-1] [-2],50%,50%,0,1 -nm[-1] @{-2,n},1 -rm[-2]
  -endl -done -v +

#@gmic sl3d : eq. to '-specl3d'. : (+)

#@gmic specl3d : value>=0 : (+)
#@gmic : Set lightness of 3d specular light.
#@gmic : (eq. to '-sl3d').
#@gmic : Default value: 'value=0.15'.
#@gmic : $ (0,0.3,0.6,0.9,1.2) -repeat {w} -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -color3d[-1] 255,0,0 -specl3d @{0,$>} -snapshot3d[-1] 400 -done -remove[0]

#@gmic ss3d : eq. to '-specs3d'. : (+)

#@gmic specs3d : value>=0 : (+)
#@gmic : Set shininess of 3d specular light.
#@gmic : (eq. to '-ss3d').
#@gmic : Default value: 'value=0.8'.
#@gmic : $ (0,0.3,0.6,0.9,1.2) -repeat {w} -torus3d 100,30 -rotate3d[-1] 1,1,0,60 -color3d[-1] 255,0,0 -specs3d @{0,$>} -snapshot3d[-1] 400 -done -remove[0]

#@gmic sphere3d : radius,_nb_recursions>=0 : (+)
#@gmic : Input 3d sphere at (0,0,0), with specified geometry.
#@gmic : Default value: 'nb_recursions=3'.
#@gmic : $ -sphere3d 100 --primitives3d 1  -color3d[-2] @{-RGB}

#@gmic spherical3d : _nb_azimuth>=3,_nb_zenith>=3,_radius_function(phi,theta)
#@gmic : Input 3d spherical object at (0,0,0), with specified geometry.
#@gmic : Default values: 'nb_zenith=nb_azimut=64' and 'radius_function="abs(1+0.5*cos(3*phi)*sin(4*theta))"'.
#@gmic : $ -spherical3d 64 --primitives3d 1
spherical3d : -check "${1=64}>=3 && ${2=$1}>=3" -skip "${3=abs(1+0.5*cos(3*phi)*sin(4*theta))}"
  -e[^-1] "Input 3d spherical object, with subdivisions ($1,$2) and height function '$3'."
  -v -
  ({'CImg3d'}) -y[-1] # Magic number.
  n1={round($1)} n2={round($2)}

  # Define 3d vertices.
  $n1,{$n2-1},1,3,"phi=2*pi*(x+0.5)/w;\
                   theta=-pi/2+pi*(y+0.5)/h;\
                   cp=cos(phi);\
                   sp=sin(phi);\
                   ct=cos(theta);\
                   ($3)*if(c==0,ct*cp,if(c==1,ct*sp,sin(theta)))"
  -r[-1] {w*h},3,1,1,-1 -permute[-1] yxzc
  -i[-2] (0,0,{phi=0;theta=-pi/2;-$3};0,0,{phi=0;theta=pi/2;$3}) -a[-2,-1] y  # Add the two poles.
  nbv={h} -y[-1]

  # Define 3d primitives.
  $n1,{$n2-2},1,4,"nx=(x+1)%w;ny=(y+1);2+if(c==0,x+y*"$n1",if(c==1,nx+y*"$n1",if(c==2,nx+ny*"$n1",x+ny*"$n1")))"
  -r[-1] {w*h},4,1,1,-1 -permute[-1] yxzc -i[-2] 1,{h},1,1,4 -a[-2,-1] x
  2,$n1,1,1,3,0 1,$n1,1,1,'y' --+[-1] 1 -%[-1] {h} 2,$n1,1,1,3,1 [-3,-2]  # Connect the two poles.
  -+[-5,-4] 2 -rv[-5,-4] -+[-2,-1] {$nbv-$n1} -a[-3--1] x -a[-4--2] x
  nbp={h+@{-2,h}+@{-3,h}}
  -y[-3--1] -a[-3--1] y

  # Define other object information (properties, colors and opacities).
  -i[-3] ($nbv;$nbp)
  1,{3*$nbp},1,1,200 1,$nbp,1,1,1 -a[-2,-1] y

  # Append as a 3d object.
  -a[-5--1] y -nm[-1] "[3d spherical surface '$3']"
  -v +

#@gmic spline3d : x0[%],y0[%],z0[%],u0[%],v0[%],w0[%],x1[%],y1[%],z1[%],u1[%],v1[%],w1[%],_nb_vertices>=2
#@gmic : Input 3d spline with specified geometry.
#@gmic : Default values: 'nb_vertices=128'.
#@gmic : $ -repeat 100 -spline3d {?},{?},{?},{?},{?},{?},{?},{?},{?},{?},{?},{?},128 -color3d[-1] @{-RGB} -done -box3d 1 -primitives3d[-1] 1 -+3d
spline3d : -check ${13=128}>=2
  -e[^-1] "Input new 3d spline from (${1-3}) [${4-6}] to (${7-9}) [${10-12}] with $13 vertices."
  -v -
  ({'CImg3d'}) -+[-1] 0.5   # Header.
  ($13;{$13-1})             # Nb vertices / primitives.
  # Define vertices.
  1,$13,1,1,1 (0;1) -r[-1] 1,$13,1,1,3 --sqr[-1] --*[-2,-1] -a[-4--1] x
  --*[-1] '$2,$5,{3*(($8)-($2))-2*($5)-($11)},{($5)+($11)+2*(($2)-($8))}' -l[-1] -s x -+ -endl
  --*[-2] '$3,$6,{3*(($9)-($3))-2*($6)-($12)},{($6)+($12)+2*(($3)-($9))}' -l[-1] -s x -+ -endl
  -*[-3] '$1,$4,{3*(($7)-($1))-2*($4)-($10)},{($4)+($10)+2*(($1)-($7))}' -l[-3] -s x -+ -endl
  -a[-3--1] x
  1,{$13-1},1,1,2 (0,1;{$13-2},{$13-1}) -r[-1] 2,[-2],1,1,3 -round[-1] -a[-2,-1] x # Primitives.
  1,{3*($13-1)},1,1,200 1,{$13-1},1,1,1 # Colors / opacities.
  -y[-3,-4,-6] -a[-6--1] y
  -v +

#@gmic s3d : eq. to '-split3d'. : (+)

#@gmic split3d : _keep_shared_data={ 0 | 1 } : (+)
#@gmic : Split selected 3d objects into 6 feature vectors :
#@gmic : { header, sizes, vertices, primitives, colors, opacities }.
#@gmic : (eq. to '-s3d').
#@gmic : To recreate the 3d object, append these 6 images along the y-axis.
#@gmic : Default value: 'keep_shared_data=1'.
#@gmic : $ -box3d 100 --split3d

#@gmic sprite3d
#@gmic : Convert selected images as 3d sprites.
#@gmic : Selected image with alpha channels are managed.
#@gmic : $ image.jpg -sprite3d
sprite3d :
  -e[^-1] "Convert image$? as 3d sprites."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -split_opacity
    -i[0] (67.5;73.5;109.5;103.5;51.5;100.5;1;1;0;0;0;1;0;-128;{w};{h};@{0,s}) -y[1]
    -if {@#==2} (1) -a y
    -else -/[-1] 255 -i[-2] (-128;{w};{h};{s}) -y[-1]
    -endif
    -a y
  -nm $nm,1 -endl -done -v +

#@gmic sprites3d
#@gmic : Convert selected 3d objects as sprites clouds, where the specified 2d sprite is the last selected image.
#@gmic : If the selected sprite has a 4th channel, it stands for the sprite alpha-channel (in [0,255]).
#@gmic : $ -torus3d 100,20 image.jpg -resize2dy[-1] 64 100%,100% -gaussian[-1] 30%,30% -*[-1] 255 -append[-2,-1] c --sprites3d -drgba[-2]
sprites3d :
  -e[^-1] "Convert image$? as 3d sprites clouds."
  -v - -repeat {@#-1}
    -if {!@{$>,(0,7)}} -continue -endif # Do nothing if 3d object is empty.
    [-1] -l[$>,-1]
    -s3d[0] N=@{1,0} -=[1] $N,0,1
    -rm[3-5] -i[3] (1,0;1,{$N-1}) -r[3] 2,$N,1,1,3 -round[3]
    -if {s==4}
      -s[-1] c,-3 -/[-1] 255
      -i[-3] (-128;{w};{h};3)
      -if {$N>1} -i[-2] 1,{4*($N-1)},1,1,-128,0,0,0 -endif
      -i[-2] (-128;{w};{h};1)
      -if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
    -else
      -i[-2] (-128;{w};{h};{s}) -y[-3,-1]
      -if {$N>1} 1,{4*($N-1)},1,1,-128,0,0,0 -endif
      1,$N,1,1,1
    -endif
    -y -a y
  -endl -done -rm[-1] -v +

#@gmic star3d : nb_branches>0,0<=thickness<=1
#@gmic : Input 3d star at (0,0,0), with specified geometry.
#@gmic : Default values: 'nb_branches=5' and 'thickness=0.38'.
#@gmic : $ -star3d , --primitives3d 1 -color3d[-2] @{-RGB}
star3d : -check "${1=5}>0 && ${2=0.38}>=0 && $2<=1"
  -e[^-1] "Input 3d star, with $1 branches and thickness $2."
  -v -
  N={2*$1} ({'CImg3d'}) -+[-1] 0.5 ({$N+1};$N)
  ({-pi/2};{3*pi/2}) -r[-1] 1,{$N+1},1,1,3 -rows[-1] 0,{h-2} --sin[-1] -cos[-2] -a[-2,-1] x
  (1,1;$2,$2) -*[-2,-1] -z[-1] 0,2 -r[-1] 3,{h+1},1,1,0
  (3,$N,1,0;3,$N,$N,{$N-1}) -r[-1] 4,$N,1,1,3 -=[-1] 0,2,100%
  3,$N,1,1,200 1,$N,1,1,1 -y[-6,-4--2] -a[-6--1] y -nm[-1] [3d\ star]
  -v +

#@gmic streamline3d : x[%],y[%],z[%],_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : 'formula',x,y,z,_L>=0,_dl>0,_interpolation,_is_backward={ 0 | 1 },_is_oriented={ 0 | 1 } : (+)
#@gmic : Extract 3d streamlines from selected vector fields or from specified formula.
#@gmic : 'interpolation' can be { 0=nearest integer | 1=1st-order | 2=2nd-order | 3=4th-order }.
#@gmic : Default values: 'dl=0.1', 'interpolation=2', 'is_backward=0' and 'is_oriented=0'.
#@gmic : $ 100,100,100,3 -rand -10,10 -blur 3 -repeat 300 --streamline3d[0] {?(100)},{?(100)},{?(100)},1000,1,1 -color3d[-1] @{-RGB} -done -remove[0] -box3d 100 -primitives3d[-1] 1 -add3d

#@gmic -3d : eq. to '-sub3d'. : (+)

#@gmic sub3d : tx,_ty,_tz : (+)
#@gmic : Shift selected 3d objects with the opposite of specified displacement vector.
#@gmic : (eq. to '--3d').
#@gmic : Default values: 'ty=tz=0'.
#@gmic : $ -sphere3d 10 -repeat 5 --sub3d[-1] 10,{?(-10,10)},0 -color3d[-1] @{-RGB} -done -add3d

#@gmic superformula3d : resolution>1,m>=1,n1,n2,n3
#@gmic : Input 2d superformula curve as a 3d object.
#@gmic : Default values: 'resolution=1024', 'm=8', 'n1=1', 'n2=5' and 'n3=8'.
#@gmic : $ -superformula3d ,
superformula3d : -check "${1=1024}>1 && ${2=8}>=1" -skip ${3=1},${4=5},${5=8}
  -e[^-1] "Input 2d superformula curve, with resolution $1, m=$2 and (n1,n2,n3)=($3,$4,$5)."
  -v -
  res={round($1)}

  # Define object header and vertices.
  (67.5;73.5;109.5;103.5;51.5;100.5;$res;{$res-1})
  (0,{2*pi}) -r[-1] $res,1,1,1,3 [-1]

  -*[-1] {$2/4} --sin[-1] -cos[-2] -abs[-2,-1]
  -^[-2] $4 -^[-1] $5 -+[-2,-1] -^[-1] {-1/$3}
  --sin[-2] -cos[-3] -*[-1] [-2] -*[-3,-2] -n[-2,-1] -1,1
  -a[-2,-1] y -rows[-1] 0,2 -transpose[-1] -r[-1] 1,{w*h},1,1,-1

  # Define object primitives, colors and opacities.
  1,{$res-1},1,1,2 (0;{$res-2}) -r[-1] 1,{$res-1},1,1,3 --+[-1] 1 -a[-3--1] x -round[-1] 1 -r[-1] 1,{w*h},1,1,-1
  1,{3*($res-1)},1,1,200 1,{$res-1},1,1,1 -a[-5--1] y -nm[-1] [3d\ superformula]
  -v +

#@gmic text_pointcloud3d : _"text1",_"text2",_smoothness
#@gmic : Input 3d text pointcloud from the two specified strings.
#@gmic : Default values: 'text1="text1"', 'text2="text2"' and 'smoothness=1'.
#@gmic : $ -text_pointcloud3d "G'MIC","Rocks!"
text_pointcloud3d : -skip ${1="text1"},${2="text2"},${3=1}
  -e[^-1] "Input 3d pointcloud text object from strings '$1' and '$2', with smoothness $3."
  -v -
  0 -t[-1] "$1",0,0,57,1,1
  0 -t[-1] "$2",0,0,57,1,1 -mirror[-1] y
  -expand_xy[-2,-1] 2,0 -dilate[-2,-1] 2
  -permute[-1] zyxc -r[-2,-1] @{-max_whd} -and[-2,-1]

  100%,100% -rand[-1] 0,{@{-2,d}-1} -round[-1] -r[-1] [-2] -f[-1] 'if(z==i,1,0)'
  -distance[-1] 1 -+[-1] 1 --f[-1] 1 -rv[-2,-1] -/[-2,-1] -*[-1] [-2]
  --dilate[-1] 0,0,{d} -==[-2,-1] -*[-1] [-2]

  1,100%,100% -rand[-1] 0,{@{-2,w}-1} -round[-1] -r[-1] [-2] -f[-1] 'if(x==i,1,0)'
  -distance[-1] 1 -+[-1] 1 --f[-1] 1 -rv[-2,-1] -/[-2,-1] -*[-1] [-3]
  --dilate[-1] 0,0,{d} -==[-2,-1] -*[-3,-1]

  -or[-2,-1]

  -b[-1] $3 -isosurface3d[-1] 25%
  -c3d[-1] -n3d[-1] -nm[-1] "[3d text pointcloud]" -v +

#@gmic text3d : text,_font_height>0,_depth>0,_smoothness
#@gmic : Input a 3d text object from specified text.
#@gmic : Default values: 'font_height=57', 'depth=10' and 'smoothness=1.5'.
#@gmic : $ -text3d "G'MIC as a\n3D logo!"
text3d : -skip ${2=57},${3=10},${4=1.5}
  -e[^-1] "Input 3d text object '$1' with size $2, depth $3 and smoothness $4."
  -v - 0 -t[-1] "$1",0,0,$2,1,1 -autocrop[-1] 0 -r[-1] 100%,100%,$3 -expand_xyz[-1] 10,0
  -b[-1] $4 -isosurface3d[-1] 40% -rv3d[-1] -nm[-1] "[3d text '$1']" -v +

#@gmic t3d : eq. to '-texturize3d'. : (+)

#@gmic texturize3d : [ind_texture],_[ind_coords] : (+)
#@gmic : Texturize selected 3d objects with specified texture and coordinates.
#@gmic : (eq. to '-t3d').
#@gmic : When '[ind_coords]' is omitted, default XY texture projection is performed.
#@gmic : Default value: 'ind_coords=(undefined)'.
#@gmic : $ image.jpg -torus3d 100,30 -texturize3d[-1] [-2] -keep[-1]

#@gmic torus3d : _radius1,_radius2,_nb_subdivisions1>2,_nb_subdivisions2>2
#@gmic : Input 3d torus at (0,0,0), with specified geometry.
#@gmic : Default values: 'radius1=1', 'radius2=0.3', 'nb_subdivisions1=24' and 'nb_subdivisions2=12'.
#@gmic : $ -torus3d 10,3 --primitives3d 1 -color3d[-2] @{-RGB}
torus3d : -check "${3=24}>2 && ${4=12}>2" -skip ${1=1},${2=0.3}
  -e[^-1] "Input 3d torus, with radii ($1,$2) and subdivisions ($3,$4)."
  -v -
  # Header.
  nbp={$3*$4}
  1,8,1,1,67.5,73.5,109.5,103.5,51.5,100.5,$nbp,{$4*$3}

  # Vertices.
  (0;{2*pi}) --y[-1] x
  -r[-2] 1,{$3+1},1,1,3 -z[-2] 0,0,0,{$3-1}
  -r[-1] {$4+1},1,1,1,3 -z[-1] 0,{$4-1}
  --sin[-2,-1] -cos[-4,-3] -r[-4--1] $4,$3
  -*[-3] $2 -+[-3] $1 -*[-1] $2 -*[-4] [-3] -*[-3,-2]
  -y[-3--1] -a[-3--1] x

  # Primitives.
  1,$3,1,1,'y' -*[-1] $4 --shift[-1] 0,-1 $4,1,1,1,'x' --shift[-1] -1 -r[-4--1] $4,$3
  --+[-4,-1] -+[-2] [-4] -+[-5] [-3] -+[-4,-3] -y[-4--1] -i[-5] 1,{h},1,1,4 -a[-5--1] x

  # Colors / opacities.
  3,{h},1,1,200 1,{h},1,1,1 -y[-4--2] -a[-5--1] y
  -nm[-1] [3d\ torus]
  -v +

#@gmic triangle3d : x0,y0,z0,x1,y1,z1,x2,y2,z2
#@gmic : Input 3d triangle at specified coordinates.
#@gmic : $ -repeat 100 a={$>*pi/50} -triangle3d 0,0,0,0,0,3,{cos(3*$a)},{sin(2*$a)},0 -color3d[-1] @{-RGB} -done -add3d
triangle3d :
  -e[^-1] "Input 3d triangle ($1,$2,$3)-($4,$5,$6)-($7,$8,$9)."
  -v - 1,25,1,1,67.5,73.5,109.5,103.5,51.5,100.5,3,1,${1-9},3,0,1,2,200,200,200,1 -nm[-1] [3d\ triangle] -v +

#@gmic volume3d
#@gmic : Transform selected 3d volumetric images as 3d parallelepipedic objects.
#@gmic : $ image.jpg -animate blur,0,5,30 -a z -volume3d
volume3d :
  -e[^-1] "Transform image$? as 3d parallelepipedic objects."
  -v - -repeat @# -l[$>]
    w={w} h={h} d={d}
    --slices 0 --slices[0] 100% -mirror[-1] y
    --columns[0] 0 --columns[0] 100% -permute[-2,-1] zyxc -mirror[-2] x
    --rows[0] 0 --rows[0] 100% -permute[-2,-1] xzyc -mirror[-2] y
    -rm[0] -image6cube3d -*3d $w,$h,$d
  -endl -done -v +

#@gmic weird3d : _resolution>0
#@gmic : Input 3d weird object at (0,0,0), with specified resolution.
#@gmic : Default value: 'resolution=32'.
#@gmic : $ -weird3d 48 --primitives3d 1 -color3d[-2] @{-RGB}
weird3d : -skip ${1=32}
  -e[^-1] "Input 3d weird object, with resolution $1."
  -v -
  -isosurface3d "'\
    T = 1.61803399;\
    2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))\
    '",0,-4.7,-4.7,-4.7,4.7,4.7,4.7,$1,$1,$1
  -c3d[-1] -n3d[-1] -nm[-1] [3d\ weird]
  -v +

#-------------------------------
#
#@gmic :: Program controls
#
#-------------------------------

#@gmic apply_parallel : "command" : (*)
#@gmic : Apply specified command on each of the selected images, by parallelizing it for all image of the list.
#@gmic : $ image.jpg --mirror x --mirror y -apply_parallel "-blur 3"
apply_parallel :
  -e[^-1] "Execute command '$*' on all image$? in parallel, using "@*" threads."
  -v - -m "_apply_parallel : $*" N=@#
  -l[]
    -repeat @* ({'-_apply_parallel[$>]'}) -done -if {@#>1} -i[1--2] ({','}) -endif -a x arg0=@{-1,t} -rm
    -if {$N%@*} -repeat {$N%@*} ({'-_apply_parallel[$>]'}) -done -if {@#>1} -i[1--2] ({','}) -endif -a x arg1=@{-1,t} -rm -endif
  -endl
  -repeat {round(@#/@*,1,1)} -l[{@**$>}-{min(@**$>+@*-1,@#-1)}]
    -parallel ${arg{@#!=@*}}
  -endl -done
  -uncommand _apply_parallel -v +

#@gmic apply_parallel_channels : "command"
#@gmic : Apply specified command on each of the selected images, by parallelizing it for all channel of the images independently.
#@gmic : $ image.jpg -apply_parallel_channels "-blur 3"
apply_parallel_channels :
  -e[^-1] "Execute command '$*' on all channels of image$? in parallel, using "@*" threads."
  -v - N=@# -repeat $N s$>=@{$>,s} -done -s c
  -apply_parallel "$1"
  -repeat $N -a[$>-{$>+${s$>}-1}] c -done -v +

#@gmic apply_parallel_overlap : "command",overlap[%],nb_threads={ 0=auto | 1 | 2 | 4 | 8 | 16 }
#@gmic : Apply specified command on each of the selected images, by parallelizing it on 'nb_threads' overlapped sub-images.
#@gmic : 'nb_threads' must be a power of 2.
#@gmic : Default values: 'overlap=0','nb_threads=0'.
#@gmic : $ image.jpg --apply_parallel_overlap "-smooth 500,0,1",16
apply_parallel_overlap : -check "${2=0}>=0 && isint(${3=0}) && $3>=0"
  -v - N={if($3,max(1,round($3)),@*)} N={2^int(log2(min(16,$N)))} -v +
  -e[^-1] "Apply parallelized command '$1' on image$?, with overlap $2 and "$N" threads."
  -v -
  -m "_check1 : -if {@#!=1} -error[0--9] \"Specified command '$1' changes the size of the image stack.\" -endif"
  -repeat @# -l[$>]
    -_apply_parallel_overlap$N "$1",$2
  -endl -done
  -uncommand _check1
  -v +

_apply_parallel_overlap1 :
  $1

_apply_parallel_overlap2 :
  -if {w>=h}
    ovx={round(if(@{"-is_percent $2"},w*$2,$2))} w2={int(w/2)}
    --z[0] {$w2-$ovx},100% -z[0] 0,{$w2+$ovx-1}
    -parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl"
    -z[0] 0,@{0,w-1-$ovx} -z[1] $ovx,100% -a x
  -else
    ovy={round(if(@{"-is_percent $2"},h*$2,$2))} h2={int(h/2)}
    --rows[0] {$h2-$ovy},100% -rows[0] 0,{$h2+$ovy-1}
    -parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl"
    -rows[0] 0,@{0,h-1-$ovy} -rows[1] $ovy,100% -a y
  -endif

_apply_parallel_overlap4 :
  -if {max(w,h)/min(w,h)>=3}
    -_apply_parallel_overlap2 "-_apply_parallel_overlap2 \"$1\",$2",$2
  -else
    ovx={round(if(@{"-is_percent $2"},w*$2,$2))} w2={int(w/2)}
    ovy={round(if(@{"-is_percent $2"},h*$2,$2))} h2={int(h/2)}
    --z[0] {$w2-$ovx},0,100%,{$h2+$ovy-1} --z[0] 0,{$h2-$ovy},{$w2+$ovx-1},100%
    --z[0] {$w2-$ovx},{$h2-$ovy},100%,100% -z[0] 0,0,{$w2+$ovx-1},{$h2+$ovy-1}
    -parallel "-l[0] $1 -_check1 -endl","-l[1] $1 -_check1 -endl","-l[2] $1 -_check1 -endl","-l[3] $1 -_check1 -endl"
    -z[0] 0,0,@{0,w-1-$ovx},@{0,h-1-$ovy} -z[1] $ovx,0,100%,@{1,h-1-$ovy}
    -z[2] 0,$ovy,@{2,w-1-$ovx},100% -z[3] $ovx,$ovy,100%,100%
    -a[0,1] x -a[1,2] x -a y
  -endif

_apply_parallel_overlap8 :
  -_apply_parallel_overlap2 "-_apply_parallel_overlap4 \"$1\",$2",$2

_apply_parallel_overlap16 :
  -_apply_parallel_overlap4 "-_apply_parallel_overlap4 \"$1\",$2",$2

#@gmic check : expression : (*)
#@gmic : Evaluate specified expression and display an error message if evaluated to false.
#@gmic : If 'expression' is not evaluable, it is regarded as a filename and checked if it exists.

#@gmic check3d : _is_full_check={ 0 | 1 } : (*)
#@gmic : Check validity of selected 3d vector objects, and display an error message
#@gmic : if one of the selected image is not a valid 3d vector object.
#@gmic : Full 3d object check is slower but more precise.
#@gmic : Default value: 'is_full_check=1'.

#@gmic continue : (*)
#@gmic : Go to end of current block 'repeat..done', 'do..while' or 'local..endlocal'.
#@gmic : $ image.jpg -repeat 10 -blur 1 -if {1==1} -continue -endif -deform 10 -done

#@gmic break : (*)
#@gmic : Break current 'repeat..done', 'do..while' or 'local..endlocal' block.
#@gmic : $ image.jpg -repeat 10 -blur 1 -if {1==1} -break -endif -deform 10 -done

#@gmic do : (*)
#@gmic : Start a 'do..while' block.
#@gmic : $ image.jpg -luminance i={ia+2} -do -set 255,{?(100)}%,{?(100)}% -while {ia<$i}

#@gmic done : (*)
#@gmic : End a 'repeat..done' block, and go to associated '-repeat' position, if iterations remain.

#@gmic elif : boolean : filename : (*)
#@gmic : Start a 'elif..[else]..endif' block if previous '-if' was not verified
#@gmic : and test if specified boolean is true, or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.

#@gmic else : (*)
#@gmic : Execute following commands if previous '-if' or '-elif' conditions failed.

#@gmic endif : (*)
#@gmic : End a 'if..[elif]..[else]..endif' block.

#@gmic endl : eq. to '-endlocal'. : (*)

#@gmic endlocal : (*)
#@gmic : End a 'local..endlocal' block.
#@gmic : (eq. to '-endl').

#@gmic error : message : (*)
#@gmic : Print specified error message on the standard error (stderr) and exit interpreter, except
#@gmic : if error is caught by a '-onfail' command.
#@gmic : Command subset (if any) stands for displayed scope indices instead of image indices.

#@gmic x : eq. to '-exec'. : (*)

#@gmic exec : command : (*)
#@gmic : Execute external command using a system call.
#@gmic : The status value is then set to the error code returned by the system call.
#@gmic : (eq. to '-x').

#@gmic if : boolean : filename : (*)
#@gmic : Start a 'if..[elif]..[else]..endif' block and test if specified boolean is true,
#@gmic : or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.
#@gmic : $ image.jpg -if {ia<64} -add 50% -elif {ia<128} -add 25% -elif {ia<192} -sub 25% -else -sub 50% -endif -cut 0,255

#@gmic l : eq. to '-local'. : (*)

#@gmic local : (*)
#@gmic : Start a 'local..[onfail]..endlocal' block, with selected images.
#@gmic : (eq. to '-l').
#@gmic : $ image.jpg -local[] 300,300,1,3 -rand[0] 0,255 -blur 4 -sharpen 1000 -endlocal
#@gmic : $ image.jpg --local -repeat 3 -deform 20 -done -endlocal

#@gmic mutex : indice,_action={ 0=unlock | 1=lock } : (*)
#@gmic : Lock or unlock specified mutex for multi-threaded programming.
#@gmic : A locked mutex can be unlocked only by the same thread. All mutexes are unlocked by default.
#@gmic : 'indice' designates the mutex indice, in [0,255].
#@gmic : Default value: 'action=1'.

#@gmic onfail : (*)
#@gmic : Execute following commands when an error is encountered in the body of the 'local..endlocal' block.
#@gmic : The status value is set with the corresponding error message.
#@gmic : $ image.jpg --local -blur -3 -onfail -mirror x -endlocal

#@gmic parallel : _wait_threads,"command1","command2",... : (*)
#@gmic : Execute specified commands in parallel, each in a different thread.
#@gmic : All running threads share the current list of images and the global variables.
#@gmic : 'wait_threads' can be { 0=never | 1=at return point | 2=immediately }.
#@gmic : Default value: 'wait_threads=2'.
#@gmic : $ image.jpg [0] -parallel "-blur[0] 3","-mirror[1] c"

# The implementation below allows to use parallel as a regular command with selections.
parallel :
  -if {$1==0||$1==1||$1==2} -e[0--3] "Execute "{$#-1}" commands '${2--1}' in parallel on image$?."
  -else -e[0--3] "Execute "$#" commands '$*' in parallel on image$?."
  -endif
  -v - -parallel $"*" -v +

#@gmic progress : 0<=value<=100 : -1 : (*)
#@gmic : Set the progress indice of the current processing pipeline.
#@gmic : This command is useful only when G'MIC is used by an embedding application.

#@gmic q : eq. to '-quit'. : (*)

#@gmic quit : (*)
#@gmic : Quit interpreter.
#@gmic : (eq. to '-q').

#@gmic repeat : nb_iterations : (*)
#@gmic : Start iterations of a 'repeat..done' block.
#@gmic : $ image.jpg -split y -repeat @# -shift[$>] $<,0,0,0,2 -done -append y
#@gmic : $ image.jpg -mode3d 2 -repeat 4 -imagecube3d -rotate3d 1,1,0,40 -snapshot3d 400,1.4 -done

#@gmic return : (*)
#@gmic : Return from current custom command.

#@gmic rprogress : 0<=value<=100 | -1 | "command",0<=value_min<=100,0<=value_max<=100
#@gmic : Set the progress indice of the current processing pipeline (relatively to
#@gmic : previously defined progress bounds), or call the specified command with
#@gmic : specified progress bounds.
rprogress : -skip ${2=""}
  -v -
  -if {!narg($_progress_bounds)} _progress_bounds=0,100 -endif
  m={arg(-2,$_progress_bounds)} M={arg(-1,$_progress_bounds)}
  -if {$#==2&&!narg($2)} # 1 argument -> Set progress bar.
    -v + -e[0--3] "Set relative progress indice to $1%." -v -
    -progress {if($1<0,-1,min(100,max(0,$m+($M-$m)*$1%)))}
  -elif {$#==3} # 3 arguments -> Call command with specified bounds.
    nm={min($2,$-1)} nM={max($2,$-1)}
    -v + -e[0--3] "Call command '$1' with progress bounds ["$nm,$nM"]." -v -
    -progress $m _progress_bounds=$_progress_bounds,{$m+$nm*($M-$m)/100},{$m+$nM*($M-$m)/100}  # Push new bounds.
    -_rprogress "$1"
    -progress $M ($_progress_bounds) _progress_bounds=@{-1,0--3} -rm[-1] # Pop bounds.
  -else -error[0--3] "Command '-rprogress' : Invalid argument '$*'."
  -endif
  -v +

_rprogress : $*

#@gmic skip : item : (*)
#@gmic : Do nothing but skip specified item.

#@gmic u : eq. to '-status'. : (*)

#@gmic status : value : (*)
#@gmic : Set current status value. Used to define a returning value in a function.
#@gmic : (eq. to '-u').
#@gmic : $ image.jpg -command "foo : u0=Dark u1=Bright -status ${u{ia>=128}}" -text_outline @{-foo},2,2,24,2,1,255

#@gmic while : boolean : filename : (*)
#@gmic : End a 'do..while' block and go back to associated '-do'
#@gmic : if specified boolean is true or if specified filename exists.
#@gmic : 'boolean' can be a float number standing for { 0=false | other=true }.

#----------------------------------
#
#@gmic :: Arrays, tiles and frames
#
#----------------------------------

#@gmic array : M>0,_N>0,_expand_type={ 0=min | 1=max | 2=all }
#@gmic : Create MxN array from selected images.
#@gmic : Default values: 'N=M' and 'expand_type=0'.
#@gmic : $ image.jpg -array 3,2,2
array : -check "isint($1) && $1>0 && isint(${2=$1}) && $2>0" -skip ${3=0}
  -e[^-1] "Create $1x$2 array from image$?, with expand type $3."
  -v - r0={100/max($1,$2)} r1={100/min($1,$2)} r2=100
  -r ${r$3}%,${r$3}%,1,100%,2 -r {$1*100}%,{$2*100}%,1,100%,0,2 -v +

#@gmic array_fade : M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0=min | 1=max | 2=all}
#@gmic : Create MxN array from selected images.
#@gmic : Default values: 'N=M', 'fade_start=60', 'fade_end=90' and 'expand_type=1'.
#@gmic : $ image.jpg -array_fade 3,2
array_fade : -skip ${2=$1},${3=60},${4=90},${5=1}
  -e[^-1] "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
  -v - -repeat @# -l[$>] [-1] -shift[-2] 50%,50%,1,1,2 -fade_diamond $3,$4 -endl -done
  -array $1,$2,$5
  -v +

#@gmic array_mirror : N>=0,_dir={ 0=x | 1=y | 2=xy | 3=tri-xy },_expand_type={ 0 | 1 }
#@gmic : Create 2^Nx2^N array from selected images.
#@gmic : Default values: 'dir=2' and 'expand_type=0'.
#@gmic : $ image.jpg -array_mirror 2
array_mirror : -skip ${2=2},${3=0}
  -e[^-1] "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
  -v - -repeat $1
    -if {$3==0}
      -if {$2>=3} -r 33%,33%,100%,100%,2
      -else -r 50%,50%,100%,100%,2
      -endif
    -endif
    -repeat @# -l[$>]
      -if {$2==0} --mirror x -a x
      -elif {$2==1} --mirror y -a y
      -else --mirror x -a x --mirror y -a y -if {$2==3} -r 150%,150%,1,100%,0,2,1,1 -endif
      -endif
    -endl -done
  -done -v +

#@gmic array_random : Ms>0,_Ns>0,_Md>0,_Nd>0
#@gmic : Create MdxNd array of tiles from selected MsxNs source arrays.
#@gmic : Default values: 'Ns=Ms', 'Md=Ms' and 'Nd=Ns'.
#@gmic : $ image.jpg --array_random 8,8,15,10
array_random : -skip ${2=$1},${3=$1},${4=$2}
  -e[^-1] "Create $3x$4 array of tiles from $1x$2 array$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -split_tiles $1,$2
    -repeat $3 -repeat $4 [{?($1*$2-1)}] -done -done
    -rm[0-{$1*$2-1}] -append_tiles $3,$4
  -nm $nm,1 -endl -done -v +

#@gmic frame : eq. to '-frame_xy'.
frame : -check "$1>=0 && ${2=$1}>=0" -skip ${3=255},${4=$3},${5=$4},${6=255}
  -v - __s="?" -v +
  -_frame_xy ${1--1}

#@gmic frame_blur : _sharpness>0,_size>=0,_smoothness,_shading,_blur
#@gmic : Draw RGBA-colored round frame in selected images.
#@gmic : Default values: 'sharpness=10', 'size=30', 'smoothness=0', 'shading=1' and 'blur=3%'.
#@gmic : $ image.jpg -frame_blur 3,30,8,10%
frame_blur : -skip ${1=10},${2=30},${3=0},${4=1},${5=3%}
  -e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and blur $5."
  -v - -to_rgba -repeat @# -l[$>] nm=@{0,n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" -ge[-1] $2%
    -if $4 -distance[-1] 1 -n[-1] 0,1 -*[-1] -1 -+[-1] 1 -^[-1] {1/$4} -endif
    -b[-1] $3 --b[-2] $5 -mv[-1] -3 -blend_fade
  -nm $nm,1 -endl -done -v +

#@gmic frame_cube : _depth>=0,_x_center,_y_center,_left_side={0=normal | 1=mirror-x | 2=mirror-y | 3=mirror-xy},_right_side,_lower_side,_upper_side
#@gmic : Insert 3d frames in selected images.
#@gmic : Default values: 'depth=1', 'x_center=y_center=0' and 'left_side=right_side,lower_side=upper_side=0'.
#@gmic : $ image.jpg -frame_cube ,
frame_cube : -check "${1=1}>=0" -skip ${2=0},${3=0},${4=0},${5=0},${6=0},${7=0}
  -e[^-1] "Insert 3d frame in image$?, with depth $1, center ($2,$3) and orientations (${4--1})."
  -v - -repeat @# -l[$>] nm=@{0,n} -split_opacity
    -if {@#==2} -frame_cube ${1--1} -a c  # Manage image with alpha-channel.
    -else
      m={max(w,h)} w={w} h={h} s={s}
      -imageplane3d -c3d -/3d[-1] $w,$h,1
      --_frame_cube[0] $4 -r3d[-1] 0,1,0,90 -+3d[-1] -0.5,0,-0.5  # Left side.
      --_frame_cube[0] $5 -r3d[-1] 0,1,0,-90 -+3d[-1] 0.5,0,-0.5  # Right side.
      --_frame_cube[0] $6 -r3d[-1] 1,0,0,90 -+3d[-1] 0,0.5,-0.5   # Lower side.
      --_frame_cube[0] $7 -r3d[-1] 1,0,0,-90 -+3d[-1] 0,-0.5,-0.5 # Upper side.
      -+3d 0,0,1 -+3d -*3d $w,$h,$m  # Append sides together.
      f=1000
      cx=$2*$w/2*($f+$m*$1)/$f
      cy=$3*$h/2*($f+$m*$1)/$f
      -s3d -r[2] 3,{@{2,h}/3},1,1,-1
      -f[2] "if(i(2,y)<0.5,i,i+if(x==0,"$cx",if(x==1,"$cy",($1-1)*"$m")))"
      -y[2] -a y
      -*3d 2 {2*$w},{2*$h},1,$s -f3d {2*$f}
      -object3d[-1] [-2],50%,50%,0,1,2,0,0 -rm[-2]
      -r $w,$h,1,100%,2
    -endif
  -nm $nm,1 -endl -done
  -v +

_frame_cube :
  -if {$1==1} -r3d[-1] 0,1,0,180 -rv3d[-1]
  -elif {$1==2} -r3d[-1] 1,0,0,180 -rv3d[-1]
  -elif {$1==3} -r3d[-1] 0,0,1,180
  -endif

#@gmic frame_fuzzy : size_x>=0,_size_y>=0,_fuzzyness>=0,_smoothness>=0,_R,_G,_B,_A
#@gmic : Draw RGBA-colored fuzzy frame in selected images.
#@gmic : Default values: 'size_y=size_x', 'fuzzyness=5', 'smoothness=1' and 'R=G=B=A=255'.
#@gmic : $ image.jpg -frame_fuzzy 20
frame_fuzzy : -skip ${2=$1},${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
  -e[^-1] "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
  -v - -to_rgba -repeat @# -l[$>] nm=@{0,n}
    -i[0] ($1;$2) -*[0] 2 ($5^$6^$7^$8) -r[-1] [-2] 100%,100%
    -rectangle[-1] 0,0,100%,@{0,1},1,1
    -rectangle[-1] 0,0,@{0,0},100%,1,1
    -rm[0] -shift[-1] -$1,-$2,0,0,2 -spread[-1] $3 -b[-1] $4 -_fade 50,80
  -nm $nm,1 -endl -done -v +

#@gmic frame_painting : _size[%]>=0,0<=_contrast<=1,_profile_smoothness[%]>=0,_R,_G,_B,_vignette_size[%]>=0,_vignette_contrast>=0,_defects_contrast>=0,0<=_defects_density<=100,_defects_size>=0,_defects_smoothness[%]>=0,_serial_number
#@gmic : Add a painting frame to selected images.
#@gmic : Default values: 'size=10%', 'contrast=0.4', 'profile_smoothness=6%', 'R=225', 'G=200', 'B=120', 'vignette_size=2%', 'vignette_contrast=400', 'defects_contrast=50', 'defects_density=10', 'defects_size=1', 'defects_smoothness=0.5%' and 'serial_number=123456789'.
#@gmic : $ image.jpg -frame_painting ,
frame_painting :
  -check "${1=10%}>=0 && ${2=0.4}>=0 && $2<=1 && ${3=6%}>=0 && ${7=2%}>=0 && ${8=400}>=0 && ${9=50}>=0 && ${10=10}>=0 && $10<=100 && ${11=1}>=0 && ${12=0.5%}>=0"
  -skip ${4=225},${5=200},${6=120},${13=123456789}
  -e[^-1] "Add painting frame to image$?, with size $1, contrast $2, profile smoothness $3, color (${4-6}), vignette size $7, "\
          "vignette strength $8, defects contrast $9, defects density $10, defects size $11, defects smoothness $12 and serial number $13."
  -v - -repeat @# -l[$>]
    -if {!$1} -return -endif
    $1,$1 s={max(w,h)} -rm[-1]                                # Determine size of the frame.
    ({'@{-dec2bin\ $13}'}) --[-1] {'0'} -r[-1] $s             # Generate frame profile from serial number.
    -transpose[-1] -b[-1] $3 -n[-1] {1-$2},{1+$2}
    --r[-1] {@{-2,w}+2*$s},100%,1,1                           # Upper frame.
    --mirror[-1] y                                            # Lower frame.
    -mv[-3] @# -transpose[-1] -r[-1] 100%,{@{-4,h}+2*$s},1,1  # Left frame.
    --mirror[-1] x                                            # Right frame.
    [-3],[-3],1,1,1 -polygon[-1] 3,0,0,{$s-1},{$s-1},0,{$s-1},1,0 -polygon[-1] 3,100%,0,{w-$s},100%,100%,100%,1,0 # Upper/lower mask.
    [-2],[-2],1,1,1 -polygon[-1] 3,1,0,100%,{$s-2},100%,0 -polygon[-1] 3,1,100%,100%,{h-$s+1},100%,100%,1,0 # Left/right mask.
    -_frame_painting[-6--3] ${4-6},${9-12}                    # Add colors + defects.

    # Build full frame picture.
    {@{-7,w}+2*$s},{@{-7,h}+2*$s},1,3
    -j[-1] [-7],0,0,0,0,1,[-3],1 -rm[-7] -mirror[-3] y
    -j[-1] [-6],0,{h-$s},0,0,1,[-3],1 -rm[-6,-3]
    -j[-1] [-4],0,0,0,0,1,[-2],1 -rm[-4] -mirror[-2] x
    -j[-1] [-3],{w-$s},0,0,0,1,[-2],1 -rm[-3,-2]
    [-2],[-2],1,1,-255 -r[-1] [-2],[-2],1,1,0,0,0.5,0.5 -+[-1] 255 --b[-1] $7 -n[-1] 0,$8 -max[-2,-1] -c[-1] 0,255 # Frame opacity.
    -a[-2--1] c
    -r[-2] [-1],[-1],1,100%,0,0,0.5,0.5 -blend alpha # Insert initial image into frame picture.
  -endl -done -v +

_frame_painting : # Add color + texture to each frame part.
  -repeat @# -l[$>]
    --*[-1] $2 --*[-2] $3 -*[-3] $1 -a[-3--1] c
    100%,100%
    i=0 -do -rand[-1] 0,1 -remove_pixels[-1] {100-$5} -b[-1] $6 -ge[-1] 50% i={$i+1} -while {"m=$5/200;(ia<m-0.2 || ia>m+0.2) && "$i"<10"}
    -b[-1] $7 -g[-1] -+[-2,-1] -n[-1] -$4,$4
    -+[-2,-1] -c[-1] 0,255
  -endl -done

#@gmic frame_pattern : M>=3,_pattern = { 0=first image | 1=self },_constrain_size = { 0 | 1 }
#@gmic : Insert selected pattern frame in selected images.
#@gmic : Default values: 'pattern=0' and 'constrain_size=0'.
#@gmic : $ image.jpg -frame_pattern 8
frame_pattern : -check $1>=3 -skip ${2=0},${3=0}
  -v - -to_colormode 0
  -if {@#==1||$2} # Self-framing
    -v + -e[^-1] "Insert $1x$1 self-pattern frame on image$?." -v -
    -repeat @# -l[$>]
      wh={w},{h}
      --r {w/($1-2)},{h/($1-2)},1,100%,2 -r[-2] {$1*w},{$1*h},1,100%,0,0,0.5,0.5
      [-1]x{$1+2} -a[{-$1-2}--1] x -j[-3] [-1],0,0 -j[-3] [-1],0,{@{-3,h}-1-h} -rm[-1]
      [-1]x{$1+1} -a[{-$1-2}--1] y -j[-2] [-1],0,0 -j[-2] [-1],{@{-2,w}-1-w} -rm[-1]
      -if $3 -r $wh,1,100%,2 -endif
    -endl -done
  -else # Frame from image[0]
    -v + -e[^-1] "Insert $1x$1 pattern frame on image$?, using first image." -v -
    -repeat {@#-1}
      wh={w},{h}
      --r[0] {w/($1-2)},{h/($1-2)},1,100%,2
      -r[-2] {@{-2,w}+2*w},{@{-2,h}+2*h},1,100%,0,0,0.5,0.5
      [-1]x{$1+2} -a[{-$1-2}--1] x -j[-3] [-1],0,0 -j[-3] [-1],0,{@{-3,h}-1-h} -rm[-1]
      [-1]x{$1+1} -a[{-$1-2}--1] y -j[-2] [-1],0,0 -j[-2] [-1],{@{-2,w}-1-w} -rm[-1]
      -if $3 -r[-1] $wh,1,100%,2 -endif
    -mv[-1] 1 -done -rm[0]
  -endif
  -v +

#@gmic frame_round : _sharpness>0,_size>=0,_smoothness,_shading,_R,_G,_B,_A
#@gmic : Draw RGBA-colored round frame in selected images.
#@gmic : Default values: 'sharpness=10', 'size=10', 'smoothness=0', 'shading=0' and 'R=G=B=A=255'.
#@gmic : $ image.jpg -frame_round 10
frame_round : -skip ${1=10},${2=10},${3=0},${4=0},${5=255},${6=$5},${7=$6},${8=255}
  -e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and RGBA color ($5,$6,$7,$8)."
  -v - -to_rgba -repeat @# -l[$>] nm=@{0,n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" -ge[-1] $2%
    -if $4 -distance[-1] 1 -n[-1] 0,1 -*[-1] -1 -+[-1] 1 -^[-1] {1/$4} -endif
    -b[-1] $3 -i[-3] 100%,100%,1,4 -fc[-3] $5,$6,$7,$8 -blend_fade
  -nm $nm,1 -endl -done -v +

#@gmic frame_x : size_x[%]>=0,_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@gmic : $ image.jpg -frame_x 20,255,0,255
frame_x : -check "$1>=0" -skip ${2=255},${3=$2},${4=$3},${5=255}
  -e[^-1] "Insert $1 outer frame in image$? along the x-axis, with color (${2--1})."
  -_frame $1,0,0,${2--1}

#@gmic frame_xy : size_x[%]>=0,_size_y[%]>=0,_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'size_y=size_x', 'col1=col2=col3=255' and 'col4=255'.
#@gmic : (eq. to '-frame').
#@gmic : $ image.jpg -frame_xy 1,1,0 -frame_xy 20,10,255,0,255
frame_xy : -check "$1>=0 && ${2=$1}>=0" -skip ${3=255},${4=$3},${5=$4},${6=255}
  -v - __s="$?" -v +
  -_$0 ${1--1}

_frame_xy :
  -e[0--3] "Insert $1x$2 outer frame in image"$__s" along the xy-axes, with color (${3--1})."
  -_frame $1,$2,0,${3--1}

#@gmic frame_xyz : size_x[%]>=0,_size_y[%]>=0,_size_z[%]>=0_col1,...,_colN
#@gmic : Insert colored frame along the x-axis in selected images.
#@gmic : Default values: 'size_y=size_x=size_z', 'col1=col2=col3=255' and 'col4=255'.
frame_xyz : -check "$1>=0 && ${2=$1}>=0 && ${3=$2}>=0" -skip ${4=255},${5=$4},${6=$5},${7=255}
  -e[^-1] "Insert $1x$2x$3 outer frame in image$? along the xyz-axes, with color (${4--1})."
  -_frame $1,$2,$3,${4--1}

#@gmic frame_y : size_y[%]>=0,_col1,...,_colN
#@gmic : Insert colored frame along the y-axis in selected images.
#@gmic : Default values: 'col1=col2=col3=255' and 'col4=255'.
#@gmic : $ image.jpg -frame_y 20,255,0,255
frame_y : -check "$1>=0" -skip ${2=255},${3=$2},${4=$3},${5=255}
  -e[^-1] "Insert $1 outer frame in image$? along the y-axis, with color (${2--1})."
  -_frame 0,$1,0,${2--1}

_frame :
  -v - -repeat @# -l[$>]
    w={round($1*if(@{-is_percent\ $1},w,1))}
    h={round($2*if(@{-is_percent\ $2},h,1))}
    d={round($3*if(@{-is_percent\ $3},d,1))}
    -r {w+2*$w},{h+2*$h},{d+2*$d},100%,0,0,0.5,0.5,0.5
    -if {$w} $w,100%,100%,100% -fc[-1] ${4--1} -j[0] [1] -j[0] [1],@{0,w-$w} -rm[-1] -endif
    -if {$h} 100%,$h,100%,100% -fc[-1] ${4--1} -j[0] [1] -j[0] [1],0,@{0,h-$h} -rm[-1] -endif
    -if {$d} 100%,100%,$d,100% -fc[-1] ${4--1} -j[0] [1] -j[0] [1],0,0,@{0,d-$d} -rm[-1] -endif
  -endl -done -v +

#@gmic imagegrid : M>0,_N>0
#@gmic : Create MxN image grid from selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg -imagegrid 16
imagegrid : -skip ${2=$1}
  -e[^-1] "Create $1x$2 image grid from image$?."
  -v - -repeat @# -l[$>]
    ({w},{h}) ($1,$2) -/[-2,-1] -round[-1] 1 -r[-2] @-1,[-2],[-2],2 -rm[-1]
    ({w},{h}) ($1,$2) -*[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    $1,$2,1,[-1],1 -shift[-1] 1,1 -r[-1] [-2],0,2 -*
  -endl -done -v +

#@gmic linearize_tiles : M>0,_N>0
#@gmic : Linearize MxN tiles on selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --linearize_tiles 16
linearize_tiles : -check "$1>0 && ${2=$1}>0"
  -e[^-1] "Linearize $1x$2 tiles on image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    s={s} -split_tiles $1,$2 -s c # Split as tiles for all channels.
    -repeat @# -l[$>]
      wh={w},{h}
      --f x --f[-1] y --f[-1] 1 -y -a[^0] x -solve[-2] [-1] -rm[-1]
      $wh,1,1,@{-1,0}"*x + "@{-1,1}"*y + "@{-1,2} -rm[-2]
    -endl -done
    -repeat {int(@#/$s)} -a[-$s--1] c -mv[-1] 0 -done -append_tiles $1,$2
  -nm $nm,1 -endl -done -v +

#@gmic map_sprites : _nb_scales>=1,_allow_rotation={ 0=none | 1=90 deg. | 2=180 deg. }
#@gmic : Map set of sprites (defined as the 'nb_scales' latest images of the selection) to other selected images,
#@gmic : according to the luminosity of their pixel values.
#@gmic : $ image.jpg -r2dy 48 -repeat 16 -ball {8+2*$>},@{-RGB} -*[-1] {(1+$>)/16} -done -map_sprites 16
map_sprites : -check "isint($1) && $1>0 && isint(${2=0}) && $2>=0 && $2<=2"
  -e[^-1] "Map set of $1 sprites to image selection$?."
  -v - -norm[0--{$1+1}] -quantize[0--{$1+1}] $1,0,1
  -slices[-$1--1] 0 -r[-$1--1] @{-max_wh[-$1--1]},1,100%,0,0,0.5,0.5
  -if {$2==1}
    N={4*$1}
    -repeat {@#-$1} -*[$>] 4 --rand[$>] 0,3 -round[-1] -+[$>,-1] -done
    -repeat $1 -l[{1+$<}] --mirror xy --rotate 90 -endl -done
  -elif {$2==2}
    N={2*$1}
    -repeat {@#-$1} -*[$>] 2 --rand[$>] 0,1 -round[-1] -+[$>,-1] -done
    -repeat $1 -l[{1+$<}] --mirror xy -endl -done
  -else N=$1 -endif
  -r[-$N--1] 100%,100%,1,@{-max_s[-$N--1]} w={w} h={h} -a[-$N--1] x
  -r[^-1] ${w}00%,${h}00%,1,1 -*[^-1] $w
  (0,{$w-1};0,{$w-1}^0,0;{$h-1},{$h-1}) -r[-1] $w,$h,1,2,3 -round[-1]
  -repeat {@#-2} --r[-1] [$>],[$>],1,2,0,2 -r[$>] 100%,100%,1,2,0 -+[$>,-1] --warp[-2] [$>],0,0 -rv[$>,-1] -rm[-1] -done -rm[-2,-1] -v +

#@gmic puzzle : _width>0,_height>0,_M>=1,_N>=1,_curvature,_centering,_connectors_variability,_resolution>=1
#@gmic : Input puzzle binary mask with specified size and geometry.
#@gmic : Default values: 'width=height=512', 'M=N=5', 'curvature=0.5', 'centering=0.5', 'connectors_variability=0.5' and 'resolution=64'.
#@gmic : $ -puzzle ,
puzzle : -check "isint(${1=512}) && $1>0 && isint(${2=$1}) && $2>0 && isint(${3=5}) && $3>0 && isint(${4=$3}) && $4>0 && isint(${8=64}) && $8>0"
         -skip ${5=0.5},${6=0.5},${7=0.5}
  -e[^-1] "Draw $3x$4 puzzle pattern on image$?, with curvature $5, centering $6, connectors variability $7 and resolution $8."
  -v - -l[]
    -if {$4>=2} -_puzzle[] $3,{$4-1},${5-8} -+3d[-1] 0,1 -endif
    -if {$3>=2} -_puzzle[] $4,{$3-1},${5-8} -r3d[-1] 0,0,1,90 -+3d[-1] 1,$4 -endif
    -*3d {$1/$3},{$2/$4} -quadrangle3d 0,0,0,{$1-1},0,0,{$1-1},{$2-1},0,0,{$2-1},0 -p3d[-1] 1 -+3d -col3d 1
    $1,$2 -object3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
  -endl -v +

_puzzle :
  R={$6*$1}
  -repeat $2
    ({'CImg3d'},$R,{$R-1})
    -repeat $1
      sign={if(?<=0.5,-1,1)}
      center={$4*?(-0.25,0.25)}
      knob={$5*?(-0.05,0.12)}
      ($>,0;\
       {0.2+$center+$>},{-$sign*$3*0.1};\
       {0.4+$center+$>},0;\
       {0.35+$center+$>},{0.1*$sign};\
       {0.45+$center+$>},{(0.15+$knob)*$sign};\
       {0.55+$center+$>},{(0.15+$knob)*$sign};\
       {0.65+$center+$>},{0.1*$sign};\
       {0.6+$center+$>},0;\
       {0.8+$center+$>},{-$sign*$3*0.1})
    -done
    ($1,0) -a[-{$1+1}--1] y -r[-1] 2,$R,1,1,5 -z[-1] 0,2
    (2,0,1;2,{$R-2},{$R-1}) -r[-1] 3,{$R-1},1,1,3 -round[-1]
    3,{h},1,1,255 1,{h},1,1,255 -y[-5--1] y -a[-5--1] y -+3d[-1] 0,$>
  -done -+3d

#@gmic quadratize_tiles : M>0,_N>0
#@gmic : Quadratize MxN tiles on selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --quadratize_tiles 16
quadratize_tiles : -check "$1>0 && ${2=$1}>0"
  -e[^-1] "Quadratize $1x$2 tiles on image$?."
  -v - -repeat @# -l[$>] nm=@{0,n}
    s={s} -split_tiles $1,$2 -s c # Split as tiles for all channels.
    -repeat @# -l[$>]
      wh={w},{h}
      --f x^2 --f[-1] y^2 --f[-1] x*y --f[-1] x --f[-1] y --f[-1] 1 -y -a[^0] x -solve[-2] [-1] -rm[-1]
      $wh,1,1,@{-1,0}"*x^2 + "@{-1,1}"*y^2 + "@{-1,2}"*x*y +"@{-1,3}"*x + "@{-1,4}"*y + "@{-1,5} -rm[-2]
    -endl -done
    -repeat {int(@#/$s)} -a[-$s--1] c -mv[-1] 0 -done -append_tiles $1,$2
  -nm $nm,1 -endl -done -v +

#@gmic rotate_tiles : angle,_M>0,N>0
#@gmic : Apply MxN tiled-rotation effect on selected images.
#@gmic : Default values: 'M=8' and 'N=M'.
#@gmic : $ image.jpg -to_rgba -rotate_tiles 10,8 -drop_shadow 10,10 -display_rgba
rotate_tiles : -skip ${2=8},${3=$2}
  -e[^-1] "Apply $2x$3 tiled-rotation effect on image$?, with angle $1 deg."
  -v - -split_tiles $2,$3,1 -rotate $1 -append_tiles $2,$3 -v +

#@gmic shift_tiles : M>0,_N>0,_amplitude
#@gmic : Apply MxN tiled-shift effect on selected images.
#@gmic : Default values: 'N=M' and 'amplitude=20'.
#@gmic : $ image.jpg --shift_tiles 8,8,10
shift_tiles : -check "${2=$1}>=0" -skip ${3=20}
  -e[^-1] "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
  -v - -repeat @# -l[$>]
    $1,$2,1,2 -noise[-1] $3 -r[-1] [-2],[-2],1,2 -warp[-2] [-1],1,1,0 -rm[-1]
  -endl -done -v +

#@gmic taquin : M>0,_N>0
#@gmic : Create MxN taquin puzzle from selected images.
#@gmic : Default value: 'N=M'.
#@gmic : $ image.jpg --taquin 8
taquin : -skip ${2=$1}
 -e[^-1] "Create $1x$2 taquin puzzle from image $?."
 -v - -repeat @# -l[$>] nm=@{0,n}
   -split_tiles $1,$2,1 -repeat {$1*$2} -mv[$>] {?(@#)} -done -append_tiles $1,$2
 -nm $nm,1 -endl -done -v +

#@gmic tunnel : _level>=0,_factor>0,_cx,_cy,_opacity,_angle
#@gmic : Apply tunnel effect on selected images.
#@gmic : Default values: 'level=9', 'factor=80%', 'cx=cy=0.5', 'opacity=1' and 'angle=0'
#@gmic : $ image.jpg --tunnel 20
tunnel : -check "${1=9}>=0 && ${2=80%}>0" -skip ${3=0.5},${4=0.5},${5=0.1},${6=0}
  -e[^-1] "Apply tunnel effect on image$?, with depth $1, factor $2, centering ($3,$4), opacity $5 and angle $6."
  -v - -repeat @# -l[$>]
    -repeat $1 --r[-1] $2,$2,1,100%,5
    -if $6 100%,100%,1,1,1 -rotate[-2,-1] $6,1,0 -erode[-1] 3 -j[-3] [-2],{(@{-3,w}-w)*$3},{(@{-3,h}-h)*$4},0,0,$5,[-1] -rm[-2,-1]
    -else -j[-2] [-1],{(@{-2,w}-w)*$3},{(@{-2,h}-h)*$4},0,0,$5 -rm[-1] -endif
    -done
  -endl -done -c 0,255 -v +

#-----------------------------
#
#@gmic :: Artistic
#
#-----------------------------

#@gmic boxfitting : _min_box_size>=1,_max_box_size>=0,_initial_density>=0,_nb_attempts>=1
#@gmic : Apply box fitting effect on selected images, as displayed the web page:
#@gmic : [http://www.complexification.net/gallery/machines/boxFittingImg/]
#@gmic : Default values: 'min_box_size=1', 'max_box_size=0', 'initial_density=0.1' and 'nb_tries=3'.
#@gmic : $ image.jpg --boxfitting ,
boxfitting : -check "isint(${1=3}) && $1>=1 && isint(${2=0}) && $2>=0 && ${3=0.1}>=0 && isint(${4=3}) && $4>=1"
  -e[^-1] "Apply box fitting effect on image$?, with box sizes ($1,$2), density $3 and $4 attempts."
  -v -
  min_size=$1
  max_size={if($2,$2,max(w,h))}
  -repeat @# -l[$>]
    nb_attempts=0 prec=5
    100%,100%
    -repeat 1e8

      # Add random non-intersecting squares with min size.
      -if {$><1} # Takes random points for the first iteration.
        100%,100% -noise[-1] {max(1e-3,$3)},2
      -else # Then, try to take points near the median axis of the distance function otherwise.
        --distance[-1] 1 --rand[-1] 0,1 -*[-2,-1] -max_patch[-1] {round($prec*$min_size)}
        prec={max(1,$prec*0.9)}
      -endif

      # Discard new squares that intersect something.
      -dilate[-1] $min_size -area_fg[-1] 0,1 -eq[-1] {($min_size)^2}
      --dilate[-2] 3 -eq[-1] 0 -*[-2,-1] -area_fg[-1] 0,1 -eq[-1] {($min_size)^2}
      -if {!iM} nb_attempts={$nb_attempts+1} -if {$nb_attempts>$4} -rm[-1] -break -endif # If no new squares have been placed.
      -else nb_attempts=0 -endif
      -+[-2,-1]

      # Make current squares grown until max square size is reached.
      -repeat {int(($max_size-$min_size)/2)}
        --dilate[-1] 3 -area_fg[-1] 0,1 -eq[-1] {($min_size+2*$>+2)^2}
        -if {!iM} -rm[-1] -break -endif  # No more squares to grow.
        -or[-2,-1]
      -done

    -done
    -blend shapeaverage0
  -endl -done -v +

#@gmic cartoon : _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0
#@gmic : Apply cartoon effect on selected images.
#@gmic : Default values: 'smoothness=3', 'sharpening=150', 'threshold=20', 'thickness=0.25', 'color=1.5' and 'quantization=8'.
#@gmic : $ image.jpg --cartoon 3,80,15
cartoon : -skip ${1=3},${2=150},${3=20},${4=0.25},${5=1.5},${6=8}
  -e[^-1] "Apply cartoon effect on image$?, with smoothness $1, sharpening $2, threshold $3, thickness $4, color $5 and quantization $6."
  -v - -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -b $1 -sharpen $2,1 -c 0,255 -n 0,255
    --edges $3 -b[-1] $4 -ge[-1] 0.9
    -rgb2lab[-2] -s[-2] c -*[-3,-2] $5 -a[-4--2] c -lab2rgb[-2] -quantize[-2] $6,1,0 -n[-2] 0,255 -*
  -endl -a c -endl -done -v +

#@gmic circlism : _radius_min>0,_radius_max>0,_smoothness[%]>=0,_radius_linearity>=0,_location_linearity>=0,_shape={0=squares | 1=diamonds | 2=circle }
#@gmic : Apply circlism effect on selected images (effect inspired by Ben Heine).
#@gmic : Default values: 'radius_min=2', 'radius_max=20', 'smoothness=1', 'radius_linearity=0.4', 'location_linearity=3' and 'shape=1'.
#@gmic : $ image.jpg --circlism ,
circlism : -check "${1=2}>0 && ${2=20}>0 && ${3=1}>=0 && ${4=0.4}>0 && ${5=3}>=0" -skip ${6=2}
  -e[^-1] "Apply circlism effect on image$?, with radii ($1,$2), smoothness $3, radius linearity $4 and location linearity $5.\n"
  -v - -repeat @# -l[$>]
    --gradient_norm -b[-1] $3 -n[-1] 0,1 --^[-1] $5 -^[-2] $4 sumg0=@{-1,+} 100%,100%
    it=0 failed=0 noedges=0 svg="-1,-1"
    -do
      --distance[-1] 1,3
      -if $noedges xyzc=@{-1,C} -else --*[-3,-1] xyzc=@{-1,C} -rm[-1] -endif
      n=@{-4,($xyzc)}
      x={arg(1,$xyzc)}
      y={arg(2,$xyzc)}
      r={min(max($1,$2*(1-$n)),sqrt(@{-1,($xyzc)})-2)}
      -rm[-1]
      -if {$r>=$1}
        -if {$6==2}  # Fill with circles.
          -ellipse[-1] $x,$y,$r,$r,0,1,1 -ellipse[-2] $x,$y,{$r+$1},{$r+$1},0,1,-1
        -elif {$6==1} # Fill with squares.
          x0={$x-$r/2} y0={$y-$r/2} x1={$x+$r/2} y1={$y+$r/2}
          -rectangle[-1] $x0,$y0,$x1,$y1,1,1
          x0={$x-($r+$1)/2} y0={$y-($r+$1)/2} x1={$x+($r+$1)/2} y1={$y+($r+$1)/2}
          -rectangle[-2] $x0,$y0,$x1,$y1,1,-1
        -else # Fill with diamonds.
          x0={round($x-$r/2)} y0={round($y-$r/2)} x1={round($x+$r/2)} y1={round($y+$r/2)}
          -polygon[-1] 4,$x0,$y,$x,$y0,$x1,$y,$x,$y1,1,1
          x0={round($x-($r+$1)/2)} y0={round($y-($r+$1)/2)} x1={round($x+($r+$1)/2)} y1={round($y+($r+$1)/2)}
          -polygon[-2] 4,$x0,$y,$x,$y0,$x1,$y,$x,$y1,1,-1
        -endif
        failed=0
      -else
        -=[-2] -1,$x,$y
        failed={$failed+1}
        -if {$failed==100} failed=0 -if $noedges n=-1 -else noedges=1 -endif -endif
      -endif
      it={$it+1}
      -if {!($it%50)}
        p={round(100*(($sumg0-@{-2,+})/@{-2,wh})^3)}
        -rprogress $p -v + -e[] "\r  "$p% -v -
      -endif
    -while {$n>=0}
    -rm[-3,-2] -rprogress -1
    -blend shapeaverage0
  -endl -done -v +

#@gmic color_ellipses : _count>0,_radius>=0,_opacity>=0
#@gmic : Add random color ellipses to selected images.
#@gmic : Default values: 'count=400', 'radius=5' and 'opacity=0.1'.
#@gmic : $ image.jpg --color_ellipses ,,0.15
color_ellipses : -skip ${1=1400},${2=5},${3=0.1}
  -e[^-1] "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
  -v - -repeat $1 -ellipse {?(0,100)}%,{?(0,100)}%,{?(0,$2)}%,{?(0,$2)}%,{?(0,360)},$3,{?(60,255)},{?(60,255)},{?(60,255)},255 -done -v +

#@gmic cubism : _density>=0,0<=_thickness<=50,_max_angle,_opacity,_smoothness>=0
#@gmic : Apply cubism effect on selected images.
#@gmic : Default values: 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'.
#@gmic : $ image.jpg --cubism ,
cubism : -check "${1=50}>=0 && ${2=10}>=0 && $2<=50 && ${5=0}>=0" -skip ${3=75},${4=0.7}
  -e[^-1] "Apply cubism effect on image$?, with density $1, thickness $2, maximum angle $3 deg., opacity $4 and smoothness $5."
  -if {"!$1 || !$2 || !$3 || !$4"} -return -endif
  -v - -repeat @# -l[$>]
    w={w} h={h} s={s}
    P={round($2*max(w,h)/200)}
    N={round(1.5*$1*w*h/(4*$P)/100)}

    # Define Header + nb vertices / primitives.
    ({'CImg3d'}) -+[-1] 0.5 ({4*$N};$N)

    # Generate list of random points.
    1,$N -rand[-1] $P,{$w-1-$P} --rand[-1] $P,{$h-1-$P} -a[-2,-1] x -round[-1]

    # Generate list of primitives.
    --+[-1] '-$P,-$P' --+[-2] '$P,-$P' --+[-3] '$P,$P' --+[-4] '-$P,$P'
    -a[-4--1] x -i[-2] (12,0,1,2,3;12,{4*($N-1)},{4*($N-1)+1},{4*($N-1)+2},{4*($N-1)+3})
    -r[-2] 5,$N,1,1,3 -round[-2] 1 -a[-2,-1] x

    # Generate list of vertices.
    1,$N -rand[-1] {225-$3},{225+$3} -*[-1] {pi/180}
    --sin[-1] -cos[-2] --*[-1] -1 [-3] -a[-4--3] x -a[-2,-1] x -z[-4,-2,-1] 0,2 --*[-2,-1] -1 -a[-4--1] x -*[-1] {sqrt(2)*$P}
    -r[-3] 400%,100%,1,1,0,2 -+[-3,-1]

    # Generate materials.
    (-128;$w;$h;$s) --b[0] $5
    -if {$N>1} 4,{$N-1},1,1,-128,0,0,0 -endif
    1,$N,1,1,1

    # Apply effect on current image.
    -y[1--1] -a[1--1] y -rv3d[-1]
    -if {$4>=1} -object3d[0] [1],0,0,0,1,2,0,0 -rm[1]
    -else --object3d[0] [1],0,0,0,1,2,0,0 -rm[1] -blend alpha,$4
    -endif

  -endl -done -v +

#@gmic draw_whirl : _amplitude>=0
#@gmic : Apply whirl drawing effect on selected images.
#@gmic : Default value: 'amplitude=100'.
#@gmic : $ image.jpg --draw_whirl ,
draw_whirl : -skip ${1=100}
  -e[^-1] "Apply whirl drawing effect on image$? with amplitude $1."
  -v - -repeat @# -l[$>]
    100%,100% -noise[-1] 70,2 -*[-1] 255 -r[-1] [-2] -and[-1,-2] -smooth[-1] $1,0,1,2,2
    -sqrt[-1] -n[-1] 0,255 -equalize[-1]
  -endl -done -v +

#@gmic drawing : _amplitude>=0
#@gmic : Apply drawing effect on selected images.
#@gmic : Default value: 'amplitude=200'.
#@gmic : $ image.jpg --drawing ,
drawing : -skip ${1=200}
  -e[^-1] "Apply drawing effect on image$? with amplitude $1."
  -v - -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -smooth $1,0.2,1,3,3 -b 2 -sharpen 1000 [0]
    -r[0] 20,20,1,3,2 -equalize[0] -index[1] [0],1,1
    -nm[1] @{0,n},1 -rm[0]
  -endl -a c -endl -done -v +

#@gmic drop_shadow : _offset_x[%],_offset_y[%],_smoothness[%]>=0,0<=_curvature<=1,_expand_size={ 0 | 1 }
#@gmic : Drop shadow behind selected images.
#@gmic : Default values: 'offset_x=20', 'offset_y=offset_x', 'smoothness=5', 'curvature=0' and 'expand_size=1'.
#@gmic : $ image.jpg -drop_shadow 10,20,5,0.5 -expand_xy 20,0 -display_rgba
drop_shadow : -check "${3=5}>=0 && ${4=0}>=0 && $4<=1" -skip ${1=20},${2=$1},${5=1}
  -e[^-1] "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and curvature $4."
  -v - -to_a -repeat @# -l[$>]
    dx={if(@{-is_percent\ $1},w*$1,$1)}
    dy={if(@{-is_percent\ $2},h*$2,$2)}
    sigma={if(@{-is_percent\ $3},max(w,h)*$3,$3)}
    w={w} h={h} s={s} --channels 100% coords=@{-autocrop_coords[-1]\ 0} -rm[-1] -crop $coords  # Crop part with opaque pixels.
    -r {w+abs($dx)},{h+abs($dy)},1,100%,0,0,{if($dx>0,0,1)},{if($dy>0,0,1)} -r[-1] {w+4*$sigma},{h+4*$sigma},1,100%,0,0,0.5,0.5
    --channels[-1] 100%
    -if {!$4} -shift[-1] $dx,$dy # Flat shadow.
    -else # Curved shadow.
      (0;{pi}) -r[-1] [-2],3 -sin[-1] -*[-1] -$4 -+[-1] 1 -*[-1] $dx
      (0,{pi}) -r[-1] [-2],3 -sin[-1] -*[-1] -$4 -+[-1] 1 -*[-1] $dy
      -a[-2,-1] c -warp[-2] [-1],1,0,0 -rm[-1]
    -endif
    -b[-1] $sigma,0
    -r[-1] 100%,100%,1,2,0,0,0,0,0,1 -mv[-1] 0 -blend alpha
    --channels[-1] 100% -ge[-1] 1 -* -autocrop 0
    -if {!$5} $w,$h,1,$s -j[-1] [-2],{arg(1,$coords)},{arg(2,$coords)} -rm[-2] -endif
  -endl -done -v +

#@gmic ellipsionism : _R>0[%],_r>0[%],_smoothness>=0[%],_opacity,_outline>0,_density>0
#@gmic : Apply ellipsionism filter to selected images.
#@gmic : Default values: 'R=10', 'r=3', 'smoothness=1%', 'opacity=0.7', 'outlise=8' and 'density=0.6'.
#@gmic : $ image.jpg --ellipsionism ,
ellipsionism : -check "${1=10}>0 && ${2=3}>0 && ${5=8}>0 && ${6=0.6}>0" -skip ${3=1%},${4=0.7}
  -e[^-1] "Apply ellipsionism filter to image$?, with radii ($1,$2), smoothness $3, opacity $4 and outline $5."
  -v - -to_rgba -repeat @# -l[$>]

    # Compute contour angle.
    --luminance -g[-1] xy -a[-2,-1] c -b[-1] $3 -orientation[-1]
    -sh[-1] 0,0 -sh[-2] 1,1 -atan2[-1] [-2] -*[-1] {180/pi} -+[-1] 90 -rm[-2,-1] -channels[-1] 1,1

    # Render ellipses.
    [-2],[-2],1,[-2]
    -repeat {$6*w*h/max($1,$2)}
      xy={?(w)},{?(h)}
      -ellipse[-1] $xy,$1,$2,@{-2,($xy)},$4,\
                   @{-3,($xy,0,0)},@{-3,($xy,0,1)},@{-3,($xy,0,2)},@{-3,($xy,0,3)}
      -ellipse[-1] $xy,$1,$2,@{-2,($xy)},$4,0x1,\
                   {@{-3,($xy,0,0)}/$5},{@{-3,($xy,0,1)}/$5},{@{-3,($xy,0,2)}/$5},{@{-3,($xy,0,3)}/$5}
    -done -rm[-2]

    # Renormalize and prepare next image.
    -n[-1] [-2] -blend[-2,-1] alpha
  -endl -done -v +

#@gmic fire_edges : _edges>=0,0<=_attenuation<=1,_smoothness>=0,_threshold>=0,_nb_frames>0,_starting_frame>=0,frame_skip>=0
#@gmic : Generate fire effect from edges of selected images.
#@gmic : Default values: 'edges=0.7', 'attenuation=0.25', 'smoothness=0.5', 'threshold=25', 'nb_frames=1', 'starting_frame=20' and 'frame_skip=0'.
#@gmic : $ image.jpg -fire_edges ,
fire_edges : -check "${1=0.7}>=0 && ${2=0.25}>=0 && $2<=1 && ${3=0.5}>=0 && ${4=25}>=0 && ${5=1}>0 && ${6=20}>=0 && ${7=0}>=0"
  -e[^-1] "Generate fire effect from edges of image$?, with edges $1, attenuation $2, smoothness $3, threshold $4, "\
          "$5 frames, starting frame $6 and frame skip $7."
  -v - -repeat @# -l[$>] nm=@{0,n}
    -norm --gradient_norm -n[-1] 0,1 -roundify[-1] $1 -f[0] 0
    (0,0,0;0,0,0;1,1,1;0,1,0) -*[-1] {(1-$2^4)/4}
    -repeat {$5*(1+$7)+$6}
      @{0,w},@{0,h} -rand[-1] 0,255 -*[-1] [1]
      -b[-1] $3
      -if $4 -ge[-1] $4% -else -equalize[-1] -endif
      -n[-1] 0,255
      -j[0] [-1],0,0,0,0,1,[1],1 -rm[-1]
      -correlate[0] [2]
      -if {$>>=$6" && "($>-$6)%($7+1)==0} [0] -endif
    -done -rm[0-2]
  -nm $nm,1 -endl -done
  (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r[-1] 256,1,1,3,3
  -map[^-1] [-1] -rm[-1] -v +

#@gmic glow : _amplitude>=0
#@gmic : Add soft glow on selected images.
#@gmic : Default value: 'amplitude=1%'.
#@gmic : $ image.jpg --glow ,
glow : -skip ${1=1%}
  -e[^-1] "Add soft glow on image$?, with amplitude $1."
  -v - -repeat @# -l[$>] -split_opacity --b[0] $1 -n[-1] [0] -blend_edges[0,-1] 1 -a c -endl -done -v +

#@gmic halftone : nb_levels>=2,_size_dark>=2,_size_bright>=2,_shape={ 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle },_smoothness[%]>=0
#@gmic : Apply halftone dithering to selected images.
#@gmic : Default values: 'nb_levels=5', 'size_dark=8', 'size_bright=8', 'shape=5' and 'smoothnesss=0'.
#@gmic : $ image.jpg --halftone ,
halftone : -check "${1=5}>=2 && ${2=8}>=2 && ${3=8}>=2 && ${5=0}>=0" -skip ${4=5}
  -v - s0="square" s1="diamond" s2="circle" s3="inv-square" s4="inv-diamond" s5="inv-circle" -v +
  -e[^-1] "Apply halftone dithering to image$?, with $1 levels, dark size $3, bright size $4, "${s$4}" shape and smoothness $5."
  -v - -repeat @# -l[$>] -s c -repeat @# -l[$>]
    (0,255) -a y -quantize $1,0 -rows 0,{h-2}
    -repeat $1
      s={round(($2*$<+$3*$>)/($1-1))}
      $s,$s -=[-1] 1,50%,50% -distance[-1] 1,{$4%3} --shift[-1] 50%,50%,0,0,2 -min[-2,-1]
      -if {$4>=3} -lt[-1] {100*$</($1-1.1)}% -*[-1] {-255} -+[-1] {255-$>}
      -else -lt[-1] {100*$>/($1-1.1)}% -*[-1] 255 --[-1] $>
      -endif
      -r[-1] [-2],0,2 -b[-1] $5 --eq[-2] $> -*[-2,-1] -+[-2,-1]
    -done -endl -done -a c
  -endl -done -v +

#@gmic hardsketchbw : _amplitude>=0,_density>=0,_opacity,0<=_edge_threshold<=100,_is_fast={ 0 | 1 }
#@gmic : Apply hard B&W sketch effect on selected images.
#@gmic : Default values: 'amplitude=1000', 'sampling=3', 'opacity=0.1', 'edge_threshold=20' and 'is_fast=0'.
#@gmic : $ image.jpg --hardsketchbw 200,70,0.1,10 -median[-1] 2 --local -reverse -blur[-1] 3 -blend overlay -endlocal
hardsketchbw : -skip ${1=300},${2=50},${3=0.1},${4=20},${5=0}
  -e[^-1] "Apply hard B&W sketch effect on image$?, with amplitude $1, density $2, opacity $3 and edge threshold $4."
  -if {!$2} -channels 0 -f 255 -return -endif
  -v - -luminance -n 0,1

  -if $5 # Fast version.
    -repeat @# -l[$>] nm=@{0,n}
      -g xy -rv -*[-2] -1 -a c
      -if $4 --norm -ge[-1] $4% -* -endif
      100%,100%,1,1,255 -quiver[-1] [-2],{max(1,10-$2/6)},$1,0,$3 -rm[-2]
    -nm $nm,1 -endl -done

  -else # Slower version.
    -repeat @# -l[$>] nm=@{0,n}

      # Isolate starting points and tangents.
      w={w} h={h} -g xy -rv -*[-2] -1 -a c -* $1
      --norm -ge[-1] $4% 100%,100% -noise[-1] $2,2 -*[-2,-1]

      # Retrieve points coordinates and corresponding tangents.
      -pointcloud3d[-1] -s3d[-1] -rm[-6--5,-3--1] -r[-1] 3,{h/3},1,1,-1 -s[-1] x -rm[-1] -a[-2,-1] c
      -warp[-2] [-1],0,0 ---[-1] [-2] -+[-3,-2] -s[-2,-1] c

      # Convert as a 3d object and render on white background.
      -i[-3] 1,{h} 1,{h} -a[-6--1] x
      -i[-2] ({'CImg3d'}) -i[-2] ({2*h},{h})
      1,{h},1,1,2 1,{h},1,1,2*y --+[-1] 1 -a[-3--1] x
      3,{h} 1,{h},1,1,$3 -y[-6--1] -a[-6--1] y
      $w,$h,1,1,255 -object3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
    -nm $nm,1 -endl -done
  -endif -v +

#@gmic hearts : _density>=0
#@gmic : Apply heart effect on selected images.
#@gmic : Default value: 'density=10'.
#@gmic : $ image.jpg --hearts ,
hearts : -skip ${1=10}
  -e[^-1] "Apply heart filter on image$?, with density $1."
  -v - -repeat @# -l[$>]
    100%,100%,1 -noise[-1] $1,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2] -_heart9x7
    -mirror[-1] y -dilate[-2] [-1] -rm[-1]
  -endl -done -v +

_heart9x7 :
  (0,1,1,0,0,0,1,1,0;1,1,1,1,0,1,1,1,1;1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,1,0,0,0,0)

#@gmic houghsketchbw : _density>=0,_radius>0,0<=_threshold<=100,0<=_opacity<=1,_votesize[%]>0
#@gmic : Apply hough B&W sketch effect on selected images.
#@gmic : Default values: 'density=8', 'radius=5', 'threshold=80', 'opacity=0.1' and 'votesize=100%'.
#@gmic : $ image.jpg --houghsketchbw ,
houghsketchbw : -check "${1=8}>=0 && ${2=5}>=0 && ${3=80}>=0 && $3<=100 && ${4=0.1}>=0 && $4<=1 && ${5=100%}>0"
  -e[^-1] "Apply hough B&W sketch effect on image$?, with density $1, radius $2, threshold $3, opacity $4 and votesize $5."
  -v - -luminance -repeat @# -l[$>] nm=@{0,n}

    # Compute normalized Hough transform.
    res={round(if(@{-is_percent\ $5},$5*max(w,h),$5))} w={w} h={h} rhomax={sqrt(w^2+h^2)/2}
    -hough $res,$res -n 0,255

    # Retrieve coordinates of maximas in hough space.
    -normalize_local[-1] $1,$2 -ge[-1] $3% -pointcloud3d[-1]
    -s3d[-1] -rm[-6--5,-3--1] -r[-1] 3,{h/3},1,1,-1 -columns[-1] 0,1

    # Convert to (x0,y0)-(x1,y1) line coordinates.
    -s[-1] x,2
    -*[-2] {2*pi/$res}                   # theta
    -*[-1] {$rhomax/$res}                # rho
    --cos[-2] -*[-1] [-2] -+[-1] {$w/2}  # x
    --sin[-3] -*[-1] [-3] -+[-1] {$h/2}  # y
    -rm[-3]                              # Remove rho
    -i[-3] [-3]
    -cos[-4] -sin[-3] -*[-4,-3] 10000    # cos(t) sin(t)
    --+[-2] [-3]                         # x + sin(t)
    ---[-2] [-5]                         # y - cos(t)
    --[-4] [-5]                          # x - sin(t)
    -+[-3] [-6]                          # y + cos(t)
    -rm[-6,-5]

    # Transform as a 3d object.
    -i[-3] 1,{h} 1,{h} -a[-6--1] x                  # Vertices
    -i[-2] ({'CImg3d'}) -i[-2] ({2*h},{h})          # Header and size.
    1,{h},1,1,2 1,{h},1,1,2*y --+[-1] 1 -a[-3--1] x # Primitives.
    3,{h},1,1,0 1,{h},1,1,$4                        # Colors and opacities
    -y[-6--1] -a[-6--1] y

    # Render on a white image.
    $w,$h,1,1,255 -object3d[-1] [-2],0,0,0,1,1,0,0 -rm[-2]
  -nm $nm,1 -endl -done -v +

#@gmic lightrays : 100<=_density<=0,_cx,_cy,_ray_length>=0,_ray_attenuation>=0
#@gmic : Generate ray lights from the edges of selected images.
#@gmic : Defaults values : 'density=50%', 'cx=0.5', 'cy=0.5', 'ray_length=0.9' and 'ray_attenuation=0.5'.
#@gmic : $ image.jpg --lightrays , -+ -c 0,255
lightrays : -check "${1=50}>=0 && $1<=100 && ${4=1} && ${5=1}>=0" -skip ${2=0.5},${3=0.5}
  -e[^-1] "Generate ray lights from image$?, with density $1, center ($2,$3), ray length $4 and attenuation $5."
  -v - -repeat @# -l[$>]
    -gradient_norm -* -1 -lt $1% -euclidean2polar $2,$3
    -repeat {log2(w)} --shift[-1] {2^$>} -+[-2,-1] -done
    -function1d 0.5,0,1,{$4*w},1,{1+($4+1-$5)*w},0 -r[-1] @{-2,w},1,1,1,0
    (1,{w}) -r[-1] @{-2,w},1,1,1,3 -/[-2,-1]
    -r[-1] [-2] -*[-2,-1] -polar2euclidean $2,$3 -n 0,255
  -endl -done -v +

#@gmic light_relief : _ambient_light,_specular_lightness,_specular_size,_light_smoothness,_darkness,_xl,_yl,_zl,_zscale,_opacity_bumpmap={ 0 | 1 }
#@gmic : Apply relief light to selected images.
#@gmic : Default values(s) : 'ambient_light=0.3', 'specular_lightness=0.5', 'specular_size=0.2', 'darkness=0', 'xl=0.2', 'yl=zl=0.5',
#@gmic : 'zscale=1', 'opacity=1' and 'opacity_bumpmap=0'.
#@gmic : $ image.jpg --blur 2 -light_relief[-1] 0.3,4,0.1,0
light_relief : -skip ${1=0.3},${2=0.5},${3=0.2},${4=0},${5=0.2},${6=0.5},${7=0.5},${8=1},${9=1},${10=0}
  -e[^-1] "Apply relief light to image$?."
  -v - -repeat @# -l[$>]
    ({-$6},{1-$6};{-$6},{1-$6}^{-$7},{-$7};{1-$7},{1-$7}^$8,$8;$8,$8) -r[-1] [-2],[-2],1,3,3  # Create light vector field.
    -if $10 --channels[-2] 3 -to_rgb[-3] -else --to_rgb[-2] -norm[-1] -endif
    -b[-1] $5% -g[-1] xy 100%,100%,1,1,$9  -a[-3--1] c                                        # Create normal vector field.
    -orientation[-2,-1] -*[-2,-1] -s[-1] c -+[-3--1]                                          # Normalized scalar product.
    100%,100% -=[-1] 1,{$6*100}%,{$7*100}% -distance[-1] 1 -sqr[-1] -*[-1] -1                 # Compute specular attenuation.
    -/[-1] {($3*max(w,h))^2} -exp[-1] -*[-1] $2 -+[-1] $1
    -*[-2,-1] --[-1] $4 -*[-1] @{-2,M}
    -split_opacity[0] -+[0,-1] -a c -c 0,255
  -endl -done -v +

#@gmic mosaic : _density>=0,_edges={ 0 | 1 }
#@gmic : Create random mosaic from selected images.
#@gmic : Default values: 'density=0.8' and 'edges=1'.
#@gmic : $ image.jpg --mosaic ,
mosaic : -skip ${1=0.8},${2=1}
  -e[^-1] "Apply mosaic effect on image$?, with density $1."
  -v - -repeat @# -l[$>]
    label0={1+im} -+ $label0
    100%,100% -noise[-1] {$1*2},2 -*[-2] [-1] -distance[-1] 1 -*[-1] -1 -watershed[-2] [-1],{if($2,0,1)} -rm[-1]
    -if $2 --l[-1] -gt 0 -s c -and -endl --[-2] $label0 -*[-2,-1] -else --[-1] $label0 -endif
  -endl -done -v +

#@gmic old_photo
#@gmic : Apply old photo effect on selected images.
#@gmic : $ image.jpg --old_photo
old_photo :
  -e[^-1] "Apply old photo effect on image$?."
  -v - -noise 20 -bilateral 30,60 -b 2 -sharpen 100 -frame_fuzzy 20,20,6,3 -to_rgb -shadow_patch 0.75 -n 0,255 -sepia -v +

#@gmic pencilbw : _size>=0,_amplitude>=0
#@gmic : Apply B&W pencil effect on selected images.
#@gmic : Default values: 'size=0.3' and 'amplitude=60'.
#@gmic : $ image.jpg --pencilbw ,
pencilbw : -skip ${1=0.3},${2=60}
  -e[^-1] "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
  -v - -repeat @# -l[$>] -split_opacity -l[0] -norm -b $1 -sharpen 4000 -smooth $2,0,1 -equalize -sqrt -n 0,255 -endl -a c -endl -done -v +

#@gmic polaroid : _size1>=0,_size2>=0
#@gmic : Create polaroid effect in selected images.
#@gmic : Default values: 'size1=10' and 'size2=20'.
#@gmic : $ image.jpg -to_rgba -polaroid 5,30 -rotate 20 -drop_shadow , -display_rgba
polaroid : -check "${1=10}>=0 && ${2=20}>=0"
  -e[^-1] "Create polaroid effect in image$?, with borders sizes $1 and $2."
  -v - -- 255 -r {100+$1}%,{100+$1}%,1,100%,0,0,0.5,0.5 -r 100%,{100+$2}%,1,100%,0,0,0 -+ 255 -v +

#@gmic polygonize : _warp_amplitude>=0,_smoothness[%]>=0,_min_area[%]>=0,_resolution_x[%]>0,_resolution_y[%]>0
#@gmic : Apply polygon effect on selected images.
#@gmic : Default values: 'warp_amplitude=300', 'smoothness=2%', 'min_area=0.1%', 'resolution_x=resolution_y=10%'.
#@gmic : $ image.jpg --polygonize ,
polygonize : -check "${1=300}>=0 && ${2=2%}>=0 && ${3=0.1%}>=0 && ${4=10%}>0 && ${5=$4}>0"
  -e[^-1] "Polygonize image$? with warp amplitude $1, smoothness $2, minimal area $3 and resolutions ($4,$5)."
  -v -  -repeat @# -l[$>]
    --b $2 -gradient_norm[-1] -gradient[-1] -a[-2,-1] c -channels[-1] 0,2 -*[-1] {1/0.1+max(abs(im),abs(iM))}
    resx={max(1,round(if(@{-is_percent\ $4},w*$4,w/$4)-1))}
    resy={max(1,round(if(@{-is_percent\ $5},h*$5,h/$5)-1))}
    -plane3d 1,1,$resx,$resy -*3d[-1] @{0,w-1},@{0,h-1},1
    -s3d[-1] -rm[-2] -i[-2] (0;{h-1}) -r[-2] 3,{h},1,1,3 -round[-2] -y[-2]
    [-4] -a[-7--2] y -r[-1] 3,{h/3},1,1,-1 -z[-1] 0,1 -permute[-1] yzcx
    -repeat $1 --warp[1] [-1],0,0 -+[-2,-1] -done
    -permute[-1] cxyz -z[-1] 0,2 -y[-1] -j[2] [-1],0,8 -rm[-3,-1]
    [0],[0] -object3d[-1] [1],0,0,0,1,2 -rm[1]
    -if {$3>0}
      min_area=@{0,if(@{-is_percent\ $3},$3*w*h,$3)}
      --area[-1] 0,1 -ge[-1] $min_area -+[-2] 1 -*[-2] [-1] -distance[-1] 1 -*[-1] -1 -watershed[-2] [-1] -rm[-1]
    -endif
    -blend[0,-1] shapeaverage
  -endl -done -v +

#@gmic poster_edges : 0<=_edge_threshold<=100,0<=_edge_shade<=100,_edge_thickness>=0,_edge_antialiasing>=0,0<=_posterization_level<=15,_posterization_antialiasing>=0
#@gmic : Apply poster edges effect on selected images.
#@gmic : Default values: 'edge_threshold=40', 'edge_shade=5', 'edge_thickness=0.5', 'edge_antialiasing=10', 'posterization_level=12' and 'posterization_antialiasing=0'.
#@gmic : $ image.jpg --poster_edges ,
poster_edges : -check "${1=40}>=0 && $1<=100 && ${2=5}>=0 && $2<=100 && ${3=0.5}>=0 && ${4=10}>=0 && ${5=12}>=0 && $5<=15 && ${6=0}>=0"
  -e[^-1] "Apply poster edge on image$?, with edge threshold $1, edge shade $2, edge thickness $3, edge antialiasing $4, $5 level of posterization and posterization antialiasing $6."
  -v - -repeat @# -l[$>] -split_opacity -l[0]
    --gradient xy,1 -a[-2,-1] c -norm[-1] -b[-1] $3 -n[-1] 0,255
    -apply_curve[-1] 1,0,1,{max(0,(100-($1%)^0.1*100)*255%)},0.99,{min(255,(101-($1%)^0.1*100+$2)*255%)},0.01,255,0 -c[-1] 0,1
    -if $4 -smooth[-1] {min(50,$4)},0,1,{$4/40},{$4/40},0.8,90 -endif
    -if $5 -autoindex[0] {round((4-sqrt($5+1))*32+2)} -endif
    -if $6 -smooth[0] {min(50,$6)},0,1,{$6/40},{$6/40},0.8,90 -endif
    -*
  -endl -a c -endl -done -v +

#@gmic poster_hope : _smoothness>=0
#@gmic : Apply Hope stencil poster effect on selected images.
#@gmic : Default value: 'smoothness=3'.
#@gmic : $ image.jpg --poster_hope ,
poster_hope : -check "${1=3}>=0"
  -e[^-1] "Apply Hope stencil poster effect on image$?, with smoothness $1."
  -v - -repeat @# -l[$>] -to_rgb
    -apply_parallel_channels "-smooth 200,0,1,$1,1"
    -quantize 7,0 -f 'if(i!=5,i,i+1-2*(y%2))'
    (0,32,47;0,32,47;209,1,23;209,1,23;90,141,145;-1,-1,-1;253,221,138) -permute[-1] yzcx
    -map[0] [1] -rm[1]
  -endl -done -v +

#@gmic rodilius : 0<=_amplitude<=100,_0<=thickness<=100,_sharpness>=0,_nb_orientations>0,_offset,_color_mode={ 0=darker | 1=brighter }
#@gmic : Apply rodilius (fractalius-like) filter on selected images.
#@gmic : Default values: 'amplitude=10', 'thickness=10', 'sharpness=400', 'nb_orientations=7', 'offset=0' and 'color_mode=1'.
#@gmic : $ image.jpg --rodilius 12,10,300,10 -normalize_local[-1] 10,6
rodilius : -check "${1=10}>=0 && $1<=200 && ${2=10}>=0 && $2<=100 && ${3=400}>=0 && ${4=7}>0" -skip ${5=0},${6=1}
  -e[^-1] "Apply rodilius filter on image$? with amplitude $1, thickness $2, sharpness $3, $4 orientations, offset $5 and "\
    @{-arg\ 1+!$6,brighter,darker}" color mode."
  -v - -repeat @# -l[$>] -split_opacity -rv
    -if {!$6} -negative[-1] -endif
    --f[-1] 0 -nm[-1] @{-2,n}
    -repeat {round($4)}
      angle={$5+$>*180/round($4)}
      --blur_linear[-2] $1%,{$1*$2/100}%,$angle,1 -b[-1] 0.7 -sharpen[-1] $3 -max[-2,-1]
    -done -rm[-2]
    -if {!$6} -negative[-1] -endif
  -rv -a c -endl -done -v +

#@gmic stained_glass : _edges[%]>=0, shading>=0, is_thin_separators={ 0 | 1 }
#@gmic : Generate stained glass from selected images.
#@gmic : Default values: 'edges=40%', 'shading=0.2' and 'is_precise=0'.
#@gmic : $ image.jpg --stained_glass ,
stained_glass : -check "${1=40%}>=0 && ${2=0.2}>=0" -skip ${3=0}
  -e[^-1] "Apply stained glass effect on image$?, with edges $1, shading $2 and thin-separators "@{-arg\ 1+!$3,enabled,disabled}"."
  -v - -repeat @# -l[$>]
    im={1+im} -+ $im  # Ensure positiveness of image labels.
    --gradient_norm -ge[-1] $1 -*[-2] [-1]
    -distance[-1] 1 -sharpen[-1] 1e10 -neq[-1] 0
    -if $3 -skeleton[-1] 0 -endif
    -distance[-1] 1 -watershed[-2] [-1] --[-2] $im
    -n[-1] 0,1  -^[-1] $2 -*
  -endl -done -v +

#@gmic star : _width>0,_height>0
#@gmic : Input star binary mask with specified size.
#@gmic : $ -star ,
star : -check "${1=512}>=1 && ${2=$1}>=1"
  -e[^-1] "Input $1x$2 star binary mask."
  -v - -l[]
    -star3d 5,0.5 -col3d 1 -c3d -n3d -*3d $1,$2
    $1,$2 -object3d[-1] [-2],50%,50%,0,1,2 -rm[-2]
    -nm "[Heart binary mask]"
  -endl -v +

#@gmic stars : _density[%]>=0,_depth>=0,_size>0,_nb_branches>=1,0<=_thickness<=1,_smoothness[%]>=0,_R,_G,_B,_opacity
#@gmic : Add random stars to selected images.
#@gmic : Default values: 'density=10%', 'depth=1', 'size=32', 'nb_branches=5', 'thickness=0.38', 'smoothness=0.5', 'R=G=B=200' and 'opacity=1'.
#@gmic : $ image.jpg -stars ,
stars : -check "${1=10%}>=0 && ${2=1}>=0 && ${3=32}>0 && ${4=5}>=1 && ${5=0.38}>=0 && $5<=1 && ${6=0.5}>=0" -skip ${7=200},${8=$7},${9=$8},${10=1}
  -e[^-1] "Add $1 random stars to image$?, with depth $2, size $3, $4 branches, thickness $5, smoothness $6, color ($7,$8,$9) and opacity $10."
  -v -

  # Generate star sprites.
  -star3d $4,$5 -col3d[-1] 255 -*3d[-1] $3
  -l[-1] -repeat 4 {round(2*$3)},{round(2*$3)} -object3d[-1] [0],50%,50%,0,1,2,0,0 -r3d[0] 0,0,1,90 -done -rm[0] -endl
  -autocrop[-4--1] 0 -r2dy[-4--1] $3 -b[-4--1] $6,0 -r[-4--1] 100%,100%,1,4
  -repeat 4 -sh[{-1-$>}] 0,2 -fc[-1] $7,$8,$9 -rm[-1] -done

  # Draw stars on selected images.
  -repeat {@#-1} [-4--1] -l[$>,-4--1]
    N={round(if(@{-is_percent\ $1},w*h*$1,$1)/4,1,1)}
    -repeat 4
      2,$N -rand[-1] -1,1 1,$N -rand[-1] 0,1 -a[-2,-1] x
      -i[-2] ({'CImg3d'}) -+[-2] 0.5 -i[-2] ($N;$N)
      (1,0;1,{$N-1}) -r[-1] 2,$N,1,1,3 -round[-1] 4,$N,1,1,1 -y[-5,-3--1] -a[-5--1] y
      -rv[-2,-1] -sprites3d[-2,-1] -*3d[-1] {0.75*@{0,w}},{0.75*@{0,h}},{1000*$2}
      -object3d[0] [-1],50%,50%,0,$10,0,0,0 -rm[-1]
    -done
  -endl -done
  -rm[-4--1] -v +

#@gmic sketchbw
#@gmic : _nb_orients>0,_start_angle,_angle_range>=0,_length>=0,_threshold>=0,
#@gmic : _opacity,_bgfactor>=0,_density>0,_sharpness>=0,
#@gmic : _anisotropy>=0,_smoothness>=0,_coherence>=0,_is_boost={ 0 | 1 },_is_curved={ 0 | 1 }\n
#@gmic : Apply sketch effect to selected images.
#@gmic : Default values: 'nb_orients=2', 'start_angle=45', 'angle_range=180', 'length=30', 'threshold=1', 'opacity=0.03',
#@gmic : 'bgfactor=0', 'density=0.6', 'sharpness=0.1', 'anisotropy=0.6', 'smoothness=0.25', 'coherence=1', 'is_boost=0' and 'is_curved=1'.
#@gmic : $ image.jpg --sketchbw 1 --local -reverse -blur[-1] 3 -blend overlay -endlocal
sketchbw :
  -check "${1=2}>0 && ${3=180}>=0 && ${4=30}>=0 && ${5=1}>=0 && ${7=0}>=0 && ${8=0.6}>0 && ${9=0.1}>=0 && ${10=0.6}>=0 && ${11=0.25}>=0 && ${12=1}>=0"
  -skip ${2=45},${6=0.03},${13=0},${14=1}
  -e[^-1] "Apply B&W sketch effect on image$?."
  -v - -diffusiontensors $9,$10,$11,$12
  w=1 h=1 -i[0] 1 -m3d 0

  -repeat {@#-1}
    -/[-1] {max(iM,im)} -s[-1] c        # Normalize and split tensor coefficients.
    100%,100%,1,1,255 -nm[-1] @{-4,n},1 # Create rendering B&W image.

    -if {$w!=w||$h!=h}               # Create set of random coordinates, if necessary.
      -rm[0] {$8*w*h/($1*sqrt($4))}
      --rand[-1] 0,{@{-2,h}-1} -rand[-2] 0,{@{-3,w}-1} -a[-2,-1] y -mv[-1] 0
      w={w} h={h}
    -endif

    -if $14 # Render sketch with curved strokes
      -repeat $1
        alpha={($2+$>*$3/$1)*pi/180}
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        -a[-2,-1] c -channels[-1] 0,2
        -if $13 -orientation[-1] -endif
        -repeat @{0,w}
          xy=@{0,($>,0)},@{0,($>,1)}
          -if {@{-5,($xy)}+@{-3,($xy)}<$5} opac=$6 -else opac={$7*$6} -endif
          -if $opac
            --streamline3d[-1] $xy,0,$4,0.8,0,0,1 -col3d[-1] 0 -object3d[-3] [-1],0,0,0,$opac,1,0,0 -rm[-1]
            --streamline3d[-1] $xy,0,$4,0.8,0,1,1 -col3d[-1] 0 -object3d[-3] [-1],0,0,0,$opac,1,0,0 -rm[-1]
          -endif
        -done
        -rm[-1]
      -done

    -else # Render sketch with straight strokes
      -repeat $1
        alpha={($2+$>*$3/$1)*pi/180}
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        --*[-4] {cos($alpha)} --*[-4] {sin($alpha)} -+[-2,-1]
        -a[-2,-1] c
        -if $13 -orientation[-1] -endif
        -repeat @{0,w}
          x=@{0,($>,0)} y=@{0,($>,1)}
          -if {@{-5,($x,$y)}+@{-3,($x,$y)}<$5} opac=$6 -else opac={$7*$6} -endif
          -if $opac
            -line[-2] {$x-$4*@{-1,($x,$y,0,0)}},{$y-$4*@{-1,($x,$y,0,1)}},\
                      {$x+$4*@{-1,($x,$y,0,0)}},{$y+$4*@{-1,($x,$y,0,1)}},\
                      {3*$opac},0
          -endif
        -done
        -rm[-1]
      -done

    -endif
    -rm[-4--2]
  -mv[-1] 1 -done -rm[0] -v +

#@gmic sponge : _size>0
#@gmic : Apply sponge effect on selected images.
#@gmic : Default value: 'size=13'.
#@gmic : $ image.jpg --sponge ,
sponge : -skip ${1=13}
  -e[^-1] "Apply sponge filter on image$?, with brush size $1."
  -v - -repeat @# -l[$>]
    100%,100%,1,1 -noise[-1] 20,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2]
    -_circle $1 -dilate[-2] [-1] -rm[-1]
  -endl -done -v +

_circle :
  -if {$1%2==0} -i 2,2 -else -i 1 -endif
  -+[-1] 1 -r[-1] $1,$1,1,1,0,0,0.5,0.5 -distance[-1] 1 -n[-1] 0,1 -sqrt[-1] -c[-1] 0.85,0.86 -*[-1] -1 -n[-1] 0,1

#@gmic stencil : _radius[%]>=0,_smoothness>=0,_iterations>=0
#@gmic : Apply stencil filter on selected images.
#@gmic : Default values: 'radius=3', 'smoothness=1' and 'iterations=8'.
#@gmic : $ image.jpg --stencil 1,10,3
stencil : -check "${1=3}>=0 && ${2=1}>=0 && ${3=8}>=0"
  -e[^-1] "Apply stencil filter on image$?, with radius $1, smoothness $2 and $3 iterations."
  -v - -n 0,1 -repeat $3 -b $1 -unsharp {$1+$2},1000 -c 0,255 -done -v +

#@gmic stencilbw : _edges>=0,_smoothness>=0
#@gmic : Apply B&W stencil effect on selected images.
#@gmic : Default values: 'edges=15' and 'smoothness=10'.
#@gmic : $ image.jpg --stencilbw 40,4
stencilbw : -skip ${1=15},${2=10}
  -e[^-1] "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
  -v - -repeat @# -l[$>] -split_opacity -luminance[0] -n[0] 0,255
    --edges[0] $1 -quantize[0] 3,0,1 -b[0] $2
    -sharpen[0] 1000000 -n[0] 0,1 -*[0,-1] -n[0] 0,255
  -a c -endl -done -v +

#@gmic tetris : _scale>0
#@gmic : Apply tetris effect on selected images.
#@gmic : Default value: 'scale=10'.
#@gmic : $ image.jpg --tetris 10
tetris : -skip ${1=10}
  -e[^-1] "Apply tetris effect on image$?, with scale $1."
  -v - -repeat @# -l[$>]
    wh={w},{h},1,{s} -r $1%,$1%,$1%,100%,2 -n 0,255 -quantize 10,1,0 -r $wh -b 2 -sharpen 300,1
  -endl -done -v +

#@gmic warhol : _M>0,_N>0,_smoothness>=0,_color>=0
#@gmic : Create MxN Andy Warhol-like artwork from selected images.
#@gmic : Default values: 'M=3', 'N=M', 'smoothness=2' and 'color=20'.
#@gmic : $ image.jpg --warhol 5,3,3,40
warhol : -skip ${1=3},${2=$1},${3=2},${4=20}
  -e[^-1] "Create $1x$2 Andy Warhol-like artwork from image$?."
  -v - r0={100/max($1,$2)}
  -repeat @# -l[$>]
    -norm -b $3 -r $r0%,$r0%,1,100%,2 -quantize 6 -n 0,5 -round 1
    -repeat $1 -repeat $2
      (0,1,2,3,4,5) -n[-1] 32,224 6,1,1,2,128 -noise[-1] $4,0 -c[-1] 0,255 -a[-2,-1] c -ycbcr2rgb[-1] --map[0] [-1] -rm[-2]
    -done -done -append_tiles[^0] $1,$2 -nm[1] @{0,n},1 -rm[0]
  -endl -done -v +

#@gmic weave : _density>=0,0<=_thickness<=100,0<=_shadow<=100,_shading>=0,_fibers_amplitude>=0,_fibers_smoothness>=0,_angle,-1<=_x_curvature<=1,-1<=_y_curvature<=1
#@gmic : Apply weave effect to the selected images.
#@gmic : 'angle' can be { 0=0 deg. | 1=22.5 deg. | 2=45 deg. | 3=67.5 deg. }.
#@gmic : Default values: 'density=6', 'thickness=65', 'shadow=40', 'shading=0.5', 'fibers_amplitude=0', 'fibers_smoothness=0', 'angle=0' and 'curvature_x=curvature_y=0'
#@gmic : $ image.jpg --weave ,
weave : -check "${1=6}>=0 && ${2=65}>=0 && $2<=100 && ${3=40}>=0 && $3<=100 && ${4=0.5}>=0"
        -check "${5=0}>=0 && ${6=0}>=0 && ${7=0}>=0 && $7<=3 && ${8=0}>=-1 && $8<=1 && ${9=0}>=-1 && $9<=1"
  -e[^-1] "Apply weave effect to image$?, with $1 strips, thickness $2, shadow $3, shading $4, "\
          "fibers amplitude $5 and fibers smoothness $6, angle "{$7*22.5}" deg. and curvatures ($8,$9)."
  -v - -repeat @# -l[$>] -split_opacity -l[0]
    w={round(max(w,h)/$1,1,1)} h=$w s={(100-$3)*255%} p={max(0.01,$4)}

    # Create patterns.
    1,$h -=[-1] 1,0,50% -distance[-1] 1 -^[-1] $p -c[-1] 50%,100% -r[-1] {max(1,round($2*$w%))},100%
    $w,1 -=[-1] 1,50% -distance[-1] 1 -^[-1] $p -c[-1] 50%,100% -*[-1] -1 -r[-1] 100%,{max(1,round($2*$h%))}
    --*[-1] -1 --*[-3] -1 -n[-4,-2] 0,$s -n[-3,-1] $s,255
    {w},1 1,[-3] -rand[-2,-1] 0,1 -b[-2,-1] $6% -n[-2,-1] -$5,$5 -r[-1] [-4] -+[-5] [-1] -+[-4,-1] -+[-5] [-1] -+[-2,-1]
    --f[-3] 255 -a[-4,-1] c --f[-1] 255 -a[-2,-1] c

    amp_x={$8*($w-w)/2} amp_y={$9*($w-w)/2}
    -r[-4--1] $w,$h,1,100%,0,0,0.5,0.5
    -f[-4] 'i(x+$amp_x*sin(y/h*pi),y,0,c,1,2)' -f[-1] 'i(x-$amp_x*sin(y/h*pi),y,0,c,1,2)'
    -f[-3] 'i(x,y+$amp_y*sin(x/w*pi),0,c,1,2)' -f[-2] 'i(x,y-$amp_y*sin(x/w*pi),0,c,1,2)'
    -blend[-4,-3] alpha -blend[-2,-1] alpha -c[-2,-1] 0,255

    # Render full pattern and merge.
    -/[-2,-1] 255 [-1] [-3] -a[-4,-2] x -a[-2,-1] x -a[-2,-1] y -rotate_tileable[-1] {$7*22.5} -r[-1] [-2],[-2],1,1,0,2 -*[-2,-1]
  -endl -a c -endl -done -v +

#@gmic whirls : _texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0
#@gmic : Add random whirl texture to selected images.
#@gmic : Default values: 'texture=3', 'smoothness=6', 'darkness=0.5' and 'lightness=1.8'.
#@gmic : $ image.jpg --whirls ,
whirls : -skip ${1=3},${2=6},${3=0.5},${4=1.8}
  -e[^-1] "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
  -v - -repeat @# -l[$>]
    100%,100% -noise[-1] 0.3,2 -repeat $1 -b[-1] $2 -gradient_norm[-1] -^[-1] 0.2 -done
    -n[-1] $3,$4 -r[-1] [-2] -* -c 0,255
  -endl -done -v +

#------------------------------------
#
#@gmic :: Warpings
#
#------------------------------------

#@gmic euclidean2polar : _cx,_cy,_n>0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Apply euclidean to polar transform on selected images.
#@gmic : Default values: 'cx=cy=0.5', 'n=1' and 'boundary=1'.
#@gmic : $ image.jpg --euclidean2polar ,
euclidean2polar : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
  -e[^-1] "Apply euclidean to polar transform on image$?."
  -v - -repeat @# -l[$>]
    ({w},{h}) ($1,$2) -*[-2,-1] ({"sqrt(max("@{-1,0}","@{-2,w}"-"@{-1,0}")^2 + max("@{-1,1}","@{-2,h}"-"@{-1,1}")^2)"})
    -a[-2,-1] x
    [-2],[-2],1,1,@{-1,2}"*(x/w)^$3*cos(y*2*pi/h)" -+[-1] @{-2,0}
    [-1],[-1],1,1,@{-2,2}"*(x/w)^$3*sin(y*2*pi/h)" -+[-1] @{-3,1}
    -rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
  -endl -done -v +

#@gmic deform : _amplitude>=0
#@gmic : Apply random smooth deformation on selected images.
#@gmic : Default value: 'amplitude=10'.
#@gmic : $ image.jpg --deform[0] 10 --deform[0] 20
deform : -skip ${1=10}
  -e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
  -v - -repeat @# -l[$>]
    2%,2%,1,2 -noise[-1] $1 -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -endl -done -v +

#@gmic fisheye : _x,_y,0<=_radius<=100,_amplitude>=0
#@gmic : Apply fish-eye deformation on selected images.
#@gmic : Default values: 'x=y=50', 'radius=50' and 'amplitude=1.2'.
#@gmic : $ image.jpg --fisheye ,
fisheye : -skip ${1=50},${2=50},${3=50},${4=1.2}
  -e[^-1] "Apply Fish-eye effect on image$?, centered at ($1%,$2%) with radius $3% and amplitude $4."
  -if {$4==0} -return -endif
  -v - -repeat @# -l[$>]
    100%,100%,1,1 -=[-1] 1,$1%,$2% -distance[-1] 1 -c[-1] 0,$3% -*[-1] -1 -n[-1] 0,1 -^[-1] {1/$4}
    -i[-2] ({-$1/100},{1-$1/100};{-$1/100},{1-$1/100}^{-$2/100},{-$2/100};{1-$2/100},{1-$2/100}) -r[-2] [-1],[-1],1,2,3
    -n[-1] 0,{max(w,h)} -*[-2,-1]
    -warp[-2] [-1],1,1,1 -rm[-1]
  -endl -done -v +

#@gmic flower : _amplitude,_frequency,_offset_r[%],_angle,_cx,_cy,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Apply flower deformation on selected images.
#@gmic : Default values: 'amplitude=30', 'frequency=6', 'offset_r=0', 'angle=0', 'cx=cy=0.5' and 'boundary=2'.
#@gmic : $ image.jpg -flower ,
flower : -skip ${1=30},${2=6},${3=0},${4=0},${5=0.5},${6=0.5},${7=2}
  -e[^-1] "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 deg. and center ($1,$2)."
  -v - -repeat @# -l[$>]
    -euclidean2polar $5,$6,1,$7 -shift $3,0,0,0,2
    100%,100%,1,1,y -/[-1] {h} -*[-1] $2 ({$4/360}) -+[-2] @-1 -rm[-1] -*[-1] 6.2831853 -sin[-1]
    -*[-1] $1 -*[-1] {w} -/[-1] 100
    -channels[-1] 0,1 -warp[-2] [-1],1,1,$7 -rm[-1]
    -polar2euclidean $5,$6,1,1
  -endl -done -v +

#@gmic kaleidoscope : _cx,_cy,_radius,_angle,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Create kaleidoscope effect from selected images.
#@gmic : Default values: 'cx=cy=0.5', 'radius=100', 'angle=30' and 'boundary=1'.
#@gmic : $ image.jpg --kaleidoscope ,
kaleidoscope : -skip ${1=0.5},${2=0.5},${3=100},${4=30},${5=1}
  -e[^-1] "Create kaleidoscope effect from image$?, with center ($1,$2), radius $3, angle $4 deg."
  -v - -euclidean2polar $1,$2,1,$5 -repeat @# -l[$>]
    --columns 0,$3% -rows[-1] 0,$4% -r[-1] [-2],0,2 -nm[1] @{0,n} -rm[0]
  -endl -done -polar2euclidean $1,$2,1,$5 -v +

#@gmic map_sphere : _width>0,_height>0,_radius,_dilation>0,_fading>=0,_fading_power>=0
#@gmic : Map selected images on a sphere.
#@gmic : Default values: 'width=height=512', 'radius=100', 'dilation=0.5', 'fading=0' and 'fading_power=0.5'.
#@gmic : $ image.jpg --map_sphere ,
map_sphere : -check "${1=512}>0 && ${2=512}>0 && ${5=0}>=0 && ${6=0.5}>=0" -skip ${3=100},${4=0.5}
   -e[^-1] "Map image$? on spheres in $1x$2 images, with radius $3, dilation $4 and fading $5."
   -v - r2={($3*min($1,$2)/200)^2} # Compute squared radius.
   -repeat @# -l[$>]
     -i[-2] 100%,1,1,100%,0 -nm[0] @{1,n} -a y # Add one border line to have a sphere exterior.
     ({-$1/2},{$1/2}) ({-$2/2};{$2/2}) -r[-2,-1] $1,$2,1,1,3 -atan2[-1] [-2] -rm[-2] # Compute theta angle.
     $1,$2 -=[-1] 1,50%,50% -distance[-1] 1,3 -/[-1] $r2 -sqrt[-1] -c[-1] 0,1
     -asin[-1] # Compute phi angle.
     -+[-2] {pi} -*[-2] {(@{-3,w}-1)/(2*pi)} # Normalize theta to X-coordinates
     -*[-1] {2/pi} -^[-1] $4 -*[-1] {@{-3,h}-1} -*[-1] -1 -+[-1] {@{-3,h}-1} # Normalize phi to Y-coordinates
     -if $5 --ge[-1] 1 -distance[-1] 1 -c[-1] 0,$5% -n[-1] 0,1 -^[-1] $6 -c[-2] 1,100% --[-2,-1] -endif
     -r[-1,-2] 100%,100%,@{-3,d}
     --f[-1] z -a[-3--1] c
      -warp[-2] [-1],0,1,1 -rm[-1] # Apply image warping
   -endl -done -v +

#@gmic polar2euclidean : _cx,_cy,_n>0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Apply polar to euclidean transform on selected images.
#@gmic : Default values: 'cx=cy=0.5', 'n=1' and 'boundary=1'.
#@gmic : $ image.jpg --euclidean2polar , -mirror[-1] x -polar2euclidean[-1] ,
polar2euclidean : -skip ${1=0.5},${2=0.5},${3=1},${4=1}
  -e[^-1] "Apply polar to euclidean transform on image$?."
  -v - -repeat @# -l[$>]
    ({w},{h}) ($1,$2) -*[-2,-1] ({"sqrt(max("@{-1,0}","@{-2,w}"-"@{-1,0}")^2 + max("@{-1,1}","@{-2,h}"-"@{-1,1}")^2)"})
    -a[-2,-1] x
    [-2],[-2],1,1,"w*(sqrt((x-"@{-1,0}")^2 + (y-"@{-1,1}")^2)/"@{-1,2}")^(1/$3)"
    [-1],[-1],1,1,"(atan2(y-"@{-2,1}",x-"@{-2,0}")*h/(2*pi)+h)%h"
    -rm[-3] -a[-2,-1] c -warp[-2] [-1],0,1,$4 -rm[-1]
  -endl -done -v +

#@gmic raindrops : _amplitude,_density>=0,_wavelength>=0,_merging_steps>=0
#@gmic : Apply raindrops deformation on selected images.
#@gmic : Default values : 'amplitude=80','density=0.1', 'wavelength=1' and 'merging_steps=0'.
#@gmic : $ image.jpg --raindrops ,
raindrops : -check "${2=0.1}>=0 && ${3=1}>=0 && isint(${4=0}) && $4>=0" -skip ${1=80}
  -e[^-1] "Apply raindrops deformation on image$?, with amplitude $1, density $2, wavelength $3 and $4 merging steps."
  -v - -repeat @# -l[$>]
    100%,100% -noise[-1] $2,2 -distance[-1] 1 -f[-1] 'cos(i)/(1+i/$3)'
    -if $4
      -i[-2] (0,1,0;1,0,1;0,1,0) -/[-2] 2 [-1]
      -repeat $4 --convolve[-1] [-3],1 --[-1] [-3] -rm[-3] -done -rm[-3,-2]
    -endif
    -gradient[-1] -a[-2,-1] c -*[-1] {$1/(1e-5+max(abs(im),abs(iM)))}
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic ripple : _amplitude,_frequency,_shape={ 0=bloc | 1=triangle | 2=sine | 3=sine+ | 4=random },_angle,_offset
#@gmic : Apply ripple deformation on selected images.
#@gmic : Default values: 'amplitude=10', 'frequency=10', 'shape=2', 'angle=0' and 'offset=0'.
#@gmic : $ image.jpg --ripple ,
ripple : -skip ${1=10},${2=20},${3=2},${4=0},${5=0}
  -e[^-1] "Apply ripple deformation on image$?, with amplitude $1, frequency $2, shape $3, angle $4 deg. and offset $5."
  -v -
  theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
  -repeat @# -l[$>]
    100%,100%,1,1,"x" --[-1] {w/2} 100%,100%,1,1,'y'
    --[-1] {h/2-$5} -*[-2] $S -*[-1] $C -+[-2,-1]      # Generate rotated Y.
    -_ripple$3[-1] $1,$2                               # Generate warp field.
    --*[-1] {-$S} -*[-2] $C -a[-2,-1] c                # Rotate warp field.
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

_ripple0 : -f {$1/2}*"(1-2*(i%"{2*$2}"<$2))"
_ripple1 : -f "I=(i%$2)/$2;$1*(2*if(I<0.5,I,1-I)-0.5)"
_ripple2 : -f {-$1/2}*"cos(i*"{2*pi/$2}")"
_ripple3 : -f {-$1/2}*"abs(cos(i*"{2*pi/$2}"))"
_ripple4 : -skip $* -n 0,{h-1} 1,{h} -rand[-1] {-$1/2},{$1/2} m={im} M={iM} -b[-1] {$2/10} -n[-1] $m,$M -map[-2] [-1] -rm[-1]

#@gmic rotoidoscope : _cx,_cy,_tiles>0,_smoothness[%]>=0,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Create rotational kaleidoscope effect from selected images.
#@gmic : Default values: 'cx=cy=50%', 'tiles=10', 'smoothness=1' and 'boundary=1'.
#@gmic : $ image.jpg --rotoidoscope ,
rotoidoscope : -skip ${1=50%},${2=50%},${5=1} -check "${3=10}>0 && ${4=1}>=0"
  -e[^-1] "Create rotational kaleidoscope effect from image$?, with center ($1,$2), $3 tiles and smoothness $4."
  -v - -repeat @# -l[$>]
    -repeat $3 --rotate[0] {360/$3},1,$5,$1,$2 -blend_edges $4 -done
  -endl -done -v +

#@gmic symmetrize : _x[%],_y[%],_angle,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic },_is_antisymmetry={ 0 | 1 },_swap_sides={ 0 | 1 }
#@gmic : Symmetrize selected image regarding specified axis.
#@gmic : Default values: 'x=y=50%', 'angle=90', 'boundary=1', 'is_antisymmetry=0' and 'swap_sides=0'.
#@gmic : $ image.jpg --symmetrize 50%,50%,45 --symmetrize[-1] 50%,50%,-45
symmetrize : -skip ${1=50%},${2=50%},${3=90},${4=1},${5=0},${6=0}
  -e[^-1] "Symmetrize image$?, regarding axis ($1,$2,$3 deg.)."
  -v -
  theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
  -if $6 symmetry_cond=A<0 -else symmetry_cond=A>0 -endif
  -repeat @# -l[$>]
    x0={if(@{-is_percent\ $1},w*$1,$1)}
    y0={if(@{-is_percent\ $2},h*$2,$2)}
    -if $5 -f 'A=($y0-y)*$u-($x0-x)*$v;X=x+2*($x0-x);Y=y+2*($y0-y);if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
    -else -f 'A=($y0-y)*$u-($x0-x)*$v;X=x-2*$v*A;Y=y+2*$u*A;if($symmetry_cond,i(X,Y,z,c,1,$4),i)'
    -endif
  -endl -done
  -v +

#@gmic transform_polar : "expr_radius",_"expr_angle",_x_center,_y_center,_boundary={ 0=dirichlet | 1=neumann }
#@gmic : Apply user-defined transform on polar representation of selected images.
#@gmic : Default values: 'expr_radius=R-r', 'expr_rangle=a', 'x_center=y_center=50' and 'boundary=1'.
#@gmic : $ image.jpg --transform_polar[0] R*(r/R)^2,a --transform_polar[0] r,2*a
transform_polar : -skip "${1=R-r}","${2=a}",${3=50},${4=50},${5=1}
  -e[^-1] "Apply custom polar transform with 'new_r = $1', 'new_a = $2', centered at ($3%,$4%)."
  -v - -repeat @# -l[$>]
    R={"sqrt((max($3,100-$3)*w/100)^2 + (max($4,100-$4)*h/100)^2)"}
    w={"$3*w/100"}
    h={"$4*h/100"}
    -f "R ="$R";
        r = sqrt((x-"$w")^2 + (y-"$h")^2);
        a = atan2(y-"$h",x-"$w");
        nr = $1;
        na = $2;
        i("$w" + nr*cos(na), "$h" + nr*sin(na), z, c, 1,$5)"
  -endl -done -v +

#@gmic twirl : _amplitude,_cx,_cy,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Apply twirl deformation on selected images.
#@gmic : Default values: 'amplitude=1', 'cx=cy=0.5' and 'boundary=1'.
#@gmic : $ image.jpg --twirl 0.6
twirl : -skip ${1=1},${2=0.5},${3=0.5},${4=1}
  -e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center at ($2%,$3%)."
  -v - -euclidean2polar $2,$3,1,$4 -repeat @#
    [$>],[$>],1,1,$1*x -channels[-1] -1,0 -warp[$>] [-1],1,1,2 -rm[-1]
  -done -polar2euclidean $2,$3,1,1 -v +

#@gmic warp_perspective : _x-angle,_y-angle,_zoom>0,_x-center,_y-center,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Warp selected images with perspective deformation.
#@gmic : Default values: 'x-angle=1.5', 'y-angle=0', 'zoom=1', 'x-center=y-center=50' and 'boundary=2'.
#@gmic : $ image.jpg --warp_perspective ,
warp_perspective : -skip ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
  -e[^-1] "Apply perspective warp on image$?, with angles ($1 deg.,$2 deg.), zoom $3 and offsets ($4,$5)."
  -v - -repeat @# -l[$>]
    (0,100) --[-1] $4 -/[-1] 100 (0;100) --[-1] $5 -/[-1] 100 -r[-2,-1] [-3],[-3],[-3],1,3
    --*[-2] $2 --*[-2] $1 -+[-2,-1] -+[-1] $3 -/[-3] [-1] -/[-2,-1]
    -*[-2] 100 -+[-2] $4 -/[-2] 100 -*[-2] @{-3,w}
    -*[-1] 100 -+[-1] $5 -/[-1] 100 -*[-1] @{-3,h}
    -a[-2,-1] c -warp[-2] [-1],0,1,$6 -rm[-1]
  -endl -done -v +

#@gmic water : _amplitude>=0,_smoothness>=0
#@gmic : Apply water deformation on selected images.
#@gmic : Default values: 'amplitude=30' and 'smoothness=1.5'.
#@gmic : $ image.jpg --water ,
water : -skip ${1=30},${2=1.5}
  -e[^-1] "Apply water deformation on image$?, with amplitude $1 and smoothness $2."
  -v - -repeat @# -l[$>]
    25%,25%,25%,1 -noise[-1] $1 -g[-1] xyz -+[-1,-2,-3] -b[-1] $2 -*[-1] 2 -r[-1] [-2],[-2],1,2,3 -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic wave : _amplitude>=0,_frequency>=0,_center_x,_center_y
#@gmic : Apply wave deformation on selected images.
#@gmic : Default values: 'amplitude=4', 'frequency=0.4' and 'center_x=center_y=50'.
#@gmic : $ image.jpg --wave ,
wave : -skip ${1=4},${2=0.4},${3=50},${4=50}
  -e[^-1] "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center at ($3%,$4%)."
  -v - -repeat @# -l[$>]
    100%,100% -=[-1] 1,$3%,$4% -distance[-1] 1
    -*[-1] $2 --sin[-1] -cos[-2] -a[-2,-1] c -*[-1] $1
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic wind : _amplitude>=0,_angle,0<=_attenuation<=1,_threshold
#@gmic : Apply wind effect on selected images.
#@gmic : Default values: 'amplitude=20', 'angle=0', 'attenuation=0.7' and 'threshold=20'.
#@gmic : $ image.jpg --wind ,
wind : -check "isint(${1=20}) && $1>=0 && ${3=0.7}>=0 && $3<=1" -skip "${2=0},${4=20}"
  -e[^-1] "Apply wind effect on image$?, with amplitude $1, angle "{round($2/45)*45}" deg., attenuation $3 and threshold $4."
  -v -
  -if {!$1} -return -endif
  dxdy=@{-_wind{round($2/45)%8}}
  fact={(1-$3)^(1/$1)}
  -repeat @# -l[$>]
    --gradient_norm -ge[-1] $4%
    sum=@{-1,+} -r[-1] 100%,100%,1,[-2] -*[-1] [-2]
    -repeat $1
      -shift[-1] $dxdy,0,0,0 -max[-2] [-1] -*[-1] $fact
      -remove_pixels[-1] {100/$1},$sum
    -done -rm[-1]
  -endl -done -v +

_wind0 : -u 1,0
_wind1 : -u 1,1
_wind2 : -u 0,1
_wind3 : -u -1,1
_wind4 : -u -1,0
_wind5 : -u -1,-1
_wind6 : -u 0,-1
_wind7 : -u 1,-1

#@gmic zoom : _factor,_cx,_cy,_cz,_boundary={ 0=dirichlet | 1=neumann | 2=cyclic }
#@gmic : Apply zoom factor to selected images.
#@gmic : Default values: 'factor=1', 'cx=cy=cz=0.5' and 'boundary=0'.
#@gmic : $ image.jpg --zoom[0] 0.6 --zoom[0] 1.5
zoom : -skip ${1=2},${2=0.5},${3=0.5},${4=0.5},${5=0}
  -e[^-1] "Apply zoom effect on image$?, with factor $1 and center ($2,$3)."
  -v - -repeat @# -l[$>]
    -if {d==1} # 2d image.
       ({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
       ({(@{-2,h}-1)*$3*(1-1/$1)};{(@{-2,h}-1)*($3+(1-$3)/$1)})
       -r[-2--1] [-3],[-3],1,1,3 -a[-2--1] c -warp[-2] [-1],0,1,$5
    -else # 3d image.
       ({(w-1)*$2*(1-1/$1)},{(w-1)*($2+(1-$2)/$1)})
       ({(@{-2,h}-1)*$3*(1-1/$1)};{(@{-2,h}-1)*($3+(1-$3)/$1)})
       ({(@{-3,d}-1)*$4*(1-1/$1)}/{(@{-3,d}-1)*($4+(1-$4)/$1)})
       -r[-3--1] [-4],[-4],[-4],1,3 -a[-3--1] c -warp[-2] [-1],0,1,$5
    -endif
    -rm[-1]
  -endl -done -v +

#-----------------------------
#
#@gmic :: Degradations
#
#-----------------------------

#@gmic cracks : _density>=0,_amplitude,_relief={ 0 | 1 }
#@gmic : Add random cracks to selected images.
#@gmic : Default values: 'density=0.2', 'amplitude=40' and 'relief=0'.
#@gmic : $ image.jpg --cracks 0.2,60,1
cracks : -skip ${1=0.2},${2=40},${3=0}
  -e[^-1] "Add random cracks to image$?, with density $1."
  -v - -repeat @# -l[$>]
    ({im},{iM}) [-2],[-2],1,1 -noise[-1] $1,2 -distance[-1] 1 -sharpen[-1] 10000
    -if $3 -g[-1] xy -+[-2,-1] -n[-1] -1,1 -else -n[-1] 0,1 -endif
    -*[-1] $2 -+[-3,-1] -c[-2] @-1 -rm[-1]
  -endl -done -v +

#@gmic light_patch : _density>0,_darkness>=0,_lightness>=0
#@gmic : Add light patches to selected images.
#@gmic : Default values: 'density=10', 'darkness=0.9' and 'lightness=1.7'.
#@gmic : $ image.jpg --light_patch 20,0.9,4
light_patch : -skip ${1=10},${2=0.9},${3=1.7}
  -e[^-1] "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
  -v - -repeat @# -l[$>]
    -n 0,255 $1,$1 -noise[-1] 40 -r[-1] [-2],5 -c[-1] 0,255
    -n[-1] $2,$3 -* -c 0,255
  -endl -done -v +

#@gmic noise_hurl : _amplitude>=0
#@gmic : Add hurl noise to selected images.
#@gmic : Default value: 'amplitude=10'.
#@gmic : $ image.jpg --noise_hurl ,
noise_hurl : -skip ${1=10}
  -e[^-1] "Add hurl noise to image$?, with amplitude $1%."
  -v - -repeat @# -l[$>]
    --f 0 -noise[-1] 10 -n[-1] @{-2,m},@{-2,M} 100%,100%,1,1,-2
    -noise[-1] $1,2 -ge[-1] 0 -r[-1] [-2]
    -*[-2] [-1] -*[-1] -1 -+[-1] 1 -*[-3,-1] -+
  -endl -done -v +

#@gmic pixelize : _scale_x>0,_scale_y>0,_scale_z>0
#@gmic : Pixelize selected images with specified scales.
#@gmic : Default values: 'scale_x=20' and 'scale_y=scale_z=scale_x'.
#@gmic : $ image.jpg --pixelize ,
pixelize : -skip ${1=20},${2=$1},${3=$1}
  -e[^-1] "Pixelize image$? with scales ($1%,$2%,$3%)."
  -v - -repeat @# -l[$>] whd={w},{h},{d} -r $1%,$2%,$3%,100%,2 -r $whd -endl -done -v +

#@gmic shade_stripes : _frequency>=0,_direction={ 0=horizontal | 1=vertical },_darkness>=0,_lightness>=0
#@gmic : Add shade stripes to selected images.
#@gmic : Default values: 'frequency=5', 'direction=1', 'darkness=0.8' and 'lightness=2'.
#@gmic : $ image.jpg --shade_stripes 30
shade_stripes : -skip ${1=5},${2=1},${3=0.8},${4=2}
  -e[^-1] "Add "@{-arg\ 1+!$2,vertical,horizontal}" shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4."
  -v - -n 0,255 -repeat @# -l[$>]
    {max(1,w*($2!=0))},{max(1,h*($2==0))} -noise[-1] $1,2 -distance[-1] 1 -r[-1] [-2] -n[-1] $3,$4 -* -c 0,255
  -endl -done -v +

#@gmic shadow_patch : _opacity>=0
#@gmic : Add shadow patches to selected images.
#@gmic : Default value: 'opacity=0.7'.
#@gmic : $ image.jpg --shadow_patch 0.4
shadow_patch : -skip ${1=0.7}
  -e[^-1] "Apply shadow patches to image$?, with opacity $1."
  -v - -repeat @# -l[$>]
    100%,100%,1,1 -shift[-1] -2,-2 -shift[-1] 1,1
    -plasma[-1] 3,0.3,8 -abs[-1] -b[-1] 1 -c[-1] 3%,15% -r[-1] [-2]
    -n[-1] $1,1 -*
  -endl -done -v +

#@gmic spread : _dx>=0,_dy>=0,_dz>=0
#@gmic : Spread pixel values of selected images randomly along x,y and z.
#@gmic : Default values: 'dx=3', 'dy=dx' and 'dz=0'.
#@gmic : $ image.jpg --spread 3
spread : -skip ${1=3},${2=$1},${3=0}
  -e[^-1] "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
  -v - -repeat @# -l[$>]
    100%,100%,100%,3
    -sh[-1] 0,0 -rand[-1] {-$1},$1 -rm[-1]
    -sh[-1] 1,1 -rand[-1] {-$2},$2 -rm[-1]
    -sh[-1] 2,2 -rand[-1] {-$3},$3 -rm[-1]
    -warp[-2] [-1],1 -rm[-1]
  -endl -done -v +

#@gmic stripes_y : _frequency>=0
#@gmic : Add vertical stripes to selected images.
#@gmic : Default value: 'frequency=10'.
#@gmic : $ image.jpg --stripes_y ,
stripes_y : -skip ${1=10}
  -e[^-1] "Add vertical stripes to image$?, with frequency $1."
  -v - -repeat @# -l[$>]
    -n 0,255 100% -noise[-1] $1,2 -*[-1] 255 -r[-1] [-2]
    -*[-1] 0.15 -+ -c 0,255
  -endl -done -v +

#@gmic texturize_canvas : _amplitude>=0,_fibrousness>=0,_emboss_level>=0
#@gmic : Add paint canvas texture to selected images.
#@gmic : Default values: 'amplitude=20', 'fibrousness=3' and 'emboss_level=0.6'.
#@gmic : $ image.jpg --texturize_canvas ,
texturize_canvas : -check "${1=20}>=0 && ${2=3}>=0 && ${3=0.6}>=0 && ${4=80}"
  -e[^-1] "Add canvas texture to image$?, with amplitude $1, fibrousness $2 and emboss level $3."
  -repeat @# -l[$>]
    {w},{h} -rand[-1] 0,255 --blur_x[-1] $2 -blur_y[-2] $2 -+[-2,-1] -g[-1] -a[-2,-1] c
    --compose_channels[-1] + -orientation[-2] -compose_channels[-2] + -n[-2] $3,1 -n[-1] 0,255
    -sharpen[-1] 80 -*[-2,-1] -n[-1] -$1,$1 -+ -c 0,255
  -endl -done -v +

#@gmic texturize_paper
#@gmic : Add paper texture to selected images.
#@gmic : $ image.jpg --texturize_paper
texturize_paper :
  -e[^-1] "Add paper texture to image$?."
  -v - -repeat @# -l[$>]
    [-1] 30%,30% -noise[-1] 1,2 -r[-1] [-2],[-2],[-2],1,0 -ifft[-1]
    -rm[-1] -shift[-1] 50%,50%,50%,0,2 -sharpen[-1] 1 -n[-1] 1,1.2 -r[-1] [-2]
    -*[-2,-1] -c[-1] [-2],[-2] -rm[-2]
  -endl -done -v +

#@gmic vignette : _strength>=0,0<=_radius_min<=100,0<=_radius_max<=100
#@gmic : Add vignette effect to selected images.
#@gmic : Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.
#@gmic : $ image.jpg --vignette ,
vignette : -check "${1=100}>=0 && ${2=70}>=0 && $2<=100 && ${3=90}>=0 && $3<=100"
  -e[^-1] "Add vignette effect to image$?, with strength $1 and size $2."
  -v - -repeat @# -l[$>]
    mM={im},{iM} d={max(w,h)}
    $d,$d -=[-1] 1,50%,50% -distance[-1] 1 -r[-1] [-2],2
    -c[-1] $2%,$3% -n[-1] 0,$1 -- -c $mM
  -endl -done -v +

#@gmic watermark_visible : _text,0<_opacity<1,_size>0,_angle,_mode={ 0=remove | 1=add },_smoothness>=0
#@gmic : Add or remove a visible watermark on selected images (value range must be [0,255]).
#@gmic : Default values: 'text=(c) G'MIC', 'opacity=0.3', 'size=57', 'angle=25', 'mode=1' and 'smoothness=0'.
#@gmic : $ image.jpg --watermark_visible ,0.7
watermark_visible : -skip "${1=\251\ G\'MIC}" -check "${2=0.3}>0 && $2<1 && ${3=57}>0 && ${6=0.5}>=0" -skip ${4=25},${5=1}
  -e[^-1] @{-arg\ 1+!$5,Add,Remove}" visible watermark '$1' on image$?, with opacity $2, size $3, angle $4 deg."
  -v - -repeat @# -l[$>]
    0 -t[-1] "$1",0,0,$3,1,255 -rotate[-1] $4,0,0 -b[-1] $6 -n[-1] 0,255
    -r[-1] [-2],0,2 -+[-1] [-2] -c[-1] 0,255  # Generate opaque watermark image
    -if $5 -*[-1] $2 -*[-2] {1-$2} -+  # Add watermark
    -else -*[-1] $2 -- -/ {1-$2}       # Remove watermark
    -endif
    -c 0,255
  -endl -done -v +

#--------------------------------------
#
#@gmic :: Blending and fading
#
#--------------------------------------

#@gmic blend : blending_mode,0<=_opacity<=1,_revert_layer_order={ 0 | 1 }
#@gmic : Blend selected G,GA,RGB or RGBA images, two-by-two, using specified mode.
#@gmic : 'blending_mode' can be { add | alpha | and | average | blue | burn | darken | difference |
#@gmic : divide | dodge | exclusion | freeze | grainextract | grainmerge | green | hardlight |
#@gmic : hardmix | hue | interpolation | lighten | lightness | linearburn | linearlight | luminance |
#@gmic : multiply | negation | or | overlay | pinlight | red | reflect | saturation |
#@gmic : screen | shapeaverage | shapeaverage0 | softburn | softdodge | softlight | stamp | subtract | value |
#@gmic : vividlight | xor }.
#@gmic : Default values: 'blending_mode=alpha', 'opacity=1' and 'revert_layers=0'.
#@gmic : $ image.jpg --drop_shadow , -resize2dy[-1] 200 -rotate[-1] 20 --blend alpha -drgba[-2]
#@gmic : $ image.jpg -testimage2d {w},{h} -blend overlay
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,24,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex add,alpha,and,average,blue,burn,darken
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,24,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex difference,divide,dodge,exclusion,freeze,grainextract,grainmerge
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,24,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex green,hardlight,hardmix,hue,interpolation,lighten,lightness
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,24,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex linearburn,linearlight,luminance,multiply,negation,or,overlay
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,24,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex pinlight,red,reflect,saturation,screen,shapeaverage,softburn
#@gmic : $ -m "ex : $""=arg -repeat $""# --blend[0,1] ${arg{$>+1}} -text_outline[-1] Mode:\" \"${arg{$>+1}},2,2,24,2,1,255 -done" image.jpg -testimage2d {w},{h} -ex softdodge,softlight,stamp,subtract,value,vividlight,xor
blend : -skip ${1=alpha},${2=1},${3=0},${4=1}
  -v - s0="" s1="(reverted layers) " -v +
  -e[^-1] "Blend image$? two-by-two, using '$1' mode "${s{$3!=0}}"and opacity $2."
  -v - -l[] code=@{-_blend_$1}
  -onfail -v + -error[0--2] "Unknown blending mode '$1' requested."
  -endl
  -repeat {int(@#/2)} -l[$>,{$>+1}] -if $3 -rv -endif
    -r[1] [0],[0],[0],100%,0,0,0.5,0.5 # Align spatial dimensions for mask and base image.
    s={s0=if(@{0,s}<3,1,3);s1=if(s<3,1,3);max(s0,s1)} # Target color format (G or RGB).
    -to_colormode[0] {$s+1-(@{0,s}%2)} # Target format (G,GA,RGB or RGBA).
    -to_colormode[1] {$s+1-(s%2)} # Mask format (G,GA,RGB or RGBA).
    -if {@{0,s}==2||@{0,s}==4} # Target has alpha.
      -if {s==2||s==4} # Mask has alpha.
        -sh[0,1] 0,{s-2} -_blend[2,3] $code -rm[2,3]
        -if {$1'=='alpha} # Special blending code for alpha-mode.
          -sh[0,1] 0,{@{0,s}-2} -sh[0,1] 100%,100% -*[2,4] -*[3,4] -rm[2,3]
          --channels[1] 100% -sh[1] 100%,100% -f[3] 255 -rm[3]
          -j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 -rm[1,2]
          -sh[0] 0,{s-2} -sh[0] 100%,100% -+[2] 1e-10 -/[1,2] -rm[1] -c 0,255
        -else
          -sh[1] 0,{s-2} -sh[1] 100%,100% -j[0] [2],0,0,0,0,{max(0,min(1,$2))},[3],255 -rm[^0]
        -endif
      -else # Mask has no alpha.
        -sh[0] 0,{@{0,s}-2} -rv[1,2] -_blend[1,2] $code -j[1] [2],0,0,0,0,{max(0,min(1,$2))} -rm[^0]
      -endif
    -else # Target has no alpha.
      -if {s==2||s==4} # Mask has alpha.
        -sh[1] 0,{s-2} -_blend[0,2] $code -rm[2]
        -sh[1] 100%,100% -j[0] [1],0,0,0,0,{max(0,min(1,$2))},[2],255 -rm[^0]
      -else # Mask has no alpha.
        -_blend $code -j[0] [1],0,0,0,0,{max(0,min(1,$2))} -rm[1]
      -endif
    -endif
  -endl -done -v +

_blend : $*
_blend_alpha :
  -u ""
_blend_and :
  -u "-and[1] [0]"
_blend_add :
  -u "-+[1] [0] -c[1] 0,255"
_blend_average :
  -u "-+[1] [0] -/[1] 2"
_blend_blue :
  -u "-sh[0] 0,1 -j[1] [2] -rm[2]"
_blend_burn :
  -u "---[0] 255 -+[1] 0.1 -/[2] [1] -rm[1] -+[1] 1 -*[1] 255 -c[1] 0,255"
_blend_darken :
  -u "-min[1] [0]"
_blend_difference :
  -u "--[1] [0] -abs[1]"
_blend_divide :
  -u "-+[1] 0.1 -^[1] -1 -*[1] [0] -*[1] 255 -c[1] 0,255"
_blend_dodge :
  -u "--[1] 255.1 -^[1] -1 -*[1] [0] -*[1] -255 -c[1] 0,255"
_blend_exclusion :
  -u "--*[0,1] -/[2] -127.5 -+[1,2] -+[1] [0]"
_blend_freeze :
  -u "-*[1] -255 --[1] 0.1 ---[0] 255 -sqr[2] -/[2] [1] -rm[1] -+[1] 1 -*[1] 255 -c[1] 0,255"
_blend_grainextract :
  -u "--[1] [0] -*[1] -1 -+[1] 128 -c[1] 0,255"
_blend_grainmerge :
  -u "-+[1] [0] --[1] 128 -c[1] 0,255"
_blend_green :
  -u "-sh[0] 0,0 -sh[0] 2,2 -j[1] [2] -j[1] [3],0,0,0,2 -rm[2,3]"
_blend_hardlight :
  -u "--*[0,1] -/[2] 127.5 --+[0,1] -*[3] 2 --[3] 255 --[3] [2] -gt[1] 128 "\
     "-j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255"
_blend_hardmix :
  -u "-+[1] [0] -ge[1] 255 -*[1] 255"
_blend_hue :
  -u "-to_color -sh 0,2 -rgb2hsv[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -hsv2rgb[2,3] -rm[2,3]"
_blend_interpolation :
  -u "--*[0] {pi/255} -*[1] {pi/255} -cos[1,2] -+[1,2] --[1] 2 -*[1] -63.75 -c[1] 0,255"
_blend_lighten :
  -u "-max[1] [0]"
_blend_lightness :
  -u "-to_color -sh 0,2 -rgb2lab[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -lab2rgb[2,3] -rm[2,3]"
_blend_luminance :
  -u "-to_color -sh 0,2 -rgb2ycbcr[2,3] -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -ycbcr2rgb[2,3] -rm[2,3]"
_blend_linearburn :
  -u "-+[1] [0] --[1] 255 -c[-1] 0,255"
_blend_linearlight :
  -u "-*[1] 2 -+[1] [0] --[1] 255 -c[1] 0,255"
_blend_multiply :
  -u "-*[1] [0] -/[1] 255"
_blend_negation :
  -u "-+[1] [0] --[1] 255 -abs[1] -*[1] -1 -+[1] 255"
_blend_or :
  -u "-or[1] [0]"
_blend_overlay :
  -u "--*[0,1] -/[2] 127.5 -+[1] [0] -*[1] 2 --[1] 255 --[1] [2] --lt[0] 128 -j[1] [2],0,0,0,0,1,[3] -rm[2,3] -c[1] 0,255"
_blend_pinlight :
  -u "-*[1] 2 --blend darken --[1] 256 --blend[0,1] lighten -ge[1] 0 "\
     "-j[2] [3],0,0,0,0,1,[1] -rm[1,3]"
_blend_reflect :
  -u "--[1] 255.1 -*[1] -1 --sqr[0] -/[2] [1] -rm[1] -c[1] 0,255"
_blend_red :
  -u "-sh[0] 1,100% -j[1] [2],0,0,0,1 -rm[2]"
_blend_saturation :
  -u "-to_color -sh 0,2 -rgb2hsv[2,3] -shift[2,3] 0,0,0,-1,2 -sh[2] 1,2 -j[1] [4],0,0,0,1 -rm[4] -shift[2,3] 0,0,0,1,2 -hsv2rgb[2,3] -rm[2,3]"
_blend_screen :
  -u "---[0] 255 --[1] 255 -*[1,2] -/[1] 255 -*[1] -1 -+[1] 255"
_blend_shapeaverage :
  -u "-norm[1] -label[1] N={iM+1} "\
     "-repeat @{0,s} --channels[0] $> m={im} M={iM} -n[-1] 0,{1-1/256} -+[-1] [1] -histogram[-1] {$N*256},0,{$N-1/256} "\
     "-i[-2] 256,1,1,1,'x*($M-$m)/255+$m' -r[-2] [-1],0,2 -*[-2] [-1] -r[-2,-1] $N,1,1,1,2 -+[-1] 1e-8 -/[-2,-1] -done "\
     "-a[2--1] c -map[1] [2] -rm[2]"
_blend_shapeaverage0 : # Same as shapeaverage except that background values (i.e. 0) are kept to black.
  -u "-norm[1] --neq[1] 0 -label[1] N=@{1,iM+1} "\
     "-repeat @{0,s} --channels[0] $> m={im} M={iM} -n[-1] 0,{1-1/256} -+[-1] [1] -histogram[-1] {$N*256},0,{$N-1/256} "\
     "-i[-2] 256,1,1,1,'x*($M-$m)/255+$m' -r[-2] [-1],0,2 -*[-2] [-1] -r[-2,-1] $N,1,1,1,2 -+[-1] 1e-8 -/[-2,-1] -done "\
     "-a[3--1] c -map[1] [3] -rm[3] -*[1,2]"
_blend_softburn :
  -u "---[0] 255.1 -^[2] -1 -*[2] [1] -*[2] -127.5 ---[0] 255 --+[1] 0.1 -/[3,4] -*[3] 127.5 -+[3] 255 -+[1] [0] -gt[1] 255 "\
     "-j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255"
_blend_softdodge :
  -u "---[1] 255.1 -^[2] -1 -*[2] [0] -*[2] -127.5 ---[1] 255 --+[0] 0.1 -/[3,4] -*[3] 127.5 -+[3] 255 -+[1] [0] -gt[1] 255 "\
     "-j[2] [3],0,0,0,0,1,[1] -rm[1,3] -c[1] 0,255"
_blend_softlight :
  -u "--/[0] 255 -/[1] 255 --sqr[-1] -*[2] [1] -*[1] [3] -*[1] -2 -*[2] 2 -+[1-3] -*[1] 255 -c[1] 0,255"
_blend_stamp :
  -u "-*[1] 2 -+[1] [0] --[1] 255 -c[1] 0,255"
_blend_subtract :
  -u "--[1] [0] -*[1] -1 -c[1] 0,255"
_blend_value :
  -u "-to_color -sh 0,2 -rgb2hsv[2,3] -sh[2] 0,1 -j[1] [4] -rm[4] -hsv2rgb[2,3] -rm[2,3]"
_blend_vividlight :
  -u "-*[1] 2 --blend burn --[1] 256 --blend[0,1] dodge -ge[1] 0 "\
     "-j[2] [3],0,0,0,0,1,[1] -rm[1,3]"
_blend_xor :
  -u "-xor[1] [0]"

#@gmic blend_edges : smoothness[%]>=0
#@gmic : Blend selected images togethers using 'edges' mode.
#@gmic : $ image.jpg -testimage2d {w},{h} --blend_edges 0.8
blend_edges : -check {$1>=0}
  -e[^-1] "Blend image$? using 'edges' mode, with smoothness $1."
  -if {@#>1} -v - -to_rgb -r[^0] [0],0,0,0.5,0.5 -repeat @# -l[$>]
    --gradient_norm -+[-1] 1 -b[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] c -*[-4--2] [-1] -a[-4--1] c
  -endl -done -r[^0] [0],0,0,0.5,0.5 -+ -s[-1] c -/[-4--2] [-1] -rm[-1] -a[-3--1] c -v + -endif

#@gmic blend_fade
#@gmic : Blend selected images together using a given fading pattern (defined as the latest image).
#@gmic : $ image.jpg -testimage2d {w},{h} 100%,100%,1,1,'cos(y/10)' -normalize[-1] 0,1 --blend_fade
blend_fade :
  -e[^-1] "Blend image$? using 'fade' mode."
  -v - -r[^-1] @{-max_whds[^-1]},0
  -r[-1] [-2],[-2],[-2],100%,1 -max[-1] 0 -min[-1] {@#-2}
  -repeat {@#-1} ---[-1] $> -abs[-1] --[-1] 1 -*[-1] -1 -max[-1] 0 -*[$>,-1] -done
  -rm[-1] -+ -v +

#@gmic blend_median
#@gmic : Blend selected images together using 'median' mode.
#@gmic : $ image.jpg -testimage2d {w},{h} --mirror[0] y --blend_median
blend_median :
  -e[^-1] "Blend image$? using 'median' mode."
  -v - -to_colormode 0 -r @{-max_whd},100%,0,0,0.5,0.5,0.5 whd={w},{h},{d} -r 100%,{h*d},1,100%,-1
  -if {@#==2} -+ -/ 2
  -elif {@#>2}
    -permute xycz -a c
    -repeat {s} # Perform simple bubble sort along the c-axis for each pixel.
      -repeat {s-1-$>}
        -sh[-1] $>,$> -sh[-2] {$>+1},{$>+1} --gt[-2,-1]
        --j[-3] [-2],0,0,0,0,1,[-1] -j[-3] [-4],0,0,0,0,1,[-2] -j[-4] [-1] -rm[-4--1]
      -done
    -done
    -if {s%2} -channels 50% -else -channels {s/2-1},{s/2} -compose_channels + -/ 2 -endif
    -permute xycz
  -endif
  -r[-1] $whd,100%,-1 -v +

_fade :
  -r[-2] [-3],5 -r[-1] [-2],3 -c[-1] $1%,$2% -n[-1] 0,1 -j[-3] [-2],0,0,0,0,1,[-1] -rm[-2,-1]

#@gmic fade_diamond : 0<=_start<=100,0<=_end<=100
#@gmic : Create diamond fading from selected images.
#@gmic : Default values: 'start=80' and 'end=90'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_diamond 80,85
fade_diamond : -skip ${1=70},${2=90}
  -e[^-1] "Create ($1%,$2%) diamond-shaped fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    (0,1,0;1,1,1;0,1,0) -_fade $1,$2
  -endl -done -v +

#@gmic fade_linear : _angle,0<=_start<=100,0<=_end<=100
#@gmic : Create linear fading from selected images.
#@gmic : Default values: 'angle=45', 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_linear 45,48,52
fade_linear : -skip ${1=45},${2=30},${3=70}
  -e[^-1] "Create ($2%,$3%) linear fading from image$?, with angle $1 deg."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
     64,64,1,1,"x*cos($1*pi/180) + y*sin($1*pi/180)" -_fade $2,$3
  -endl -done -v +

#@gmic fade_radial : 0<=_start<=100,0<=_end<=100
#@gmic : Create radial fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_radial 30,70
fade_radial : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) radial fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}]
    100%,100% -=[-1] 1,50%,50% -distance[-1] 1 -_fade $1,$2
  -endl -done -v +

#@gmic fade_x : 0<=_start<=100,0<=_end<=100
#@gmic : Create horizontal fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_x 30,70
fade_x : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) horizontal fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}] (0,1) -_fade $1,$2 -endl -done -v +

#@gmic fade_y : 0<=_start<=100,0<=_end<=100
#@gmic : Create vertical fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
#@gmic : $ image.jpg -testimage2d {w},{h} --fade_y 30,70
fade_y : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) vertical fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}] (0;1) -_fade $1,$2 -endl -done -v +

#@gmic fade_z : 0<=_start<=100,0<=_end<=100
#@gmic : Create transversal fading from selected images.
#@gmic : Default values: 'start=30' and 'end=70'.
fade_z : -skip ${1=30},${2=70}
  -e[^-1] "Create ($1%,$2%) transversal fading from image$?."
  -v - -repeat {int(@#/2)} -l[$>,{$>+1}] (0/1) -_fade $1,$2 -endl -done -v +

#---------------------------------------------
#
#@gmic :: Image sequences
#
#---------------------------------------------

#@gmic animate : filter_name,"param1_start,..,paramN_start","param1_end,..,paramN_end",nb_frames>=0,_output_frames={ 0 | 1 },_output_filename : delay>0
#@gmic : Animate filter from starting parameters to ending parameters or animate selected images
#@gmic : in a display window.
#@gmic : Default value: 'delay=30'.
#@gmic : $ image.jpg -animate flower,"0,3","20,8",9
animate : -skip ${1=30},${2=0},${3=""},${4=0},${5=1},"${6=}"
  -if {isval($1)}
    -if $2 -e[0--4] "Animate image$?, with a delay of $1 ms, and ping-pong mode."
    -else -e[0--4] "Animate image$?, with a delay of $1 ms."
    -endif
    -if {!@#} -return -endif
    -v -
    speed=$1    # Animation speed
    pause=-1    # Pause mode.
    direction=1 # Animation direction.
    frame=0     # Current frame.
    -do
      -w[$frame] -1,-1,1,0,-1,-1,@{$frame,b}.@{$frame,x}
      frame={$frame+$direction}
      -if $2
        -if {$frame==-1} frame=0 direction=1
        -elif {$frame==@#} frame={@#-1} direction=-1
        -endif
      -else frame={$frame%@#}
      -endif
      -wait $speed
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif # Increase window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif # Decrease window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif             # Reset window size.
      -if @{!,o} speed={min(500,max(10,$speed-10*@{!,o}))} -wait -1 -endif
      -if @{!,SPACE}
        -if {$pause>=0} direction=$pause pause=-1
        -else pause=$direction direction=0 -endif
        -wait -1
      -endif

    -while {@!" && "!@{!,Q}" && "!@{!,ESC}} -v +
  -else
    -e[0--3] "Compute animated version of filter '$1', from parameters $2 to $3 with $4 frames."
    -if {!($5||narg("$6"))} -return -endif
    -v - ($2) ($3) -y[-2,-1] x -a[-2,-1] y -r[-1] 100%,$4,1,1,3 -mv[-1] 0 -rprogress 0
    -repeat {@#-1}
      -v + -e[] " > Animate image ["$>"]" -v -
      -repeat $4 --l[0,1]
        -$1[-1] @{0,{$>*@{0,w}}-{($>+1)*@{0,w}-1}} -rm[0]
        -if {narg("$6")} -o @{-filename\ "$6",@{>,-2},$>} -endif
        -if {!$5} -rm -endif
        -rprogress {100*($>+1)/$4}
        -v + -e[] "\r > Animate image ["@{>,-2}"] : Frame "{$>+1}"/$4    " -v -
      -endl -done
    -rm[1] -done -rm[0] -v +
  -endif

#@gmic morph : nb_frames>0,_smoothness>=0,_precision>0
#@gmic : Create morphing sequence between selected images.
#@gmic : Default values: 'smoothness=0.1' and 'precision=5'.
#@gmic : $ image.jpg --rotate 20,1,1,50%,50% -morph 9
morph : -skip ${2=0.1},${3=5}
  -e[^-1] "Create morphing sequence between image$?, with $1 intra-frames, smoothness $2 and precision $3.\n"
  -v - -r[^0] [0],3 -i[0] (@#) --[0] 1 -repeat @0
   -v + -e[] "\r > Morph image "$>" to image "{$>+1}".    " -v -
    --equalize[-2,-1] -n[-2,-1] 0,255
    --displacement[-1] [-2],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-2]
    --displacement[-3] [-2],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-7--4,-2]
    (1/0) -r[-1] [-2],3 -*[-3] [-1] -*[-2,-1] -mirror[-1] z -+[-2,-1] -s[-1] z
    -mv[-$1--1] 1 -mv[1] @#
  -done -mv[-1] 1 -rm[0] -v +

#@gmic register_nonrigid : _smoothness>=0,_precision>0,_nb_scale>=0
#@gmic : Register selected images with non-rigid warp.
#@gmic : Default values: 'smoothness=0.2', 'precision=6' and 'nb_scale=0(auto)'.
#@gmic : $ image.jpg --rotate 20,1,1,50%,50% --register_nonrigid , -remove[-2]
register_nonrigid : -skip ${1=0.2},${2=5},${3=0}
  -e[^-1] "Register image$? with non-rigid warp, smoothness $1, precision $2 and $3 scale(s)."
  -v - --equalize[0] -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if {$>>1}
    --equalize[-1] -n[-1] 0,255 --displacement[1] [-1],$1,$2,$3 -rm[-2]
    -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v +

#@gmic register_rigid : _smoothness>=0
#@gmic : Register selected images with rigid warp.
#@gmic : Default value: 'smoothness=1'.
#@gmic : $ image.jpg --shift 30,20 --register_rigid , -remove[-2]
register_rigid : -skip ${1=1}
  -e[^-1] "Register image$? with rigid warp and smoothness $1."
  -v - --equalize[0] -b[-1] $1 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if {$>>1}
    --equalize[-1] -b[-1] $1 -n[-1] 0,255 --phase_correlation[1,-1] -rm[-2] -*[-1] -1 -round[-1] 1
    -shift[-2] @-1,0,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v +

#@gmic transition_plasma : _nb_frames>=2,_scale>=0,_smoothness[%]>=0
#@gmic : Create plasma transition sequence between consecutive images.
#@gmic : Default values: 'nb_frames=10', 'scale=5' and 'smoothness=0.5%'.
#@gmic : $ image.jpg -testimage2d {w},{h} -transition_plasma 9
transition_plasma : -check "isint(${1=10}) && $1>=2 && isint(${2=5}) && $2>=0 && ${3=0.5%}>=0"
  -e[^-1] "Create plasma transition sequence between image$?, with $1 frames, scale $2, smoothness $3.\n"
  -v -
  -if {@#<2} -return -endif
  -slices 0 -r @{-max_whds},3
  off=0 -repeat {@#-1} -l[{$>+$off},{$>+$off+1}]
    -v + -e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " -v -
    100%,100% -plasma[-1] 1,0,$2 -n[-1] 0,1
    -repeat {$1-2} --le[2] {($>+1)/$1} -b[-1] $3 [0] -j[-1] [1],0,0,0,0,1,[-2] -rm[-2] -rprogress {$>*100/($1-2)} -done
    -rm[2] -mv[2--1] 1 off={$off+$1-2}
  -endl -done -v +

#@gmic transition3d : _nb_frames>=2,_nb_xtiles>0,_nb_ytiles>0,_axis_x,_axis_y,_axis_z,_is_antialias
#@gmic : Create 3d transition sequence between selected consecutive images.
#@gmic : 'axis_x', 'axis_y' and 'axis_z' can be set as mathematical expressions, depending on 'x' and 'y'.
#@gmic : Default values: 'nb_frames=10', 'nb_xtiles=nb_ytiles=3', 'axis_x=1', 'axis_y=1', 'axis_z=0' and 'is_antialias=1'.
#@gmic : $ image.jpg --blur 5 -transition3d 9 -drgba
transition3d : -check "isint(${1=10}) && $1>=2 && isint(${2=3}) && $2>0 && isint(${3=$2}) && $3>0" -skip ${4=1},${5=1},${6=0},${7=1}
  -e[^-1] "Create 3d transition sequence between image$?, with $1 frames, $2x$3 tiles and rotation axis ($4,$5,$6).\n"
  -v -
  -if {@#<2} -return -endif
  -slices 0 -to_rgb -r @{-max_whds},3
  off=0 -repeat {@#-1} -l[{$>+$off},{$>+$off+1}]
    -v + -e[] "\r > Generate transition from image "$>" to image "{$>+1}".    " -v -

    # Create 3d rotation vectors.
    $2,$3,1,1,'$4'
    $2,$3,1,1,'$5'
    $2,$3,1,1,'$6'
    -a[-3--1] z
    -permute[-1] zxyc -r[-1] 3,{$2*$3},1,1,-1
    -repeat {h} rot$>=@{-1,0-2} -shift[-1] 0,-1,0,0 -done
    -rm[-1]

    # Create 3d tiles.
    --split_tiles[-2,-1] $2,$3 -mv[0,1] @#
    N={$2*$3} i=0 y=0
    -repeat $3
      x=0
      -repeat $2
        lw=@{$i,w} lh=@{$i,h}
        -imageplane3d[$i] -imageplane3d[$N] -r3d[$N] ${rot$i},-180 -c3d[$i,$N] -+3d[$i,$N]
        x$i=$x y$i=$y x={$x+$lw} i={$i+1}
      -done
      y={$y+$lh}
    -done

    # Generate intermediate animation frames.
    -repeat {$1-2}
      -repeat $N -r3d[$>] ${rot$>},{180/($1-1)} --+3d[$>] ${x$>},${y$>},0 -done
      -+3d[-$N--1] -c3d[-1]

      -if $7  # Antialiased rendering.
        -i[-3] {2*@{-2,w}},{2*@{-2,h}},1,3,-1
        -*3d[-1] 2 -object3d[-3] [-1],50%,50%,0,1,2,0,0 -rm[-1]
        -to_rgba[-2] -replace_color[-2] 0,0,-1,-1,-1,255,0,0,0,0
        -r[-2] [-1],[-1],1,100%,2
      -else  # Standard rendering.
        -i[-3] @{-2,w},@{-2,h},1,3,-1 -object3d[-3] [-1],50%,50%,0,1,2,0,0 -rm[-1]
        -to_rgba[-2] -replace_color[-2] 0,0,-1,-1,-1,255,0,0,0,0
      -endif

    -done
    -rm[0-{$N-1}]
    -nm[1--2] @{0,n}
    off={$off+$1-2}
  -endl -done
  -v +

#-----------------------------
#
#@gmic :: Interactive demos
#
#-----------------------------

#@gmic demo
#@gmic : Show a menu to select and view all G'MIC interactive demos.
demo :
  -e[] "\n
------ G'MIC demos menu -----------------\n
----\n
---- Mouse button to select a demo.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -l[]
  300,420,1,3 --plasma[-1] 1,1,5 -n[-1] 0,230 -sh[-1] 0,1 -/[-1] 2.2 -rm[-1] -water[-1] 100 -*[-1] 0.15
  100%,100%,1,3
  0 -text[-1] "1- Blobs editor\n"\
              "2- Bouncing balls\n"\
              "3- Fire effect\n"\
              "4- Fireworks\n"\
              "5- Fish-eye effect\n"\
              "6- Fourier filtering\n"\
              "7- Histogram demo\n"\
              "8- Hough transform\n"\
              "9- Jawbreaker\n"\
              "10- The game of life\n"\
              "11- Light effect\n"\
              "12- Mandelbrot explorer\n"\
              "13- 3d metaballs\n"\
              "14- Minesweeper\n"\
              "15- Minimal path\n"\
              "16- Pacman\n"\
              "17- Paint\n"\
              "18- Plasma effect\n"\
              "19- RGB quantization\n"\
              "20- 3d reflection\n"\
              "21- 3d rubber object\n"\
              "22- Shade bobs\n"\
              "23- Spline editor\n"\
              "24- Tetris\n"\
              "25- Tic-tac-toe\n"\
              "26- Image waves\n"\
              "27- Fractal whirls",0,0,13,1,255,255,255
  commands=-x_blobs,-x_bouncing,-x_fire,-x_fireworks,-x_fisheye,-x_fourier,-x_histogram,-x_hough,\
           -x_jawbreaker,-x_life,-x_light,-x_mandelbrot,-x_metaballs3d,-x_minesweeper,-x_minimal_path,\
           -x_pacman,-x_paint,-x_plasma,-x_quantize_rgb,-x_reflection3d,-x_rubber3d,-x_shadebobs,\
           -x_spline,-x_tetris,-x_tictactoe,-x_waves,-x_whirl
  y0=59
  -j[-2] [-1],20,$y0,0,0 -rm[-1]
  -rectangle[-1] 0,16,100%,44,1,120,120,32
  0 -text[-1] "G'MIC "@{-strver}" demos",2,2,24,1,1,1,1 -b[-1] 0.5 -n[-1] 0,1
  (32;255^255;255^0;0) -r[-1] [-2],[-2],1,3,3 -*[-2,-1] -round[-1] 1,-1 --neq[-1] 0 -channels[-1] 1
  -j[-3] [-2],20,18,0,0,1,[-1] -rm[-2,-1] --channels[-1] 1 -dilate[-1] 5
  (80;255;80^0;255;0^0;0;0) (10;255;10^0;100;0^0;0;0)
  -r[-2,-1] [-3],13,1,3,3 -polygon[-2,-1] 3,1,1,1,11,10,6,1,255,255,255 --mirror[-2,-1] x
  -max[-4,-2] -max[-2,-1]

  # Pre-compute 3d objects.
  -ball[] 64,200,100,64 -n[-1] 0,230 -s[-1] c,-3 -rgb2hsv[-2] -*[-1] 0.5 -a[-2,-1] c
  -repeat 6
    -sh[-1] 0,0 -f[-1] {$>*360/6} -rm[-1] --s[-1] c,-3 -hsv2rgb[-2] -a[-2,-1] c
    ({'CImg3d'}) (5,5) 3,5 (1,0;1,4) -r[-1] 2,5,1,1,3 -round[-1] 4,5 -y[-5--1] -a[-5--1] y
    -rv[-2,-1] -sprites3d[-2,-1] -rv[-2,-1]
  -done -rm[-1] -+3d[-6--1]
  cfx={0} cfy={0} cfz={0} nfx={g} nfy={g} nfz={g} alpha=0 time0={@|-4} selected=-1 -f3d 400

  # Start main loop.
  -w[0] -1,-1,0,0,50%,50%,"[G'MIC] Demos menu"
  -do

    # Set 3d coordinates for object.
    t={1.5*@|}
    1,30,1,1,'(1-$alpha)*cos($cfx*y+$t)+$alpha*cos($nfx*y+$t)'
    1,30,1,1,'(1-$alpha)*sin($cfy*y+$t)+$alpha*sin($nfy*y+$t)'
    1,30,1,1,'(1-$alpha)*sin($cfz*y+$t)+$alpha*sin($nfz*y+$t)'
    -a[-3--1] x -s[-1] y,5 -a[-5--1] x -y[-1]
    -j[6] [-1],0,8 -rm[-1] -*3d[6] @{0,w/2-30},@{0,h/2-30},300 -+3d[6] 0,0,200

    # Render image.
    -*[0] 0.85 -+[0] [1] -object3d[0] [6],50%,50%,0,1,0,0,0 -j[0] [2],0,0,0,0,1,[3],255

    # Manage mouse events.
    y={@{!,y}*@{0,h}/@{!,h}}
    -if {$y>=0} y={max(0,min(26,int(($y-$y0)/13)))} -j[0] [{if($selected>=0,5,4)}],0,{$y0+13*$y},0,0,0.2 -endif # Menu location.

    -w[0] -wait 20

    -if {(@{!,b}&1)&&$selected<0} selected=$y # Selection
    -elif {!@{!,b}}
      -if {$selected>=0&&$y==$selected}
      -m "com : -v 0 "@{-arg\ {1+$y},$commands} -parallel 1,"-l[] -com -v -1 -rm -endl" -uncommand com
      -endif
      selected=-1
    -endif

    # Manage ball animation.
    -if {@|-$time0>5} alpha={$alpha+0.03} -endif
    -if {$alpha>1} alpha={$alpha-1} cfx=$nfx cfy=$nfy cfz=$nfz nfx={g} nfy={g} nfz={g} time0={@|-?*3} -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -v 0 -e[] ""

#@gmic x_blobs
#@gmic : Launch the blobs editor.
x_blobs :
  -e[] "\n
------ Blobs editor --------------------------\n
----\n
---- Mouse to insert/move/delete blobs.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"
  -v -

  # Create background image [0].
  -rm (0;0^0;128^0;255) -r[-1] 350,350,1,3,3 -flower[-1] 30,8,0,0,0.5,0.5,1 -water[-1] 20
  -w {w},{h},0,0,"[G'MIC] Blobs editor"

  # Start event loop.
  moving=-1
  -do
    x=@{!,x} y=@{!,y} b=@{!,b} nearest=-1

    # Render image of blobs and find nearest blob to mouse pointer.
    -if {@#>1}
      @{!,w},@{!,h},1,2
      -repeat @{1,h}
        r={@{1,2}*(1+@{1,3}*cos(@{1,4}+@{1,5}*@|*1000))}
        -ellipse[-1] @{1,0,1},$r,$r,0,1,@{1,6-7}
        d={sqrt(($x-@{1,0})^2+($y-@{1,1})^2)}
        -if {$d<$r} nearest=$> -endif
      -shift[1] 0,-1,0,0,2 -done
      -b[-1] 15
      --norm[-1] --ge[-1] 50 -le[-2] 40 -*[-3,-1]
      --*[0,-1] -rm[-2] -rv[-2,-1] -*[-1] 1.6 -c[-1] 0,255 -+[-2,-1]
      -w[-1] {w},{h} -rm[-1]
    -else
      --text_outline[0] "G'MIC Blobs Editor",65,40,24,3,1,200,128,255
      -t[-1] "* Left mouse button : Create and move blobs.\n\n\
              * Right mouse button : Remove blob.\n\n\
              * Middle mouse button : Remove all blobs.\n\n\
              * Key 'ESC' or 'Q' : Quit.\n\n\
              * Colors and sizes of appearing blobs are\n   chosen randomly",\
             60,120,13,1,255
      -w[-1] {w},{h} -rm[-1]
    -endif
    -wait 20

    # Manage blob insertion, removal or move.
    -if {$x<0||$y<0} -continue -endif
    -if {$b&1}
      -if {$nearest>=0" || "$moving>=0} # Move existing blob.
        -if {$moving<0} moving=$nearest -endif
        -=[1] $x,0,$moving -=[1] $y,1,$moving
        -else # Insert new blob.
          (@{!,x},@{!,y},{?(20,50)},{?(-0.3,0.3)},{?(0,pi/2)},{?(0,0.009)},{?(64,255)},{?(64,255)}) -a[^0] y
          moving={h-1}
        -endif
    -elif {$b&2} # Remove existing blob.
      -if {$nearest>=0} -l[1] -s y -rm[$nearest] -a y -endl nearest=-1 -endif
    -elif {$b&4} # Remove all blobs.
      -k[0]
    -else
      moving=-1
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_bouncing
#@gmic : Launch the bouncing balls demo.
x_bouncing :
  -e[] "\n
------ Bouncing balls ------------------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"
  -v - -l[]
  500,320,1,3 -plasma 1,1,9 -n 0,220
  N=12
  -repeat $N
    -ball[] {round(?(32,80))},@{-RGB}
    t$>={?(200)} x$>=@{0,?(10,w-10)} h$>={?(150,300)} vx$>={if(?<0.5,1,-1)*?(1,8)}
  -done
  -mv[0] @# -w[-1] -1,-1,0,"[G'MIC] Bouncing balls"
  (0;0.7;1) -r[-1] @{-2,w},70,1,1,3

  -do
    [$N]
    -repeat $N
      bw=@{$>,w} bh=@{$>,h}
      y={${h$>}*abs(cos(${t$>}*pi/60))-$bh/2}
      dt=1
      -if {$y<0} d={-$y} y=0 bh={$bh-$d} bw={$bw+$d} dt={max(0.2,1-($d/$bh)^2)} -else dt=1 -endif
      -if {${x$>}+$bw/2>w}
        d={${x$>}+$bw/2-w} bw={$bw-$d} bh={$bh+0.5*$d}
        -if {${x$>}+$bw/4>w} vx$>={-${vx$>}} -endif
      -endif
      -if {${x$>}-$bw/2<0}
        d={$bw/2-${x$>}} bw={$bw-$d} bh={$bh+0.5*$d}
        -if {${x$>}-$bw/4<0} vx$>={-${vx$>}} -endif
      -endif
      --r[$>] $bw,$bh,1,4,3 -s[-1] c,-3
      -j[-3] [-2],{max(0,min(@{$N,w-$bw},${x$>}-$bw/2))},{@{$N,h}-@{-1,h}-$y-70},0,0,1,[-1],255 -rm[-2,-1]
      t$>={${t$>}+$dt}
      x$>={${x$>}+$dt*${vx$>}}
    -done

    --rows[-1] {h-2*70},{h-1-70} -mirror[-1] y -*[-1] [{$N+1}]
    -j[-2] [-1],0,@{-2,h-71},0,0,0.5 -rm[-1]
    -w[-1] -rm[-1] -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -rm -endl -v +

#@gmic x_fire
#@gmic : Launch the fire effect demo.
x_fire : -skip "${1=G'MIC}"
  -e[] "\n
------ Fire effect ----------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -

  # Init image data.
  -i[0] 100,32 -w[0] 450,200,0,"[G'MIC] Fire effect"
  -i[1] (0,255,255,255,255^0,0,255,255,255^0,0,0,128,255) -r[1] 256,1,1,3,3
  -i[2] (0,0,0;0,0,0;1,1,1;0,1,0) -*[2] 0.21
  -text3d "$1",34,3,1 -mv[-1] 3 -c3d[3] -n3d[3] -*3d[3] 320 -col3d[3] 255,205,130 -db3d 0 -f3d 300
  100,100 -rand[-1] 0,255 -ellipse[-1] 50%,50%,5,5,0,1,300 -b[-1] 10
  -sharpen[-1] 1000 -shrink_xy[-1] 1 -n[-1] 0,255 -to_rgb[-1] -light3d [-1] -rm[-1]

  # Start animation loop.
  angle=0
  -do
    -correlate[0] [2]                                                # Apply fire effect.
    @{0,w},1 -rand[-1] 128,256 -j[0] [-1],0,{@{0,h}-1} -rm[-1]       # Add new random values at the bottom line.
    --r[0] 400,200,1,1,3 -map[-1] [1]                                # Map fire palette
    --r3d[3] 0,1,0,$angle -object3d[-2] [-1],50%,50%,0,1,5,0,0       # Draw 3d object.
    -*3d[-1] 0.25,0.16,1 -object3d[0] [-1],50%,50%,0,1,3,0,0
    -rm[-1]
    angle={$angle+3}                                                 # Update 3d angle.
    -w[-1] -rm[-1] -wait 40                                          # Display 3d object.
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # Exit properly.
  -rm[0-3] -w 0
  -v +

#@gmic x_fireworks
#@gmic : Launch the fireworks demo.
x_fireworks :
  -e[] "\n
------ Fireworks -----------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -l[]
  time=0
  (0;64^0;32^128;0) -r 256,128,1,3,3          # [-2] = Background (color gradient).
  [-1]                                        # [-1] = Rendered image.
  -w[-1] 512,256,0,"[G'MIC] Fireworks"        # Display window.
  -do                                         # Start animation loop.
    time={$time-1}
    -if {@#==2\ ||\ $time<0} # Insert new rocket.
      -i[0] ({?(w)},\        # X-position
             {h},\           # Y-position
             {?(-3,3)},\     # X-velocity
             {?(2)-5},\      # Y-velocity
             {30+?(20)},\    # Time of explosion
             1.5,\           # Radius
             255,255,255)    # Color
      time={?(40)}           # Elapsed time until next rocket.
    -endif
    -*[-1] 0.99               # Create fading effect with previous frames.
    -j[-1] [-2],0,0,0,0,0.2   # Add background.
    i=0
    -repeat {@#-2}
      to_be_removed=0
      radius={if(@{$i,4}>0,@{$i,5}/3,@{$i,5}*(1+2*(@{$i,4}+2)/120))}
      -ellipse[-1] @{$i,0},@{$i,1},@{$i,5},{max(0.5,$radius)},{atan2(@{$i,3},@{$i,2})*180/pi},0.6,@{$i,6-8}  # Draw rocket.
      (@{$i,2},@{$i,3},0,0.09,-1,0,0,0,0) -+[$i,-1] # Compute new position of the rocket.
      -if {@{$i,0}<0\ ||\ @{$i,0}>=w\ ||\ @{$i,1}>=h\ ||\ $radius<0} to_be_removed=1 -endif # Discard if rocket disappear.
      -if {@{$i,4}<0\ &&\ @{$i,4}>=-1} # In case of explosion -> Split current rocket into several colorful rockets.
        color={min(255,80+?(200))},{min(255,80+?(200))},{min(255,80+?(200))}
        radius={?(10)}
        N={5+?(10)}
        -repeat $N
          angle={$>*2*pi/$N}
          -i[-3] (@{$i,0,1},{2*cos($angle)+@{$i,2}/1.5},{2*sin($angle)+@{$i,3}/1.5},-2,$radius,$color)
        -done
        to_be_removed=1
      -endif
      -if $to_be_removed -rm[$i] -else i={$i+1} -endif  # If processed rocket has to be removed.
    -done
    -w[-1] -wait 20  # Display rendered frame.
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -endl -k[-1] -w[] 0 -v +

#@gmic x_fisheye
#@gmic : Launch the fish-eye effect demo.
x_fisheye :
  -e[] "\n
------ Fish-eye effect ------------------\n
----\n
---- Mouse pointer moves fish-eye center.\n
---- Mouse buttons set fish-eye size.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"

  -v -
  -if {@#>0} -a x -n 0,255 -r2dy 220 -else
  120,90,1,3 -rand[-1] 0,255 -plasma[-1] 0.3,3 -n 0,255
  -t "  G'MIC\nFISH-EYE\n EFFECT",15,13,24,1,255 -scale2x -b 5 -sharpen 1000
  -f i+150-4*abs(y-h/2) -c[-1] 0,255 -frame_fuzzy[-1] 15,10,15,1.5,0 -to_rgb[-1]
  -endif
  -torus3d 20,6 -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} --r3d[-1] 1,0,0,90
  -col3d[-1] {?(30,255)},{?(30,255)},{?(30,255)} -+3d[-1] 15 -+3d[-2,-1] -db3d 0 -c3d[-1]
  R=30
  -w[-2] {2*@{-2,w}},{2*@{-2,h}},0,"[G'MIC] Fish-eye effect"
  -do
    -wait 40
    -if {@{!,b}==1} R={min(80,$R+8)} -endif
    -if {@{!,b}==2} R={max(3,$R-8)} -endif
    --object3d[-2] [-1],{50+30*cos(@|*2.5)}%,{50+30*sin(@|*1.6)}%,{50+330*sin(@|*2.6)},0.7,3,0,0 -r3d[-2] 1,0.2,0.6,3
    -if {@{!,x}>=0}
    -fisheye[-1] {@{!,x}*100/@{!,w}},{@{!,y}*100/@{!,h}},$R
    -endif
    -w[-1] -rm[-1]
    -if {@!==0" || "@{!,ESC}" || "@{!,Q}} -rm[-2,-1] -w 0 -v + -return -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -wait -1 -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -wait -1 -endif
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -wait -1 -endif
  -while 1

#@gmic x_fourier
#@gmic : Launch the fourier filtering demo.
x_fourier :
  -e[] "\n
------ Fourier-filtering ----------------------------------------\n
----\n
---- Mouse buttons on the right image to set min/max frequencies.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 256 -endif

  -repeat @# -l[$>]

    # Init variables.
    need_update=1  # need_update (boolean)
    freqmin=0      # min freq. (in %)
    freqmax=100    # max freq. (in %)

    -if {w>3*@{!,u}/5} -r2dx[-1] {3*@{!,u}/10} -endif  # Reduce image size if necessary.
    -if {h>3*@{!,v}/5} -r2dy[-1] {3*@{!,v}/5} -endif

    # Compute fourier transform.
    --fft[-1] -nm[-2] real -nm[-1] imag

    # Generate log-magnitude image.
    --sqr[real,imag] -+[-2,-1] -sqrt[-1] -+[-1] 1 -log[-1]
    -n[-1] 0,255 -shift[-1] 50%,50%,0,0,2 -to_colormode[-1] @{-2,s}
    -nm[-1] logmag

    -w[0,-1] -1,-1,0,"[G'MIC] Fourier filtering"

    -if {!narg($first_time)} --l[-1] -r2dy 128 -frame 1,1,0
    -alert "[G'MIC Fourier filtering]",\
           "The G'MIC Fourier filtering demo illustrates the effect\n"\
           "of bandpass frequency filtering on an image. Use your mouse\n"\
           "buttons to select low and high bounds for the frequencies\n"\
           "displayed on the Fourier representation of the image\n"\
           "(right image).",\
           "Start demo"
    -rm -endl first_time=0 -endif

    # Enter user event-loop.
    -do

      -if $need_update # If image must be updated.

        # Generated filtering mask.
        -i[mask] 100%,100%
        r={sqrt(w^2+h^2)*$freqmax/200} -ellipse[mask] 50%,50%,$r,$r,0,1,1
        r={max(0,sqrt(w^2+h^2)*$freqmin/200-1)} -if $r -ellipse[mask] 50%,50%,$r,$r,0,1,0 -endif

        # Compute filtered log-magnitude.
        --*[logmag] [mask] -+[-1] [mask] -/[-1] 2 -n[-1] 0,255

        # Compute filtered fourier representation.
        -shift[mask] -50%,-50%,0,0,2
        --*[real,imag] [mask]
        -rm[-4]

        # Compute filtered image by inverse fourier.
        -ifft[-2,-1] -rm[-1] -n[-1] 0,255

        # Display filtered image.
        -rv[-2,-1]
        -if @! -r[-2,-1] {@{!,w}/2},@{!,h} -endif
        -t[-1] "Freq. Min/Max = "{int($freqmin)}"% / "{int($freqmax)}"%",5,5,13,1,255
        -w[-2,-1] -rm[-2,-1]
        need_update=0

      -endif

      -wait

      -if {@{!,b}" && "@{!,x}>=@{!,w}/2}  # If mouse button pressed on the right pane.
        r={200*sqrt((@{!,x}-3*@{!,w}/4)^2+(@{!,y}-@{!,h}/2)^2)/\ # Compute selected radius (in %).
           sqrt((@{!,w}/2)^2+@{!,h}^2)}
        -if {@{!,b}&1} freqmax=$r        # Update max freq. if left button.
        -else freqmin={max(0,$r-3)}      # Update min freq. if other button.
        -endif
        -if {$freqmin>=$freqmax} freqmin=$freqmax -endif   # Check that the min/max freq. are ordered.
        need_update=1                                      # Tell that the image must be updated.
      -endif

      -if @{!,r} need_update=1 -endif
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} need_update=1 -endif # Increase window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} need_update=1 -endif # Decrease window size.
      -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] {2*@{0,w}},@{0,h} need_update=1 -endif         # Reset window size.

    -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -rm[-3--1]  # Clean images.
  -endl -done -w 0 -rm -v +

#@gmic x_histogram
#@gmic : Launch the histogram demo.
x_histogram :
  -e[] "\n
------ Histogram demo -------------------------------\n
----\n
---- Mouse to set parameters.\n
---- Right button or key 'SPACE' to reset.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 300,300 -else -k[0] -to_rgb -r2dy 300,2 -if {w>800} -r 800,100%,1,3,2 -endif -n 0,255 -endif

  # Prepare image layout.
  --frame[-1] 1,1,0
  300,{h},1,3,220
  -t[-1] "Gamma :",5,0,16,1,0
  -t[-1] "Contrast :",5,50,16,1,0
  -t[-1] "Brightness :",5,100,16,1,0
  -t[-1] "Smoothness :",5,150,16,1,0
  -t[-1] "Sharpness :",5,200,16,1,0
  -t[-1] "Clusters :",5,250,16,1,0
  -a[-2,-1] x
  {w},200,1,3,255
  -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,0
  -rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,0
  -axes[-1] 0,255,1,0,13,1,0
  -frame[-2,-1] 5,5,220
  -a[-2,-1] y

  # Initialize variables.
  clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1

  # Start event loop.
  -do

    # Render corrected image and insert it in canvas.
    [0]
    ia={ia}
    -if $gamma -/[-1] 255 -^[-1] {1/$gamma} -*[-1] 255 -endif
    --[-1] $ia -*[-1] $contrast -+[-1] $brightness -+[-1] $ia
    -b[-1] $smoothness
    -sharpen[-1] $sharpness
    -c[-1] 0,255
    --j[-2] [-1],6,6

    # Render parameter sliders.
    sx={@{0,w}+12}
    -_x_histogram[-1] {$gamma*100/4} -j[-2] [-1],$sx,25 -rm[-1]
    -_x_histogram[-1] {$contrast*100/4} -j[-2] [-1],$sx,75 -rm[-1]
    -_x_histogram[-1] {($brightness+128)*100/256} -j[-2] [-1],$sx,125 -rm[-1]
    -_x_histogram[-1] {$smoothness*100/10} -j[-2] [-1],$sx,175 -rm[-1]
    -_x_histogram[-1] {$sharpness*100/2000} -j[-2] [-1],$sx,225 -rm[-1]
    -_x_histogram[-1] {$clusters*100/256} -j[-2] [-1],$sx,275 -rm[-1]

    # Render corresponding histogram.
    --s[-2] c -histogram[-3--1] $clusters,0,255 -/[-3--1] {3*@{0,wh}/$clusters} -rm[-5]
    --z[-4] 5,317,{@{-4,w}-5},{@{-4,h}-6}
    -graph[-1] [-4],3,0,1,0,0.2,255,0,0
    -graph[-1] [-3],3,0,1,0,0.2,0,255,0
    -graph[-1] [-2],3,0,1,0,0.2,0,0,255
    -rm[-4--2]
    -j[-2] [-1],5,317 -rm[-1]

    # Display rendering.
    -w[-1] {w},{h},0,"[G'MIC] Histogram demo" -rm[-1]
    -wait

    # Manage user interactions.
    -if {@{!,b}&1\ &&\ @{!,x}>=@{0,w}-10}
      -if {@{!,y}>=25\ &&\ @{!,y}<=42}
        gamma={max(0,min(4,(@{!,x}-$sx)*4/280))}
      -elif {@{!,y}>=75\ &&\ @{!,y}<=92}
        contrast={max(0,min(4,(@{!,x}-$sx)*4/280))}
      -elif {@{!,y}>=125\ &&\ @{!,y}<=142}
        brightness={max(-128,min(128,(@{!,x}-$sx)*256/280-128))}
      -elif {@{!,y}>=175\ &&\ @{!,y}<=192}
        smoothness={max(0,min(10,(@{!,x}-$sx)*10/280))}
      -elif {@{!,y}>=225\ &&\ @{!,y}<=242}
        sharpness={max(0,min(2000,(@{!,x}-$sx)*2000/280))}
      -elif {@{!,y}>=275\ &&\ @{!,y}<=292}
        clusters={max(2,min(256,(@{!,x}-$sx)*256/280))}
      -endif
    -endif
    -if {@{!,b}&2\ ||\ @{!,SPACE}} clusters=64 sharpness=0 smoothness=0 contrast=1 brightness=0 gamma=1 -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -rm -v +

_x_histogram :
  val={max(0,min(100,$1))}
  280,2,1,3,255 -line[-1] 0,0,$val%,0,1,0,255,0 -line[-1] 0,1,$val%,1,1,240,255,62 -r[-1] 100%,16,1,3,3
  0 -t[-1] {round($val)}%,0,0,20,1,1 --*[-1] -255 -+[-1] 255 -r[-1] 100%,100%,1,3
  -j[-3] [-1],{(280-w)/2},{(16-h)/2},0,0,1,[-2] -rm[-2,-1]
  -r[-1] {w+2},{h+2},1,3,0,0,0.5,0.5

#@gmic x_hough
#@gmic : Launch the hough transform demo.
x_hough :
  -e[] "\n
------ Hough-transform -----------------------------------------\n
----\n
---- Mouse buttons on the vote image to draw corresponding line.\n
---- Mouse buttons on the image to vote for all lines crossing.\n
---- the clicked point.\n
---- Key 'SPACE' to reset the hough window.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 400 -endif
  -n 0,255

  -repeat @# -l[$>]
    -r[-1] @{-fitscreen\ {w},{h}},1,100%,3  # Resize to fit screen if necessary.

    rhomax={sqrt(w^2+h^2)/2}
    --b[-1] 1.5 -hough[-1] 512,400 -b[-1] 0.5 -+[-1] 1 -log[-1] -n[-1] 0,255
    -w[-2] -1,-1,0,"[G'MIC] Image" -w1[-1] -1,-1,0,"[G'MIC] Hough transform"
    -if {!narg($first_time)} --l[0] -r2dy 128 -frame 1,1,0
    -alert "[G'MIC Hough Transform]",\
           "The G'MIC Hough transform demo illustrates the application\n"\
           "of the Hough transform to detect lines in an image. Use your\n"\
           "mouse buttons to explore the transform image and see how\n"\
           "lines in images are represented by points in the transform.",\
           "Start demo"
    -rm -endl first_time=0 -endif

    -do
      -wait

      -if @{!,b} # When clicking on the image.
        x0={@{!,x}-@{!,w}/2}
        y0={@{!,y}-@{!,h}/2}
        rho0={sqrt(($x0)^2+($y0)^2)}
        theta0={atan2($y0,$x0)}
        (0,{2*pi}) ($theta0,{$theta0-2*pi})
        -r[-2,-1] @{-3,w},1,1,1,3
        -cos[-1] -*[-1] $rho0 --lt[-1] 0 -abs[-2]
        -*[-1] {pi} -+[-3,-1] -%[-2] {2*pi}
        -*[-2] {0.5*@{-3,w}/pi} -*[-1] {@{-3,h}/$rhomax}
        -a[-2,-1] y
        -repeat {w} -point[-2] @{-1,($>,0)},@{-1,($>,1)},0,0.3,255 -done
        -rm[-1] -w1[-1]

      -elif {@{!1,x}>=0" && "@{!1,b}} # When clicking on the vote window.
        theta={@{!1,x}*2*pi/@{!1,w}}
        rho={@{!1,y}*$rhomax/@{!1,h}}
        x={@{-2,w}/2+$rho*cos($theta)}
        y={@{-2,h}/2+$rho*sin($theta)}
        x0={$x+1000*sin($theta)}
        y0={$y-1000*cos($theta)}
        x1={$x-1000*sin($theta)}
        y1={$y+1000*cos($theta)}
        [-2]
        -line[-1] $x0,$y0,$x1,$y1,1,0x0F0F0F0F,255
        -line[-1] {$x0+1},$y0,$x1,$y1,1,0x0F0F0F0F,255
        -line[-1] $x0,{$y0+1},$x1,$y1,1,0x0F0F0F0F,255
        -line[-1] $x0,$y0,$x1,$y1,1,0xF0F0F0F0,0
        -line[-1] {$x0+1},$y0,$x1,$y1,1,0xF0F0F0F0,0
        -line[-1] $x0,{$y0+1},$x1,$y1,1,0xF0F0F0F0,0
        -w[-1] -rm[-1]

      -elif {@{!,SPACE}" || "@{!1,SPACE}}
        -rm[-1] --b[-1] 1.5 -hough[-1] 512,400 -b[-1] 0.5 -+[-1] 1 -log[-1] -n[-1] 0,255
        -w1[-1] -1,-1,0,"Hough Transform"

      -elif @{!,r} -w[-2]
      -elif @{!1,r} -w1[-1]
      -endif

    -while {@!" && "@{!1}" && "!@{!,ESC}" && "!@{!,Q}" && "!@{!1,ESC}" && "!@{!1,Q}}

    -rm[-1] -endl
    -if {!@!" || "!@{!1}} -break -endif
    -w0 0
  -done -rm -v +

#@gmic x_jawbreaker : 0<_width<20,0<_height<20,0<_balls<=8
#@gmic : Launch the Jawbreaker game.
x_jawbreaker : -check "${1=12}>0 && $1<20 && ${2=13}>0 && $2<20 && ${3=5}>0 && $3<=8"
  -e[] "\n
------ Jawbreaker --------------------------------------------\n
----\n
---- The goal of the game is to remove the maximum number of\n
---- balls on the board, simply by clicking on them. But a\n
---- colored ball can disappear only if it is grouped with at\n
---- least one ball of the same color. The score is higher if\n
---- you destroy larger sets of connected colored balls.\n
----\n
---- Left mouse button to select/destroy balls on board.\n
---- Key 'BACKSPACE' or 'SPACE' to undo the last move.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -

  # Init images and variables.
  -i[board] $1,$2 -rand[board] 1,$3 -round[board] 1
  -i[undo] [-1]
  -i[balls] 32,32,1,4 -_x_jawbreaker_ball[-1] -autocrop[-1] 0 -expand_xy[-1] 1,0 -*[-1] 1.5 -c[-1] 0,255 -r[-1] {@{board,w}*w},{@{board,h}*h},1,1,0,2 -/[-1] 255
  -i[back] {w},{h},1,3 -l[-1]
    -rand 0,255 -blur_xy 6,20 -equalize 100,0,255 -blur_xy 2,4
    -sh 0,0 -sh[-2] 1,1 -sh[-3] 2,2 -/[-3] 4 -/[-2] 8 -/[-1] 2 -rm[-3--1]
  -endl
  -i[visu] [back]
  score=0
  undoscore=0
  render_board=1
  shapescorey=0
  shapescore=0

  # Enter user-event loop.
  -do

    # Render board graphics.
    -if $render_board
     --abs[board] --[-1] 1 -*[-1] {360/$3} --ge[board] 0 -*[-1] 0.9 -r[-2,-1] [balls] [balls] -a[-3--1] c -hsv2rgb[-1]
      --compose_channels[-1] + -gt[-1] 0 -dilate[-1] 3
      -j[visu] [back] -j[visu] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
      -if {!$shapescorey} -w[visu] @{back,w},@{back,h},0,"[G'MIC] Jawbreaker (score : "$score")" -endif
      render_board=0
    -endif

    # Add shape score sprite if necessary.
    -if $shapescorey
      --t[visu] "+"$shapescore,@{!,x},{@{!,y}-64+$shapescorey},32,{($shapescorey-1)/31},255
      shapescorey={max(0,$shapescorey-1)}
      -w[-1] @{back,w},@{back,h},0,"[G'MIC] Jawbreaker (score : "$score")" -rm[-1] -wait 25
    -else -wait -endif

    # Check for the end of the game.
    --f[board] "if(i,j(-1)==i || j(1)==i || j(0,1)==i || j(0,-1)==i,0)"
    -if {!@{-1,+}} -rm[-1] -break -endif -rm[-1]

    # Manage user-events
    -if @{!,r} render_board=1                   # Will resize window to initial size, if resized.
    -elif @{!,S} -o[visu] gmic_jawbreaker.png   # Save snapshot if requested.
    -elif {@{!,BACKSPACE}" || "@{!,SPACE}}      # Manage undo move.
      -abs[undo] -j[board] [undo]
      score=$undoscore
      render_board=1

    -elif {@{!,x}">=0 && "@{!,b}}               # Manage button click.

      # Retrieve board coordinates.
      -wait -1
      x={"int("@{!,x}"*"@{board,w}"/"@{!,w}")"}
      y={"int("@{!,y}"*"@{board,h}"/"@{!,h}")"}

      # When selecting a ball -> display selection and init new shape score sprite.
      -if {@{board,($x,$y)}>0}
        -abs[board] -flood[board] $x,$y,0,0,0,1,-@{board,($x,$y)}
        --ge[board] 0 --[-1] 1
        shapescore={(@{-1,+}+1)^2} shapescorey={if($shapescore,32,0)} -rm[-1]

      # When confirming selection of a ball -> remove set of connected balls.
      -elif @{board,($x,$y)}

        --flood[board] $x,$y,0,0,0,1,-1 -==[-1] -1
        -if {@{-1,+}>1} # If selected ball is connected to at least one ball.

          # Save undo state.
          -j[undo] [board]
          undoscore=$score

          # Manage board shifts (vertical and horizontal).
          -flood[board] $x,$y,0,0,0,1,0
          -repeat @{board,w}
            --columns[board] $> -mirror[-1] y
            h=@{board,h} -l[-1] -s -,0 -a y -if @# -r 1,$h,1,1,0 -mirror y -else -i 1,$h -endif -endl
            -j[board] [-1],$> -rm[-1]
          -done
          -rows[board] -1,100% -f[board] "if(y==0,if(i(x,h-1),x,w),i)" -sort[board] +,x -rows[board] 1,100%

          # Update score.
          score={$score+int((@{-1,+}-1)^2)}

        -endif
        -rm[-1] # Remove selection mask.

      -else -abs[board]  # Remove previous selection if clicked outside balls.
      -endif

      render_board=1
    -endif

  -while {@!" && "!@{!,Q}" && "!@{!,ESC}}

  # Game over.
  -if {@!" && "!@{!,ESC}}
    -w[] @{visu,w},@{visu,h},0,"[G'MIC] Jawbreaker (final score : "$score")"
    -i[gameover] 230,85 -t[-1] "Game Over!",3,0,57,1,1 -t[-1] "Score : "$score,24,54,32,1,1
    --dilate[-1] 5 -nm[-1] "mgameover" -*[-2] 255 -r[-2] 100%,100%,1,3
    -repeat 25
      --r[gameover,mgameover] {400-12*($>+1)}%,{400-12*($>+1)}%
      --j[visu] [-2],{(@{visu,w}-w)/2},{(@{visu,h}-h)/2},0,0,{$>/25},[-1]
      -w[-1] -rm[-3--1] -wait 25
    -done
    -do
      -wait -if @{!,r} -w[] @{!,w},@{!,h} -wait -1 -endif
      -while {@!" && "!@{!,Q}" && "!@{!,ESC}" && "!@{!,b}}
    -rm[gameover,mgameover]
  -endif

  # End properly.
  -rm[board,undo,balls,back,visu]
  -w 0 -v +

_x_jawbreaker_ball :
  mwh={min(w,h)}
  -sh 3,3 -f[-1] 0 -rm[-1]
  -ellipse {0.5*$mwh},{0.5*$mwh},{0.5*$mwh-4},{0.5*$mwh-4},0,1,240,240,240,1
  -sh 0,2 -*[-1] '($mwh+y-x)/(2*w)' -rm[-1]
  -ellipse {$mwh*0.7},{$mwh*0.3},{min(30,$mwh*$mwh/512)},{min(30,$mwh*$mwh/512)},0,{min($mwh/64,1)},255,255,255,1
  -sh 0,2 -b[-1] {0.02*$mwh} -rm[-1]
  -sh 3,3 -*[-2] [-1] -dilate[-1] 3 -rm[-1]
  -sh 0,2 -+[-1] 'if(i&&(!j(-1)||!j(1)||!j(0,-1)||!j(0,1)),240/6,0)' -rm[-1]

#@gmic x_life
#@gmic : Launch the game of life.
x_life :
  -e[] "\n
------ The game of life --------------------------------------\n
----\n
---- The goal is to create the biggest possible biological\n
---- system. You start with a stock of cells which you can\n
---- spread over the board. For each new cells created\n
---- simultaneously and spontaneously by your system, you\n
---- gain more new cells to scatter.\n
----\n
---- Left mouse button to scatter cells in stock.\n
---- Right mouse button to reset game.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -i[0] 90,90,1,1,0                                             # Image[0] = game state.
  -i[1] [0] -f[1] 0                                             # Image[1] = generation counter.
  -i[2] 400,400,1,3                                             # Image[2] = visualization.
  -i[3] 1                                                       # Image[3] = colormap (to be initialized).
  iteration=0                                                   # Iteration counter.
  score=0                                                       # Current score.
  bestscore=0                                                   # Best score.
  stock=500                                                     # Remaining cells.
  -w[0] 400,400,0,"[G'MIC] The game of life"                    # Initialize display window.
  -cursor[0] 0

  # Start user-event loop.
  -do
    (1,1,1;1,0,1;1,1,1) --correlate[0] [-1],0 -rm[-2]           # Count numbers of neighboring living cells.
    --t2[-1] 2,2 -and[-1] [0] -t2[-2] 3,3 -or[-2,-1]            # Make the game evolve (kill or create cells).
    -rv[0,-1]                                                   # Update game state.
    -if {@{!,x}>0" && "@{!,b}==1" && "$stock>0}                 # Add random cells to the game if user presses mouse button.
      nb={?*7}
      -repeat $nb
        x={@{!,x}/@{!,w}*@{0,w}+?(-4,4)}
        y={@{!,y}/@{!,h}*@{0,h}+?(-3,3)}
        -=[0] 1,$x,$y
        -=[1] $iteration,$x,$y
        -point[2] {$x*@{2,w}/@{0,w}},{$y*@{2,h}/@{0,h}},0,0.8,255
      -done
      stock={round(max(0,$stock-$nb))}
    -endif

    --[-1] [0] -*[-1] -1                                        # Compute difference between consecutive states.
    stock={$stock-2*(min(0,int(@{-1,+}/16*$score/150)))}        # Increment available cells if the evolution is fast.
    -+[1] [0]                                                   # Increment generation counter for still existing cells.
    -min[-1] 0 -+[-1] 1 -*[1,-1]                                # Reset generation counter for died cells.

    -if {@{!,b}==2}                                             # Reset game if right mouse button has been pressed.
      -f[0-2] 0 iteration=0 score=0 bestscore=0 stock=500 -rm[3] -i[3] 1
    -endif

    -if {@{3,w}==1}                                             # Create color palette if necessary.
      -rm[3] -i[3] {?(3,12)},1,1,3,?(100,255)
      -r[3] {?(100,300)}%,1,1,3,4
      -point[3] 0,0,0,1,0
      -r[3] {?(100,600)}%,1,1,3,5 -c[3] 0,255
    -endif

    --r[1] @{2,w},@{2,h} -and[-1] 7 -b[-1] {1+$score*0.05}   # Render colored image of the game and display it.
    -n[-1] 0,@{3,w} -map[-1] [3] -*[-1] 0.1 -+[2,-1] -/[2] 1.1
    [2] -if {@{!,x}>0}                                          # Add a small target icon at the mouse position.
      opac={0.7*min(1,$stock/500)} r={min(500,$stock)*cos($iteration)/100}
      -ellipse[-1] @{!,x},@{!,y},{15+$r},{15+$r},0,$opac,0,196,0
      -ellipse[-1] @{!,x},@{!,y},{10+$r},{10+$r},0,$opac,32,64,16
      -ellipse[-1] @{!,x},@{!,y},{5+$r},{5+$r},0,$opac,255,230,0
    -endif
    -t[-1] "Living cells : "$score"\n"\                      # Add score description.
           "Stock : "$stock"\n"\
           "Score : "$bestscore,5,3,22,0.7,255
    -w[-1] @{!,w},@{!,h}
    -if @{!,S} -o[-1] gmic_life.png -endif                      # Save snapshot if requested.
    -rm[-1]

    -if {!($iteration%10)} score=@{0,+} bestscore={max($score,$bestscore)} -endif  # Re-compute current and best scores, every 10th iterations.
    -wait 60
    iteration={$iteration+1}
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # End game and quit properly.
  -rm[0-3] -w 0 -v +

#@gmic x_light
#@gmic : Launch the light effect demo.
x_light :
  -e[] "\n
------ Light effect ----------------------\n
----\n
---- Move light position with mouse.\n
---- Mouse buttons fade light in/out.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -

  # Create warping and color images.
  0 -t[-1] "    G'MIC\nLight effect",0,0,57,1,255 -expand_xy[-1] 15,0 -b[-1] 3
  [-1] -n[-2] 0,1 -r[-2] 100%,100%,1,3
  -sh[-2] 0,0 -*[-1] 120 -rm[-1]
  -sh[-2] 1,1 -*[-1] 70 -rm[-1]
  -sh[-2] 0,50%,0,2 -*[-1] 120 -rm[-1]
  25%,25%,1,1 -rand[-1] -20,20 -smooth[-1] 10,0,1,1,4 -r[-1] [-2],3 -b[-1] 3 -n[-1] -60,60
  -+[-2,-1] -g[-1] xy -a[-2,-1] c -n[-1] -150,150
  -w[] {1.5*@{-2,w}},{1.5*@{-2,h}},0,"[G'MIC] Light effect"  # Init display window.
  -cursor[0] 0

  # Create a large light image.
  light=70
  512,512 -gaussian[-1] $light -n[-1] 0,255
  t=0

  # Start animation.
  -do

    # Manage light position and intensity.
    -if {@{!,x}>=0}
      X={round((w-@{!,x})/2)}
      Y={round((h-@{!,y})/2)}
    -else
      X={round((w-@{-2,w}*(1+cos(2*$t)))/2)}
      Y={round((h-@{-2,h}*(1+sin(2.5*$t)))/2)}
      t={$t+0.02}
    -endif
    -if {@{!,b}&1} light={min(200,$light+10)} -gaussian[-1] $light -n[-1] 0,255 -endif
    -if {@{!,b}&2} light={max(10,$light-10)} -gaussian[-1] $light -n[-1] 0,255 -endif

    # Render lightened image.
    --z[-1] $X,$Y,{$X+@{-2,w}-1},{$Y+@{-2,h}-1}
    -warp[-1] [-3],1,0,1
    -r[-1] 100%,100%,1,3 -+[-1] [-4] -c[-1] 0,255
    -w[-1] {1.5*w},{1.5*h}
    -rm[-1] -if {@{!,x}>=0" && "!@{!,b}} -wait -else -wait 20 -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w[] 0 -rm[-3--1] -v +

#@gmic x_mandelbrot : _julia={ 0 | 1 },_c0r,_c0i
#@gmic : Launch Mandelbrot/Julia explorer.
x_mandelbrot : -skip ${1=0},${2=0.317},${3=0.03}
  -e[] "\n
------ Mandelbrot/Julia explorer -----------------\n
----\n
---- Select zooming region with mouse.\n
---- Click once to reset zoom factor.\n
---- Keys 'ESC' or 'Q' to exit.\n
---- Key 'C' to print current fractal coordinates.\n
----\n
--------------------------------------------------"

  # Init variables and display.
  -v -
  -rm -w 512,512,0 -_x_mandelbrot_coords $1 -_x_mandelbrot_palette

  # Start event loop.
  -do
    siz={min(@{!,w},@{!,h})}                                                                      # Desired window dimension.
    $siz,$siz -mandelbrot[-1] @0,256,$1,{if($1,$2,0)},{if($1,$3,0)} -map[-1] [1]                  # Render fractal.
    -if $1 -w[-1] $siz,$siz,0,"[G'MIC] Julia set c=("@{0,0}","@{0,1}")-("@{0,2}","@{0,3}"), c0=($2,$3)" # Display on window.
    -else -w[-1] $siz,$siz,0,"[G'MIC] Mandelbrot set c=("@{0,0}","@{0,1}")-("@{0,2}","@{0,3}")" -endif
    w={w} h={h} -select[-1] 2                                                                     # Get the user selection.

    -if {@{-1,0}>0}                                                                               # If valid selection found.
      M={max(@{-1,3}-@{-1,0},@{-1,4}-@{-1,1})}                                                    # Compute max dimension of selected rectangle.
      -if {$M<5} -_x_mandelbrot_coords $1 -rm[1] -_x_mandelbrot_palette -mv[-1] 1                 # If selection too small, reset the view,
      -else ({@{0,0}+@{-1,0}*(@{0,2}-@{0,0})/$w};\                                                # Else compute new fractal coordinates.
             {@{0,1}+@{-1,1}*(@{0,3}-@{0,1})/$h};\
             {@{0,0}+(@{-1,0}+$M)*(@{0,2}-@{0,0})/$w};\
             {@{0,1}+(@{-1,1}+$M)*(@{0,3}-@{0,1})/$h})
      -endif
      -rm[0] -mv[-1] 0                                                          # Validate new coordinates.
    -endif
    -rm[-1]                                                                     # Delete latest rendering.
    -if {@{!,C}}                                                                # If 'C' key has been pressed.
      -if $1 -v + -e[0--4] "Julia set, at c = ("@{0,0-1}")-("@{0,2-3}"), with c0 = ($2,$3)." -v -
      -else -v + -e[0--4] "Mandelbrot set, at c = ("@{0,0-1}")-("@{0,2-3}")." -v -
      -endif
    -endif
    -if {!@!" || "@{!,ESC}" || "@{!,Q}} -rm -w 0 -v + -return -endif
    -wait -1
  -while 1

_x_mandelbrot_coords :
  -if $1 (-2;-2;2;2) -else (-2.1;-1.5;1.2;1.5) -endif

_x_mandelbrot_palette :
  6,1,1,3 -rand[-1] 20,255 -r[-1] 32,1,1,3,3 -r[-1] 1024,1,1,3,0,2 -=[-1] 0,0,0,0,0 -=[-1] 0,0,0,0,1 -=[-1] 0,0,0,0,2

#@gmic x_metaballs3d
#@gmic : Launch the 3d metaballs demo.
x_metaballs3d :
  -e[] "\n
------ 3d metaballs ---------------------------------------\n
----\n
---- Mouse button or 'SPACE' key to switch rendering mode.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------------"
  -v - -l[]
  100,100 -noise[-1] 100,1 -plasma[-1] 1,0,10 -r[-1] 512,320,1,3 -n[-1] 0,1 -b[-1] 4,0 -n[-1] 0,255
  -mix_channels[-1] (0.7,0,0;0,0.9,0;0,0,1.2) -c[-1] 0,255 -l3d
  0
  24,24,24,1,'X=x-w/2;Y=y-h/2;Z=z-d/2;exp(-(X*X+Y*Y+Z*Z)/100)'
  72,72,72 M=8 mode=5
  s0=Dots s1=Wireframe s2=Flat s3=Flat-shaded s4=Gouraud-shaded s5=Phong-shaded
  -repeat $M fx$>={g*1.5} fy$>={g*1.5} fz$>={g*1.5} -done
  -w[0] -1,-1,0,"[G'MIC] 3d metaballs"
  -do
    -repeat $M
      x$>={w/2+0.5*(w-@{2,w}-4)*cos(${fx$>}*@|)}
      y$>={h/2+0.5*(h-@{2,h}-4)*sin(${fy$>}*@|)}
      z$>={d/2+0.5*(d-@{2,d}-4)*sin(${fz$>}*@|)}
    -done
    -f[3] 0 -repeat $M -j[3] [2],{${x$>}-@{2,w/2}},{${y$>}-@{2,h/2}},{${z$>}-@{2,d/2}},0,-1 -done
    --r[3] 24,24,24,1,2 -isosurface3d[-1] 0.4 --3d[-1] 12,12,12 -*3d[-1] 13 -rv3d[-1]
    -r3d[-1] 1,2,1,{100*@|}
    N={i[7]} (255,255,150;200,96,164;50,150,230) -r[-1] 3,$N,1,1,3 -y[-1] -j[-2] [-1],0,{@{-2,h}-4*$N} # Do some color tweaks.
    -if {!$mode} -circles3d[-2] 4 -endif
    -if {!@{1,w}}
      0 -text[-1] ${s$mode},5,5,24,0.5,255,255,255 -b[-1] 0.7 -n[-1] 0,255
      --dilate[-1] 3 --j[0] [-2],5,3,0,0,1,[-1],255 -mv[-1] 1 -rm[2,-2,-1]
    -endif
    --object3d[1] [-2],50%,50%,0,1,{if(!$mode,3,$mode)},0,0,300,0,0,-500,0.1,1.5
    -w[-1] -rm[-3--1] -wait 20
    -if {@{!,b}||@{!,SPACE}} mode={($mode+if(@{!,b}&2,-1,1))%6} -wait -1 -rm[1] -i[1] 0 -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -endl -v +

#@gmic x_minesweeper : 8<=_width=<20,8<=_height<=20
#@gmic : Launch the Minesweeper game.
x_minesweeper : -check "${1=20}>=8 && $1<=30 && ${2=$1}>=8 && $2<=30"
  -e[] "\n
------ Minesweeper -------------------------------------------\n
----\n
---- The goal is to clear the minefield without detonating a\n
---- mine.\n
----\n
---- Left mouse button to try clearing one square.\n
---- Right mouse button to flag or unflag a square.\n
---- Middle mouse button to reset mine field.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------\n"
  -v -
  # Generate random mine field and player board.
  # Labels : 0=mine, 1=empty, 2='1-near', 3='2-near', ..., 9='8-near', 10=still unknown.
  $1,$2 -noise[-1] 30,2 nb_mines=@{-1,+} (1,1,1;1,0,1;1,1,1) --convolve[-2] [-1],0 -rm[-2] -+[-1] 1 -==[-2] 0 -*[-2,-1] -nm[-1] field
  -do x={round(?(w-1))} y={round(?(h-1))} -while {i($x,$y)!=1} # Find a good starting point.
  --f[field] 11 -=[-1] 12,$x,$y -nm[-1] board

  # Generate sprite graphics.
  24,24,1,3,200 -fc[-1] 255,180,130
  -ellipse[-1] 12,12,4,4 -line[-1] 6,12,18,12 -line[-1] 12,6,12,18 -line[-1] 13,10,14,10,1,255 -line[-1] 13,11,14,11,1,255
  -z[-1] 1,1,{w-2},{h-2} -frame[-1] 1,1,0
  --fc[-1] 230,250,255
  --t[-1] "1",10,5,13,1,0,196,0 --t[-2] "2",9,5,13,1,0,128,0 --t[-3] "3",9,5,13,1,0,0,255
  --t[-4] "4",9,5,13,1,255,0,0 --t[-5] "5",9,5,13,1,200,0,0 --t[-6] "6",9,5,13,1,150,0,0
  --t[-7] "7",9,5,13,1,128,0,0 --t[-8] "8",9,5,13,1,64,0,0 -erode[-8--1] 2
  --f[-1] 'if(x<=1||y<=1||x>=w-2||y>=h-2,if(x<y,128,255),160+2*(y+x))'
  --polygon[-1] 4,13,15,11,15,6,18,17,18,1,0 -line[-1] 12,15,12,6,1,255,0,0 -polygon[-1] 3,12,6,6,9,12,12,1,220,0,0
  -rv[-2,-1]
  [-1] 100%,100%,1,3 -line[-1] 6,14,10,18,1,0,200,0 -line[-1] 10,18,16,6,1,0,200,0 -dilate[-1] 2
  --channels[-1] 1 -n[-1] 0,0.7 -dilate[-1] 3 -j[-3] [-2],0,0,0,0,1,[-1] -rm[-2,-1]
  -a[-13--1] x -nm[-1] sprites

  # Pre-calculate offsets and canvas for faster board rendering.
  (0,23;0,23^0,0;23,23) -r[-1] 24,24,1,2,3 -r[-1] {@{board,w}*24},{@{board,h}*24},1,2,0,2 -nm[-1] offsets
  [-1],[-1],1,3,255 -frame[-1] 1,1,0 -frame[-1] 23,23,255
  0 -t[-1] "Number of mines : "$nb_mines,0,0,18,1,100,200,255 -negative[-1] -j[-2] [-1],{(@{-2,w}-w)/2},{@{-2,h}-h-2} -rm[-1]
  -nm[-1] canvas

  # Start user interaction loop.
  failed=0 succeeded=0 nb_flags=0 started=0
  -do

    # Render board.
    --*[board] 24 -r[-1] [offsets],[offsets] -channels[-1] 0,1 -+[-1] [offsets] --warp[sprites] [-1],0,0 -rm[-2]
    -j[canvas] [-1],24,24 -rm[-1]

    # Wait for user's selection.
    -wait -1
    -if $failed
      0 -t[-1] "Game\nOver!",3,3,38,1,255 -r[-1] 100%,100%,1,4 -sh[-1] 3,3 -dilate[-1] 5 -/[-1] 2 -rm[-1]
      -drop_shadow[-1] 5,5,1 -blend[canvas,-1] alpha
      0 -t[-1] "Boom! You failed!",0,0,18,1,100,255,255 -r[-1] @{canvas,w},100%,1,3,0,0,0.5,0.5 -negative[-1] -j[canvas] [-1],0,3 -rm[-1]
      -do -w[canvas] {w},{h} -wait -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -elif $succeeded
      0 -t[-1] "Success!",3,3,38,1,255 -r[-1] 100%,100%,1,4 -sh[-1] 3,3 -dilate[-1] 5 -/[-1] 2 -rm[-1]
      -drop_shadow[-1] 5,5,1 -blend[canvas,-1] alpha
      0 -t[-1] "Congratulations! ("{round(@|-$tic)}" s)",0,0,18,1,255,100,255 -r[-1] @{canvas,w},100%,1,3,0,0,0.5,0.5
      -negative[-1] -j[canvas] [-1],0,3 -rm[-1]
      -do -w[canvas] {w},{h} -wait -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -else
      --==[board] 10 nb_flags=@{-1,+} -rm[-1]
      -do
        -if {!$started} tic=@| -endif
        0 -t[-1] "Elapsed time : "{round(@|-$tic)}" s / Flags : "$nb_flags,0,0,18,1,255,200,0 -r[-1] @{canvas,w},100%,1,3,0,0,0.5,0.5
        -negative[-1] -j[canvas] [-1],0,3 -rm[-1]
        -wait 50
        x={int((@{!,x}-24)/24)} y={int((@{!,y}-24)/24)} b=@{!,b}
        -w[canvas] {w},{h},0,"[G'MIC] Minesweeper"
      -while {@!" && "!@{!,ESC}" && "!@{!,Q}" && "!$b}
    -endif

    # Manage selected square.
    -if {$x>=0\ &&\ $y>=0\ &&\ $x<@{board,w}\ &&\ $y<@{board,h}}
      -if {$b&1}  # Try to clean square.
        started=1 val=@{field,($x,$y)}
        -if {$val==0} --==[field] 0 -j[board] [field],0,0,0,0,1,[-1] -rm[-1] failed=1  # Found a mine -> boom!
        -elif {$val==1} --flood[field] $x,$y,0,0,1,1,-1 -==[-1] -1 -dilate[-1] 3 -j[board] [field],0,0,0,0,1,[-1] -rm[-1] # Found an empty area.
        -else -=[board] $val,$x,$y # Close to one or several mines.
        -endif
      -elif {n=@{board,($x,$y)};$b&2" && "n>=10" && "n<=11}
        -=[board] {if(@{board,($x,$y)}==11,10,11)},$x,$y # Flag or unflag a square.
      -elif {$b&4} -f[board] 10  # Reset minefield.
      -endif
    -endif

    -if {$nb_mines==$nb_flags\ &&\ @{board,M}!=11} succeeded=1 -endif  # Check if board is cleared.
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -w 0 -v +

#@gmic x_minimal_path
#@gmic : Launch the minimal path demo.
x_minimal_path :
  -e[] "\n
------ Minimal path ------------------------------------------\n
----\n
---- Click on two points to compute and display the minimal\n
---- path between those points. The ending point is then\n
---- chosen as the next starting point for another path.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 400 -endif
  -n 0,200 -round 1
  -repeat @# -l[$>]
    -w[0] -1,-1,0,"[G'MIC] Select starting point P0"
    -if {!narg($first_time)} --l[0] -r2dy 128 -frame 1,1,0
    -alert "[G'MIC Minimal path]",\
           "The G'MIC minimal path demo illustrates how minimal paths\n"\
           "can be computed in images to detect and track edge points.\n"\
           "Use your mouse to select desired starting and ending points,\n"\
           "and see what is the minimal path computed between these points.",\
           "Start demo"
    -rm -endl first_time=0 -endif
    --gradient_norm -b[-1] 1 -f[-1] exp(-i/10)
    -to_rgb[0] --select[0] 0 P0=@-1
    -ellipse[0] @{-1,0,1},3,3,0,1,255,0,255
    -ellipse[0] @{-1,0,1},3,3,0,1,0xFFFFFFFF,255,255,255
    -rm[-1]
    -if {min($P0)>=0}
      p=1
      -do
        -w[0] -1,-1,0,"[G'MIC] Select ending point P"$p
        --select[0] 0
        -if {@{!,S}}
          -rm[-1]
          --text_outline[0] "Saving snapshot...",5,5,13,1,1,255,255,255 -w[-1] -rm[-1]
          -o[0] gmic_minimal_path.png
          -wait -1
        -else
          P1=@-1
          -ellipse[0] @{-1,0,1},3,3,0,1,255,0,255
          -ellipse[0] @{-1,0,1},3,3,0,1,0xFFFFFFFF,255,255,255
          -rm[-1]
          -if {min($P1)>=0}
            --text_outline[0] "Processing...",5,5,13,1,1,255,255,255 -w[-1] -rm[-1]
            --minimal_path[1] $P0,$P1,1
            -pointcloud[-1] 0 -*[-1] 255 -r[-1] 100%,100%,1,[0],0,0,0,0,0,0.5 -r[-1] [0],0 -or[0,-1]
            P0=$P1 p={$p+1}
          -endif
        -endif
      -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
    -endif
    -rm[1]
  -endl -done -w 0 -v +

#@gmic x_pacman
#@gmic : Launch pacman game.
x_pacman :
  -e[] "\n
------ Pacman -----------------------------------------------\n
----\n
---- This is a G'MIC implementation of the pacman game.\n
----\n
---- Move the pacman to eat all pacdots on the different levels.\n
---- Eating a pacgum makes pacman invincible for 10 seconds,\n
---- which mean pacman can eat ghosts during this time.\n
---- Eating a ghost earns 100 pts.\n
---- Eating a cherry earns 10 pts.\n
---- Eating a strawberry earns 100 pts.\n
---- Eating an orange earns 1000 pts.\n
---- Eating a banana earns 5000 pts.\n
----\n
---- Arrow keys to control pacman.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v - -rm

  # Initialize characters gfx.
  -m "_pacman_ghost_base_gfx : 31,19 -circle[-1] 15,15,15,1,1 31,12,1,1,'y<4+8*abs(cos(x*0.3+0.25*pi*$""1))' -a[-2,-1] y"
  -repeat 4
    -_pacman_ghost_standard_gfx 255,0,0,$> -nm[-1] ghost0_$>
    -_pacman_ghost_standard_gfx 0,255,222,$> -nm[-1] ghost1_$>
    -_pacman_ghost_standard_gfx 255,184,222,$> -nm[-1] ghost2_$>
    -_pacman_ghost_standard_gfx 255,184,71,$> -nm[-1] ghost3_$>
    -_pacman_ghost_afraid_gfx $> -nm[-1] ghosta_$>
    -_pacman_ghost_base_gfx $> -r[-1] 16,16,1,1,2 -nm[-1] ghostm_$>
    -_pacman_ghost_standard_gfx 0,0,0,$> -nm[-1] ghostd_$>
    -_pacman_pacman_gfx $> -nm[-2] pacman_$> -nm[-1] pacmanm_$>
  -done
  --channels[ghostd_0] 0 -!=[-1] 0 -nm[-1] ghostdm
  -_pacman_cherry_gfx -nm[-1] fruit0 -_pacman_strawberry_gfx -nm[-1] fruit1
  -_pacman_orange_gfx -nm[-1] fruit2 -_pacman_banana_gfx -nm[-1] fruit3
  20,2,1,3,200 -nm[-1] gate
  score0="10" score1="100" score2="1000" score3="5000" score4="Argh!"
  -repeat 5
    0 -t[-1] ${score$>},0,0,13,1,255,255,255 -autocrop[-1] 0 -expand_xy[-1] 1,0 --dilate[-1] 3
    -nm[-1] scorem$> -nm[-2] score$>
  -done
  time4=255,255,255 time3=255,255,32 time2=255,128,32 time1=255,32,32
  -repeat 11 0 -t[-1] $<" s",0,0,23,1,${time{min(4,round(($<+1)/2))}} -nm[-1] time$< -done
  0 -t[-1] "Get Ready!",0,0,32,1,255 -autocrop[-1] 0 -expand_xy[-1] 4,0 --dilate[-1] 8 -r[-2] 100%,100%,1,3
  -nm[-2] get_ready -nm[-1] get_readym
  0 -t[-1] "Game\nOver!",0,0,57,1,255 -autocrop[-1] 0 -expand_xy[-1] 4,0 --dilate[-1] 8 -r[-2] 100%,100%,1,3
  -nm[-2] game_over -nm[-1] game_overm

  # Start game.
  score=0 level=-1 lives=3 is_quit=0
  -do

    # Build new level if necessary.
    -if {$level<0}
      _rlevel=33 _glevel=33 _blevel=255
      -_pacman_map_level{((-$level-1)%6)+1} mw={w} mh={h} mw2={int(w/2)} mh2={int(h/2)}
      -if {$level<-6} -replace[-1] 3,2 -endif
      -nm[-1] map0 -i[map] [-1]

      # Precompute valid directions on each map point, and shortest path to the ghost's home.
      --shift[map] -1,0 --shift[map] 0,-1 --shift[map] 1,0 --shift[map] 0,1 -a[-4--1] z -!=[-1] 1 -nm[-1] can_go
      --==[map] 1 100%,100% -=[-1] 1,$mw2,$mh2 -distance[-1] 1,[-2],3 -rm[-2]
      -f[-1] 'if(i==2,0,if(i==8,1,if(i==1,2,if(i==4,3,i))))' -nm[-1] path
      --==[map] 2 pacdots=@{-1,+} -rm[-1]
      level={-$level}
    -endif

    # Render board gfx.
    -f[map] 'if(i>=4,0,i)' --==[map] 1 -expand_xy[-1] 1,0 -r[-1] 1600%,1600% -erode[-1] 9 -b[-1] 2
    -g[-1] xy -abs[-2,-1] -+[-2,-1] -ge[-1] 80% -b[-1] 2 -n[-1] 0,1 -shrink_xy[-1] 16
    --*[-1] $_glevel --*[-2] $_blevel -*[-3] $_rlevel -a[-3--1] c
    16,16,1,1,'x' ---[map] 1 -max[-1] 0 -*[-1] 16 -r[-1] 1600%,1600%
    16,16,1,1,'y' -r[-3,-1] [-2],0,2 -+[-2,-1] -a[-2,-1] c
    16,16,1,3 -_pacman_pacdots_gfx -_pacman_pacgum_gfx -a[-3--1] y
    -warp[-1] [-2],0,0 -rm[-2] -or[-2,-1] -r[-1] 100%,{h+24},1,3,0,0,0,1
    -t[-1] "Lives :",10,0,23,1,255 -t[-1] "Score :",{w-140},0,23,1,255
    -if $lives --r[pacman_2] 12,12,1,4,2 -r[-1] {100*$lives}%,100%,1,4,0,2 -j[-2] [-1],90,7 -rm[-1] -endif
    -nm[-1] visu
    -w[visu] -1,-1,0,"[G'MIC] Pacman" -cursor[0] 0
    0 -t[-1] "Level "$level,0,0,57,1,1 -autocrop[-1] 0 -expand_xy[-1] 4,0 (0,255^0,255^0,0) --map[-2] [-1] -rm[-2] -dilate[-2] 8
    -nm[-1] level_N -nm[-2] levelm_N

    -repeat 4 xg$>={16*$mw2} yg$>={16*$mh2+4*$>} dg$>=3 mg$>=0 -done
    xp={16*10} yp={16*21} dp=-1 pacgum_timer=-1 fruit_timer=@| dying_pacman=0 is_get_ready=1
    xscore=0 yscore=0 nscore=0 oscore=0

    # Start game interaction.
    -do

      # Display board graphics.
      t={int(6*@|)%4} left={if($pacgum_timer>=0,10-@|+$pacgum_timer,-1)}
      [visu]
      -repeat 4
        mg=${mg$>} xg=${xg$>} yg={${yg$>}+24}
        -if {$mg==0} -j[-1] [ghost$>_$t],$xg,$yg,0,0,1,[ghostm_$t]
        -elif {$mg==1} t2={if($left>7,$t,if($left>3,int(12*@|)%4,int(24*@|)%4))} -j[-1] [ghosta_$t2],$xg,$yg,0,0,1,[ghostm_$t]
        -elif {$mg==2} -j[-1] [ghostd_$t],$xg,$yg,0,0,0.8,[ghostdm]
        -else -j[-1] [ghost$>_$t],$xg,$yg,0,0,{$mg-2},[ghostm_$t] -j[-1] [ghostd_$t],$xg,$yg,0,0,1,[ghostdm]
        -endif
      -done
      -if $dying_pacman
        -_pacman_pacman_gfx {$dying_pacman/2} -rotate[-2,-1] {90*(abs($dp)-1)} -j[-3] [-2],$xp,{24+$yp},0,0,1,[-1],255 -rm[-2,-1]
        dying_pacman={$dying_pacman+1}
        -if {$dying_pacman>64}
          -if {$lives!=1} -rm[-1] -break -endif
          -j[-1] [game_over],{(w-@{game_over,w})/2},{12+(h-@{game_over,h})/2},0,0,{min(1,($dying_pacman-64)/50)},[game_overm],255
          -rectangle[-1] 90,7,101,18,1,0
        -endif
      -else
        --rotate[pacman_$t,pacmanm_$t] {90*(abs($dp)-1)} -j[-3] [-2],$xp,{24+$yp},0,0,1,[-1],255 -rm[-2,-1]
        -if {$left>=0" && "($left>=5" || "$t<=2)} -j[-1] [time{round($left)}],{(w-@{time0,w})/2},1 -endif
      -endif
      -t[-1] $score,{w-65},1,22,1,255
      -if {$is_get_ready}
        -j[-1] [level_N],{(w-@{level_N,w})/2},{12+(h-1.5*@{level_N,h})/2},0,0,1,[levelm_N]
        -if {int(@|*4)%2} -j[-1] [get_ready],{(w-@{get_ready,w})/2},{24+(h+@{get_ready,h})/2},0,0,1,[get_readym],255 -endif
      -endif
      -if {$oscore>0} -j[-1] [score$nscore],$xscore,$yscore,0,0,$oscore,[scorem$nscore],255 oscore={$oscore-0.04} yscore={$yscore-1} -endif
      -j[-1] [gate],158,223,0,0,0.6
      -w[-1] -rm[-1]

      # Manage ghosts displacements and collisions.
      -repeat 4
        xg=${xg$>} yg=${yg$>} dg=${dg$>} mg=${mg$>}

        -if {max(abs($xg-$xp),abs($yg-$yp))<=8}            # Test collision between ghost and pacman.
          -if {$mg==0" && "!$dying_pacman} dying_pacman=1  # Was in normal mode -> dying pacman.
            xscore=$xp yscore={$yp+12} oscore=1 nscore=4
          -elif {$mg==1} mg=2 mg$>=$mg score={$score+100}  # Was in invicibility mode -> dying ghost.
            xscore=$xp yscore={$yp+12} oscore=1 nscore=1
          -endif
        -endif
        -if {$mg>=2" && "($xg>>4)==$mw2" && "($yg>>4)==$mh2} # Check if dying ghost has returned to home.
          mg={$mg+0.01}
          -if {$mg>=3} mg=0 xg={$xg&-2} yg={$yg&-2} -endif
          mg$>=$mg
        -endif

        -if {!($xg&15)" && "!($yg&15)} # Check if ghost can take a new direction.
          ({?},{?},{?},{?};0,1,2,3)
          -if {$mg<2}
            -=[-1] {?(0.6,1)},{if($mg==0,dX0=$xp-$xg;dY0=$yp-$yg;if(abs(dX0)>abs(dY0),if(dX0>0,0,2),if(dY0>0,1,3)),\ # Try to chase pacman.
                                         dX1=$xp-$xg;dY1=$yp-$yg;if(abs(dX1)<abs(dY1),if(dX1>0,2,0),if(dY1>0,3,1)))} # Try to escape pacman.
            -=[-1] 0,{($dg+2)%4}
            -if $is_get_ready -=[-1] 0.8,@{path,({$xg>>4},{$yg>>4})} -endif
          -else -=[-1] 1,@{path,({$xg>>4},{$yg>>4})} # If dying ghost, follow the best path to home.
          -endif
          -sort[-1] -,x -repeat 4 d={i($>,1)} -if @{can_go,({$xg>>4},{$yg>>4},$d)} dg=$d -break -endif -done -rm[-1] # Try directions until it matches.
          dg$>=$d
        -endif
        u={D=${dg$>};(D==0)-(D==2)}
        v={D=${dg$>};(D==1)-(D==3)}
        xg$>={($xg+$u*(1+($mg==0)))%(16*$mw)}
        yg$>={($yg+$v*(1+($mg==0)))%(16*$mh)}
      -done

      -wait 22

      # Manage pacman displacement.
      -if {!$dying_pacman}
        d={if(@{!,ARROWRIGHT},1,if(@{!,ARROWDOWN},2,if(@{!,ARROWLEFT},3,if(@{!,ARROWUP},4,$dp))))}
        -if {!($xp&15)" && "!($yp&15)}
          i=@{map,({$xp>>4},{$yp>>4})}
          -if {$i==2} score={$score+10} pacdots={$pacdots-1} # Pacdot eaten.
          -elif {$i==3} pacgum_timer=@| -repeat 4 -if {!${mg$>}} mg$>=1 dg$>={(${dg$>}+2)%4} -endif -done  # Pacgum eaten.
          -elif {$i>=4} score={$score+${score{$i-4}}} xscore=$xp yscore={$yp+12} oscore=1 nscore={$i-4} # Fruit eaten.
          -endif
          -=[map] 0,{$xp>>4},{$yp>>4}
          16,16,1,3 -j[visu] [-1],$xp,{24+$yp} -rm[-1]
          d={if(@{can_go,({$xp>>4},{$yp>>4},{abs($d)-1})},$d,$dp)}
          d={if(@{can_go,({$xp>>4},{$yp>>4},{abs($d)-1})},$d,-abs($dp))}
          dp=$d
        -else dp={if(abs($d-$dp)==2,$d,$dp)}  # Allow to turn back on non-integer locations.
        -endif
        is_get_ready={if($dp>0,0,$is_get_ready)}
        u={($dp==1)-($dp==3)}
        v={($dp==2)-($dp==4)}
        xp={($xp+2*$u)%(16*$mw)}
        yp={($yp+2*$v)%(16*$mh)}

        -if {$pacgum_timer>=0" && "@|>$pacgum_timer+10} # Check if pacgum still has some effect.
          -repeat 4 xg$>={${xg$>}&-2} yg$>={${yg$>}&-2} mg$>={if(${mg$>}==1,0,${mg$>})} -done
          pacgum_timer=-1
        -endif

        -if {!$is_get_ready" && "(@|-$fruit_timer)>=10}
          x={round(?(0,@{map0,w}))}
          y={round(?(0,@{map0,h}))}
          -if {!@{map,($x,$y)}" && "@{map0,($x,$y)}==2}
            n={min(3,int(abs(g*1.7)))} -=[map] {4+$n},$x,$y -j[visu] [fruit$n],{16*$x},{16*$y+24} fruit_timer=@|
          -endif
        -endif

      -endif
      -if {!@!" || "@{!,Q}" || "@{!,ESC}} is_quit=1 -endif

    -while {!$is_quit" && "$pacdots}

    -if $is_quit -break         # Player asked to quit.
    -elif $pacdots              # Player lost a life.
      lives={$lives-1}
    -else                       # Player achieved level.
      level={-$level-1} -wait[0] -1
      -rm[map0,map,can_go,path]
    -endif
    -rm[visu,level_N,levelm_N]
  -while $lives
  -rm -w 0 -v +

# The functions below create the various sprite gfx.
_pacman_ghost_standard_gfx :
  -_pacman_ghost_base_gfx $4 (0,$1^0,$2^0,$3) -map[-2] [-1] -rm[-1]
  -ellipse[-1] 10,11,3,4,0,1,255 -ellipse[-1] 20,11,3,4,0,1,255
  -r[-1] 16,16,1,3,2 -point[-1] 5,{7-($4>=2)},0,1,1 -point[-1] 10,{7-($4>=2)},0,1,1

_pacman_ghost_afraid_gfx :
  -_pacman_ghost_base_gfx $1
  -if {$1<2} col=255,255,255 (0,0^0,0^0,208) -else col=255,0,0 (0,248^0,248^0,248) -endif
  -map[-2] [-1] -rm[-1] -r[-1] 16,16,1,3,2
  -line[-1] 4,4,6,6,1,$col,255 -line[-1] 4,6,6,4,1,$col,255
  -line[-1] 9,4,11,6,1,$col,255 -line[-1] 9,6,11,4,1,$col,255
  -f[-1] 'if(y>=9&&y<=10&&x>=2&&x<=13&&((int((x+1)/2)+y)%2),arg(c+1,$col),i)'

_pacman_pacman_gfx :
  32,32,1,1,'X=x-15;Y=y-15;A=atan2(Y,X);R=sqrt(X^2+Y^2);R<15.5&&abs(A)>0.8*0.33*$1'
  (0,255^0,255^0,0^0,255) -map[-2] [-1] -rm[-1] -r[-1] 16,16,1,4,2 -s[-1] c,-3

_pacman_pacdots_gfx :
  (255^184^151) -r[-1] 4,4,1,3 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_pacgum_gfx :
  16,16,1,3 -circle[-1] 7,7,7,1,255,128,64

_pacman_cherry_gfx :
  (12,12,1,1,0,-10,-2,1,-8,-4,1,-6,-2,1,0,1,-7,0,1,-3,0,1,-3,-4,2,-3,0,1,-3,-6,2,0,1,-4,-5,2,0,-4,2,-2,\
   0,2,3,-2,2,0,-6,2,0,-2,2,3,2,0,-6,2,-2,-3,2,0,2,3,-4,2,-6,-2,2,3,-3,2,-7,-4,2,-2,0)
  -uncompress_rle[-1] (0,0,255,255^0,173,0,255^0,0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_strawberry_gfx :
  (11,12,1,1,0,-5,0,3,-7,-3,1,3,-3,1,-3,-2,2,-5,1,-2,2,0,-4,2,-3,1,-2,2,3,-2,2,3,-5,2,3,-6,2,3,\
   2,3,-13,2,3,-2,2,0,2,3,-2,2,3,-4,2,-2,-9,2,-3,-2,2,3,-2,2,3,-6,-5,2,-8,0,2,-5,0)
  -uncompress_rle[-1] (0,0,255,255^0,173,0,255^0,0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_orange_gfx :
  (12,13,1,1,0,-5,0,1,0,-2,1,-8,-6,1,-6,0,1,3,-3,1,-4,-3,2,1,-4,2,-3,-10,2,0,-60,2,0,-10,2,-2,-10,2,-4,-6,2,-3,0)
  -uncompress_rle[-1] (0,0,255,255^0,173,173,255^0,0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_banana_gfx :
  (9,12,1,1,0,-7,0,1,-7,-2,1,-7,-3,1,-5,0,1,0,-2,1,-5,0,1,0,-2,1,-4,0,1,0,-3,1,-4,0,1,0,-3,\
   1,-3,0,1,0,1,2,1,-3,0,1,0,1,2,-2,1,-2,0,1,0,1,2,-2,1,-2,-6,1,-3,-4,1,-5,0)
  -uncompress_rle[-1] (0,255,255^0,173,255^0,0,255) -map[-2] [-1] -rm[-1] -r2dy[-1] 14 -r[-1] 16,16,1,3,0,0,0.5,0.5

_pacman_map_level1 :
  (11,28,1,1,0,-12,1,-5,2,1,-4,2,1,3,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-10,2,-3,1,2,1,2,-3,1,2,1,-2,0,1,2,1,2,-3,1,2,-4,1,\
   2,1,2,-3,1,2,1,-3,0,2,1,-5,2,-4,1,2,-3,1,0,-3,1,-2,0,1,2,-3,1,0,-3,1,-2,0,1,2,-9,0,1,2,-3,1,0,-2,1,-3,0,1,2,1,-3,0,1,-4,\
   0,1,2,1,0,1,0,1,-2,-3,1,2,1,0,1,0,-3,1,-3,0,2,-2,0,1,-4,-3,1,2,-5,1,0,1,-2,0,1,-5,2,-2,0,1,-2,0,1,2,-3,1,2,-6,1,2,-3,1,2,\
   -4,1,-9,2,0,1,2,-3,1,2,-3,1,2,-2,1,2,-3,1,2,1,-3,2,-2,1,3,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-10,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -crop[-1] 1,100% -a[-2,-1] x
  _rlevel=33 _glevel=33 _blevel=255

_pacman_map_level2 :
  (11,28,1,1,0,-12,1,-10,2,1,3,1,2,-3,1,2,-4,1,2,1,2,-3,1,2,1,-2,2,1,2,1,-5,2,1,2,-2,1,2,-3,1,2,1,2,1,2,-2,1,2,-3,1,2,1,2,1,\
   2,-2,1,-5,2,1,-3,2,-4,1,2,-5,1,0,1,-2,0,1,2,-5,1,0,1,-2,0,1,2,-5,1,0,1,-2,0,1,-3,2,1,-4,-3,1,0,1,2,1,0,-2,1,-5,0,1,2,1,0,1,\
   -2,-5,1,2,-2,0,1,-2,-5,1,2,1,0,-3,1,-4,0,1,2,1,-4,-3,1,-3,2,-3,1,0,1,-2,0,1,2,1,-3,2,-2,0,1,-2,0,1,2,-3,1,2,1,0,-4,1,2,-3,1,\
   2,1,0,-2,1,-7,2,1,-2,0,1,2,-3,1,2,1,2,-4,1,2,1,-3,2,1,-4,2,1,3,1,2,-5,1,2,-2,1,2,1,2,-5,1,2,-2,1,-9,2,-12,1)
  -uncompress_rle[-1] --mirror[-1] x -crop[-1] 1,100% -a[-2,-1] x
  _rlevel=200 _glevel=33 _blevel=33

_pacman_map_level3 :
  (11,28,1,1,0,-11,1,-6,0,1,-4,2,-5,1,0,1,2,-8,1,0,1,2,-4,1,3,-8,2,-2,1,2,-5,1,2,1,2,-2,1,2,-5,1,2,1,2,-2,1,2,1,-5,2,1,2,-2,1,2,\
   1,2,-3,1,0,1,2,-2,1,-5,2,1,0,1,-2,2,-5,1,2,1,0,-4,1,-5,2,1,-4,0,1,2,-3,1,2,1,0,-2,1,0,1,2,-3,1,2,1,0,1,-2,0,1,-3,2,1,2,-2,0,1,\
   -2,-3,1,2,1,2,1,0,-3,1,-2,0,1,2,1,2,1,-6,0,1,2,1,2,-2,1,0,-2,1,-2,0,1,2,1,2,-2,1,0,-2,1,-2,0,1,-6,2,-5,1,2,-4,1,2,-2,1,-3,-3,2,\
   1,-3,2,0,-3,1,2,1,2,1,2,-4,1,3,-2,2,1,-5,2,-2,1,2,-3,1,2,-3,1,2,-2,1,2,-3,1,2,-3,1,2,-2,1,-10,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -crop[-1] 1,100% -a[-2,-1] x
  _rlevel=33 _glevel=200 _blevel=255

_pacman_map_level4 :
  (11,28,1,1,0,-9,1,-2,0,1,-7,2,1,-2,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,-3,2,3,-3,2,-4,1,2,-2,1,2,-2,1,-4,2,1,2,\
   -2,1,2,-2,1,2,-2,1,2,1,-7,2,-2,1,2,1,2,-2,1,2,-2,1,-4,2,1,2,-2,1,2,-2,1,2,-2,1,2,1,-7,2,-2,1,2,-3,1,-10,0,1,-5,-2,1,0,-3,1,-5,0,1,\
   -10,0,1,-2,-3,1,-5,-6,1,-8,0,1,2,-9,0,1,2,-2,1,2,-2,1,2,-2,1,2,1,2,-2,1,2,-2,1,2,-2,1,2,1,-10,2,1,2,-2,1,2,-2,1,2,-3,0,1,2,-2,1,2,\
   -2,1,2,0,-3,1,-3,2,3,-4,2,1,0,1,2,-2,1,2,-2,1,2,-2,1,0,1,2,-2,1,2,-2,1,2,1,-2,0,1,-7,2,1,-2,-9,1,-2,0)
  -uncompress_rle[-1] --mirror[-1] x -crop[-1] 1,100% -a[-2,-1] x
  _rlevel=200 _glevel=200 _blevel=33

_pacman_map_level5 :
  (11,28,1,1,0,-12,1,-7,2,1,-2,2,1,3,-5,1,2,1,2,-2,1,2,-5,1,2,1,2,-2,1,2,1,-7,2,-2,1,-3,2,1,2,-3,1,2,-4,1,2,1,2,1,0,1,2,-4,1,2,1,2,\
   -3,1,2,1,-4,0,1,-6,2,1,2,1,0,-3,1,0,-4,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-3,1,0,1,0,-2,1,0,1,2,-3,1,0,1,0,1,-2,0,1,2,-4,0,1,0,1,-2,\
   0,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-3,1,0,-3,1,0,-2,1,-5,2,1,-3,2,-4,1,2,1,2,1,2,-6,1,2,1,2,1,2,-4,1,3,-2,2,1,-5,2,0,1,2,-3,1,2,-3,\
   1,2,-2,1,-5,2,1,-3,2,-2,1,2,-3,1,2,1,2,-4,1,2,-3,1,2,1,2,-4,1,-5,2,1,-4,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -crop[-1] 1,100% -a[-2,-1] x
  _rlevel=200 _glevel=255 _blevel=33

_pacman_map_level6 :
  (11,28,1,1,0,-12,1,-10,2,1,2,-2,1,2,-7,1,3,-9,2,-5,1,2,-6,1,-10,2,1,2,-4,1,0,-5,1,2,1,-8,0,1,2,1,0,-3,1,0,-3,1,0,2,1,0,1,-6,2,1,2,\
   -2,0,1,2,-2,1,0,-3,1,2,1,-2,0,2,1,-4,0,1,2,1,0,1,2,-2,-2,1,0,1,2,1,0,1,2,1,0,1,-2,0,1,2,1,0,1,2,1,0,1,-2,0,1,2,1,0,1,2,-2,-4,1,2,\
   1,-2,0,2,1,-4,0,1,2,-2,0,1,2,-2,1,0,-2,1,0,2,1,0,1,-6,2,1,2,1,0,-3,1,0,-4,1,2,1,-8,0,1,2,-4,1,0,-3,1,0,1,-10,2,-5,1,2,-6,1,3,-9,\
   2,1,2,-2,1,2,-7,1,-10,2,-11,1)
  -uncompress_rle[-1] --mirror[-1] x -crop[-1] 1,100% -a[-2,-1] x
  _rlevel=255 _glevel=130 _blevel=233

#@gmic x_paint
#@gmic : Launch the interactive painter.
x_paint :
  -e[] "\n
------ Interactive painter -----------------------\n
----\n
---- Use mouse to select color and brush.\n
---- Left button draws a colored stroke.\n
---- Right button fills a colored region.\n
---- Arrow keys or SPACE and BACKSPACE to swap\n
---- between available images.\n
---- Key 'S' to save snapshot of the current view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------"
  -v - -to_rgb

  # Init variables and images.
  -if {!@#} -i[0] 512,512,1,3,255 -nm[0] "[New image]" -endif
  color=0,0,0
  saturation=1
  brushsize=3
  brushopacity=0
  brushangle=90
  brushthickness=1
  image=0
  refresh_palette=1
  refresh_image=1
  refresh_brush=1
  ox1=-1
  oy1=-1
  1 1    # Palette image [-2] and brush image [-1]

  # Start user event loop.
  -do

    # Open/refresh palette window.
    -if $refresh_palette
      -rm[-2] (0,359;0,359^$saturation,$saturation;$saturation,$saturation^1,1;0,0) -r[-1] 256,64,1,3,3 -hsv2rgb[-1]
      (255;0) -r[-1] 16,@{-2,h},1,3,3 -line[-1] 0,0,0,100%,1,0 -a[-2,-1] x
      {w},16,1,3 -t[-1] "Selected color",4,2,13,1,255
      -rectangle[-1] 80,3,100,13,1,$color
      -rectangle[-1] 80,3,100,13,1,0xFFFFFFFF,255,255,255
      -a[-2,-1] y -w2[-1] {w},{h},0,"Palette" -mv[-1] -2
      refresh_palette=0
    -endif

    # Open/refresh brush window.
    -if $refresh_brush
      -rm[-1] (32,64;64,32) -r[-1] 16,16,1,3,1 -r[-1] {8*48},{4*48},1,3,0,2
      -repeat 4 -repeat 8
        -ellipse[-1] {48*$>+24},{48*@{>,-2}+24},{2*$>+1},{(2*$>+1)*$brushthickness},$brushangle,{1-@{>,-2}/4},255
      -done -done
      -rectangle[-1] {$brushsize*48},{$brushopacity*48},\
                     {$brushsize*48+47},{$brushopacity*48+47},\
                     1,0xFFFFFFFF,255,128,128
      {w},16,1,3 -line[-1] 0,50%,100%,50%,1,0x55555555,128,64,128
      bx={$brushangle*w/180}
      -rectangle[-1] {$bx-16},20%,{$bx+16},80%,1,128
      -line[-1] {$bx-16},20%,{$bx+16},20%,1,255 -line[-1] {$bx+16},20%,{$bx+16},80%,1,255
      -line[-1] {$bx-16},80%,{$bx+16},80%,1,64 -line[-1] {$bx-16},20%,{$bx-16},80%,1,64
      -a[-2,-1] y
      16,{h-16},1,3 -line[-1] 50%,0,50%,100%,1,0x55555555,128,64,128
      by={$brushthickness*(h-16)}
      -rectangle[-1] 20%,{$by-16},80%,{$by+16},1,128
      -line[-1] 20%,{$by-16},80%,{$by-16},1,255 -line[-1] 80%,{$by-16},80%,{$by+16},1,255
      -line[-1] 20%,{$by-16},20%,{$by+16},1,64 -line[-1] 20%,{$by+16},80%,{$by+16},1,64
      -a[-2,-1] x
      -w3[-1] {w},{h},0,"Brush"
      refresh_brush=0
    -endif

    # Open/refresh image window.
    -if $refresh_image
      -w1[$image] @{$image,w},@{$image,h},0,"Image "#$image" : "@{$image,b}.@{$image,x}
      refresh_image=0
    -endif

    # Manage user events.
    x1=@{!1,x} y1=@{!1,y}
    x2=@{!2,x} y2=@{!2,y}
    x3=@{!3,x} y3=@{!3,y}

    -if {$x1>=0}                        # Event in the image window.
      -if {@{!1,b}&1}                   # Left button -> draw brush stroke.
        ox1={if($ox1<0,$x1,$ox1)}
        oy1={if($oy1<0,$y1,$oy1)}
        delta={max(abs($x1-$ox1),abs($y1-$oy1))}
        r1={2*$brushsize+1}
        r2={$r1*$brushthickness}
        dx={2*($x1-$ox1)/max(1,$delta)}
        dy={2*($y1-$oy1)/max(1,$delta)}
        o={1-($brushopacity/4)^0.04}
        -repeat {max(1,($delta+1)/2)}
          -ellipse[$image] {$ox1+$>*$dx},{$oy1+$>*$dy},$r1,$r2,$brushangle,$o,$color
        -done
        ox1=$x1 oy1=$y1
        refresh_image=1
      -else
        ox1=-1 oy1=-1
        -if {@{!1,b}&2}               # Right button -> fill region.
          -flood[$image] $x1,$y1,0,10,0,1,$color
          refresh_image=1
        -endif
      -endif
    -endif

    -if {@{!1,ARROWRIGHT}" || "@{!2,ARROWRIGHT}" || "@{!3,ARROWRIGHT}" || "\  # Manage image selection.
         @{!1,ARROWUP}" || "@{!2,ARROWUP}" || "@{!3,ARROWUP}" || "\
         @{!1,SPACE}" || "@{!2,SPACE}" || "@{!3,SPACE}}
      image={($image+1)%(@#-2)} refresh_image=1
    -elif {@{!1,ARROWLEFT}" || "@{!2,ARROWLEFT}" || "@{!3,ARROWLEFT}" || "\
           @{!1,ARROWDOWN}" || "@{!2,ARROWDOWN}" || "@{!3,ARROWDOWN}" || "\
           @{!1,BACKSPACE}" || "@{!2,BACKSPACE}" || "@{!3,BACKSPACE}}
      image={($image-1)%(@#-2)} refresh_image=1
    -endif

    -if @{!1,S} -o[$image] gmic_paint.png -endif  # Save snapshot if requested.

    -if {@{!2,b}" && "$x2>=0" && "$y2<64}  # Manage color selection from the palette window.
      -if {$x2>=256} saturation={1-$y2/63}
      -elif {$x2>=0} color=@{-2,($x2,$y2,0,0)},@{-2,($x2,$y2,0,1)},@{-2,($x2,$y2,0,2)}
      -endif
      refresh_palette=1
    -endif

    -if {@{!3,b}" && "$x3>=0}  # Manage brush selection.
      -if {$x3<384" && "$y3>=192} brushangle={$x3*180/(w-16)}   # Bottom slider -> select brush angle.
      -elif {$x3>=384" && "$y3<192} brushthickness={$y3/(h-16)} # Right slider -> select brush thickness.
      -elif {$x3<384" && "$y3<192} brushsize={int($x3*8/(w-16))} brushopacity={int($y3*4/(h-16))}
      -endif
      refresh_brush=1
    -endif
    -wait
    -while {@{!1}" && "!@{!1,Q}" && "!@{!1,ESC}}

  # Exit properly.
  -w1[] 0 -w2[] 0 -w3[] 0 -rm[-2,-1] -v +

#@gmic x_plasma
#@gmic : Launch the plasma effect demo.
x_plasma :
  -e[] "\n
------ Plasma effect --------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -l[]

  # Init plasma backgrounds.
  N=8
  -repeat $N
    256,150,1,3 -rand[-1] 0,255 -plasma[-1] 1,0,7 -n[-1] 0,255
    amp={?(-40,40)} freq={round(?(2,6))} dir$>={if(?<0.5,-1,1)*round(?(1,2))}
    100%,100%,1,1,'$amp*cos(y*2*pi*$freq/h)'
  -done

  {w+2},100%,1,1,'x' 100%,100%,1,1,'Y=(y-60+5*cos(x/30)+10*sin(x/15));if(Y<0||Y>=32,-1,Y)' -a[-2,-1] c
  0 -t[-1] "** Welcome to G'MIC, a powerful image processing framework **",0,0,32,1,255
  -b[-1] 0.6 -n[-1] 0,255
  M={w}

  # Start animation loop.
  -w[] {2*@{0,w}},{2*@{0,h}},0,"[G'MIC] Plasma effect"
  t=0 tt={-1.5*@{0,w}}
  -do
    tic=@|

    # Render interpolated background between two successive plasmas.
    a={int($t)}   a2={2*$a} a21={$a2+1}
    b={($a+1)%$N} b2={2*$b} b21={$b2+1}
    --warp[$a2] [$a21],1,0,2
    --warp[$b2] [$b21],1,0,2
    -j[-2] [-1],0,0,0,0,{$t-$a} -rm[-1]

    -shift[$a21] 0,${dir$a},0,0,2  # Animate plasma background.
    -shift[$b21] 0,${dir$b},0,0,2
    -if {int($t+0.005)>int($t)} dir$a={if(?<0.5,-1,1)*round(?(1,3))} -endif
    t={($t+(@|-$tic))%$N}

    # Render text scrolling.
    --z[-2] $tt,{$tt+w-1+2}
    -warp[-1] [-4],0,0,0
    -r[-1] 100%,100%,1,3
    --*[-1] -1 -+[-1] 255
    -j[-3] [-1],0,0,0,0,1,[-2],255 -rm[-1]
    -j[-2] [-1],-2,-2,0,0,1,[-1],255 -rm[-1]

    tt={$tt+(@|-$tic)*250} # Animate scrolling.
    -if {$tt>=$M} tt={-1.5*@{0,w}} -endif

    # Display rendered frame.
    -w[-1] -rm[-1]
    -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm[{-2*$N-2}--1] -w[] 0 -endl -v +

#@gmic x_quantize_rgb : _nbcolors>=2
#@gmic : Launch the RGB color quantization demo.
x_quantize_rgb : -check "isint(${1=16}) && $1>1"
  -e[] "\n
------ RGB Quantization --------------------------------------\n
----\n
---- This demo shows how RGB colors can be quantified using\n
---- the k-means algorithm.\n
----\n
---- Left mouse button on 3d view rotates the color cube.\n
---- Right mouse button on 3d view toggles colors/clusters mode.\n
---- Left mouse button on image toggles dithering mode,\n
---- Left mouse button on colormap adds a random color.\n
---- Right mouse button on colormap removes a color.\n
---- Key 'R' init colormap with random values.\n
---- Key 'U' init colormap with uniform sampling.\n
---- Key 'M' init colormap with median-cut algorithm.\n
---- Key 'SPACE' does a single iteration of k-means and pauses.\n
---- Key 'ENTER' runs k-means algorithm.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v -
  -if {!@#} -testimage2d 300 -endif                                # Create synthetic image if no input images.
  -k[0] -to_rgb -if {h>300} -r2dy 300 -round 1 -endif -nm[-1] img  # Resize input image if necessary.
  --r {w*h},1,1,3,-1 -r[-1] {min(w,8192)},1,1,3 -nm[-1] colors     # Get reduced set of image colors.
  $1,1,1,3 -rand[-1] 0,255 -round[-1] 1 -nm[-1] centroids          # Initialize random centroids.
  -_x_quantize_rgb_3d (1,0,0,0;0,1,0,0;0,0,1,0) -nm[-1] pose3d     # Init 3d object.
  -_x_quantize_rgb_text "Colors",clustering0
  -_x_quantize_rgb_text "Clusters",clustering1
  -_x_quantize_rgb_text "Dithering: off",dithering0
  -_x_quantize_rgb_text "Dithering: on",dithering1
  -if {@{img,h}<300} --r2dy[img] 300,1 -else [img] -endif          # Generate visualization canvas.
  {w+315},365,1,3,255 -rm[-2]
  -rectangle[-1] 4,4,305,305,1,0xFFFFFFFF,0
  -rectangle[-1] 309,4,{w-5},305,1,0xFFFFFFFF,0
  -rectangle[-1] 4,309,{w-5},360,1,0xFFFFFFFF,0
  [-1],[-1]
  -rectangle[-1] 310,5,{w-6},305,1,1
  -rectangle[-1] 5,310,{w-6},360,1,2
  300,300,1,1,'(y<<11)+(x<<2)+3' -j[-2] [-1],5,5 -rm[-1]
  -a[-2,-1] c  -nm[-1] visu

  # Start k-means iterations.
  dithering=0 clustering=0 pause=1 s0=off s1=on
  -repeat 1e10

    # Create and display visualization.
    -if {!narg($visu_3d)} # Update 3d vizualization.
      ---[centroids] 2 --+[centroids] 2 -a[-2,-1] x -permute[-1] cxyz -y[-1] --[-1] 128
      -j[obj3d] [-1],0,8 -rm[-1]  # Update centroids position in 3d object.
      [obj3d]
      -if $clustering
        -if {@{colors,M}<256} --index[colors] [centroids] -*[-1] 256 -+[colors,-1] -endif # Estimate nearest centroids for all colors.
        --channels[colors] 0 ->>[-1] 8 -map[-1] 2 -permute[-1] cxyz -y[-1] -j[-2] [-1],0,{@{-2,h}-$_N-h} -rm[-1]
      -endif

      -apply_pose3d[-1] @pose3d 300,300,1,3 -object3d[-1] [-2],50%,50%,100,1,2,0,0,300 -rm[-2]
      -j[-1] [clustering$clustering],2,0,0,0,1,[mclustering$clustering],255
      -nm[-1] visu_3d -j[visu] [visu_3d],5,5
    -endif

    -if {!narg($visu_img)} # Update indexed image.
      --index[img] [centroids],{0.7*$dithering},1 -if {h<300} -r2dy[-1] 300,1 -endif
      -j[-1] [dithering$dithering],2,0,0,0,1,[mdithering$dithering],255
      -nm[-1] visu_img -j[visu] [visu_img],310,5
    -endif

    -if {!narg($visu_centroids)} # Update colormap.
      --luminance[centroids] -a[-1] [centroids],y -sort[-1] +,x -rows[-1] 1 -r[-1] {@{visu,w}-10},50,1,3
      0 -text[-1] "Colors: "@{centroids,w},2,0,13,1,255,255,255 --dilate[-1] 3 -j[-3] [-2],2,2,0,0,1,[-1],255
      -rm[-2,-1] -nm[-1] visu_centroids -j[visu] [visu_centroids],5,310
    -endif
    -w[visu] -1,-1,0,"[G'MIC] RGB quantization"

    # Check for user's interactions.
    x={int(@{!,x}*@{visu,w}/@{!,w})}
    y={int(@{!,y}*@{visu,h}/@{!,h})}
    b=@{!,b}
    i=@{visu,($x,$y,0,3)}
    -if {$b&1" && "$i==1} # Toggle dithering.
      dithering={!$dithering} -rm[visu_img] -wait -1
    -elif {$b&1" && "$i==2} # Add new color.
      (@{-RGB}) -y[-1] c -a[centroids,-1] x  -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait 100
    -elif {$b&2" && "$i==2" && "@{centroids,w}>2} # Remove color.
      -r[centroids] {@{centroids,w}-1} -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait 100
    -elif {$b&2" && "$i>=3} # Toggle clusters/colors mode.
      clustering={!$clustering} -rm[visu_3d] -wait -1
    -elif @{!,M} # Init colormap with median-cut.
      --and[colors] 255 -colormap[-1] @{centroids,w},0,0 -rm[centroids] -nm[-1] centroids
      -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait -1
    -elif @{!,R} # Init colormap with random values.
      -rand[centroids] 0,255 -round[centroids] 1
      -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait -1
    -elif @{!,U} # Init colormap with uniform sampling.
      -uniform_distribution @{centroids,w},3 -*[-1] 255 -rm[centroids] -nm[-1] centroids
      -_x_quantize_rgb_3d -rm[visu_3d,visu_img,visu_centroids] -and[colors] 255 pause=1 -wait -1
    -elif @{!,ENTER} # Start k-means iterations.
      pause=0
    -elif {$b&1" && "$i>=3} # Manage 3d view rotation.
      coords={@{visu,($x,$y,0,3)}-3} u1={(($coords>>2)&511)-150} v1={($coords>>11)-150}
      -if {!narg($u0)} u0=$u1 v0=$v1 -endif
      -if {$u0!=$u1" && "$v0!=$v1}
        n0={sqrt(($u0)^2+($v0)^2)}
        nu0={if($n0>135,$u0*135/$n0,$u0)} nv0={if($n0>135,$v0*135/$n0,$v0)} nw0={sqrt(max(0,18225-($nu0)^2-($nv0)^2))}
        n1={sqrt(($u1)^2+($v1)^2)}
        nu1={if($n1>135,$u1*135/$n1,$u1)} nv1={if($n1>135,$v1*135/$n1,$v1)} nw1={sqrt(max(0,18225-($nu1)^2-($nv1)^2))}
        u={$nv0*$nw1-$nw0*$nv1} v={$nw0*$nu1-$nu0*$nw1} w={$nv0*$nu1-$nu0*$nv1} n={sqrt(($u)^2+($v)^2+($w)^2)}
        -rotation3d[] $u,$v,$w,{asin($n/18225)*180/pi} -mv[pose3d] @# -**[-2,-1] -nm[-1] pose3d
        u0=$u1 v0=$v1 -rm[visu_3d]
      -endif
    -elif {!($b&1)} u0=
    -endif

    -if {!$pause" || "@{!,SPACE}}  # Do one iteration of k-means.
      pause=@{!,SPACE}

      # Estimate new centroids positions.
      -and[colors] 255 --index[colors] [centroids] -*[-1] 256 -+[colors,-1]      # Estimate nearest centroids for all colors.
      -repeat @{colors,s}                                                        # Recompute centroid positions.
        -sh[colors] $>,$> --histogram[-1] {@{centroids,w}*256},0,{@{centroids,w}*256-1} -rm[-2]
        -i[-2] 256,1,1,1,'x' -r[-2] {w},1,1,1,0,2 -*[-2] [-1] -r[-2,-1] @{centroids,w},1,1,1,2 -max[-1] 0.01 -/[-2,-1]
      -done -a[-@{colors,s}--1] c
      -rm[centroids] -nm[-1] centroids

      # Re-assign ununsed centroids.
      -->>[colors] 8 -channels[-1] 0 -histogram[-1] @{centroids,w},0,{@{centroids,w}-1}
      cmax=@{-1,xM}
      -repeat {w} -if {!i($>)} -point[centroids] $>,0,0,1,@{-at[centroids]\ $cmax} -point[centroids] $>,0,0,-0.001,@{-RGB} -endif -done
      -rm[-1] -c[centroids] 0,255

      -if $visu_3d -rm[visu_3d] -endif
      -if $visu_img -rm[visu_img] -endif
      -if $visu_centroids -rm[visu_centroids] -endif
      -wait 20

    -else -if $visu_img -wait -endif
    -endif

  -if {!@!" || "@{!,Q}" || "@{!,ESC}} -break -endif
  -done
  -rm -w 0 -v +

 _x_quantize_rgb_3d :
  -if $obj3d -rm[obj3d] -endif
  --distribution3d[centroids] -circles3d[-1] 5 -col3d[-1] 255      # Pre-compute 3d object.
  -colorcube3d -p3d[-1] 1
  --and[colors] 255 -distribution3d[-1] -o3d[-1] 0.8 -+3d[-3--1]
  --3d[-1] 128,128,128 -nm[-1] obj3d _N={i[7]}

_x_quantize_rgb_text :
  0 -text[-1] "$1",0,0,13,1,255 -r[-1] {w+2},15,1,1,0,0,0.5,0.5 --dilate[-1] 3 -to_rgb[-2]
  -nm[-2] $2 -nm[-1] m$2

#@gmic x_reflection3d
#@gmic : Launch the 3d reflection demo.
x_reflection3d :
  -e[] "\n
------ 3d reflection --------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -

  # Render background.
  128,256,1,3 -rand[-1] 0,255 -plasma[-1] 1,100 -blur_xy[-1] 30,2
  -sh[-1] 0,0 -n[-1] 0,90 -rm[-1] -sh[-1] 1,1 -n[-1] 0,60 -rm[-1] -sh[-1] 2,2 -n[-1] 0,180 -rm[-1]
  --mirror[-1] x [-2,-1] -a[-4--1] x
  --luminance[-1] -mirror[-1] x -b[-1] 2 -n[-1] 0,255

  # Create 3d objects.
  -torus3d 30,10 -col3d[-1] 255,200,0
  -spherical3d 47,34,"80+20*abs(cos(2*theta))" -s3d[-1] -rm[-2] -i[-2] 3,{h},1,1,150,220,255,200,255,255 -y[-2] -a[-6--1] y
  -spherical3d 47,34,"100*abs(1+0.6*cos(3*phi)*sin(4*theta))"
  -r3d[-2,-1] 0,1,0,90 -db3d 0

  # Start animation loop.
  xb=0 xl=0 anim=0
  -w[] 300,300,0,"[G'MIC] 3d reflection"
  -do

    tic=@|
    # Recreate 3d interpolated background object.
    --rows[-1] 8,{8+3*i[6]-1} --j[-3] [-1],0,8,0,0,{if($anim<250,0,0.5-0.5*cos(($anim-250)/100))} -rm[-2]

    # Render 3d background object (with flat colors).
    --z[-6] $xb,0,{$xb+255},255 -object3d[-1] [-2],75%,50%,0,1,3,0,0

    # Render light reflection map.
    --z[-6] $xl,0,{$xl+255},255
    xf={min(30,$anim-70)+20*cos(1.8*@|)}
    yf={50+20*sin(2.7*@|)}
    -object3d[-1] [-6],{20+$xf}%,$yf%,0,1,4,0,0

    # Add light reflection to 3d background object.
    -l3d [-1] -rm[-1] --object3d[-1] [-2],75%,50%,0,1,5,0,0 -j[-2] [-1],0,0,0,0,0.6 -rm[-3,-1]

    # Add 3d foreground object.
    -object3d[-1] [-4],$xf%,$yf%,0,1,4,0,0

    # Display frame and update animation variables.
    -w[-1] -rm[-1]
    xb={($xb+6)&255}
    xl={($xl-6)&255}
    anim={$anim+1}
    -r3d[-2,-1] {sin(0.5*@|)},{cos(@|)},1,{(@|-$tic)*33}
    -r3d[-3] -1,0.3,0.8,{(@|-$tic)*100}
    -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm[-5--1] -w[] 0 -v +

#@gmic x_rubber3d
#@gmic : Launch the 3d rubber object demo.
x_rubber3d :
  -e[] "\n
------ 3d rubber object -----------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v - -rm
  -sphere3d 150,0 -torus3d 70,15 -cylinder3d 20,40
  -col3d[-3] 200,200,200,0.3 -col3d[-2] 128,200,76 -col3d[-1] 200,128,76
  -c3d[-3--1] -r3d[-1] 1,0,0,70 -+3d[-3--1] -+3d[-1] 10,-8,20
  256,256,64,3
  {w},{h},1,3,'if(c==0,x,if(c==1,y,y*@{1,d}/h))'
  {w},{h},1,3
  frame=0
  -do
    {w},{h},1,3 -fc[-1] 16,32,32 -object3d[-1] [0],50%,50%,0,1,3,0,0 -j[1] [-1],0,0,$frame -rm[-1]
    -r3d[0] 0.1,1,0.6,{3*cos(@|*1.25)} -r3d[0] 1,0.2,0.6,-1
    --warp[1] [2],0,0 -*[3] 0.8 -*[-1] 0.2 -+[3,-1]
    -w[-1] {1.2*w},{1.2*h},0,"[G'MIC] 3d rubber object" -wait 20
    -sh[2] 2,2 --[-1] 1 -and[-1] {@{1,d}-1} -rm[-1]
    frame={($frame-1)%@{1,d}}
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_shadebobs
#@gmic : Launch the shade bobs demo.
x_shadebobs :
  -e[] "\n
------ Shade bobs -------------------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-------------------------------------------------"
  -v - -rm t=100 -w 512,512,0,"[G'MIC] Shade bobs"

  # Start animation loop.
  -do
    t={$t+0.015}
    -if {$t>4*pi" || "@{!,b}} # Reset motions variables if necessary.
      rx={?(-1,1)} ry={?(-1,1)} rz={?(-1,1)} rt={?(-1,1)} rcx={?(-0.6*0.6)} t=0
      N={20+round(?(80))} R={(2+round(?(40)))*min(@{!,w},@{!,h})/300}
      -if $obj3d -rm[colormap,img,obj3d] -endif
      {4+round(?(12))},1,1,3 -noise[0] 255,2 -r[0] 256,1,1,3,3 -*[0] 255 -shift[0] 1 -nm[-1] colormap
      (67.5;73.5;109.5;103.5;51.5;100.5;{2*$N};$N) 3,{2*$N},1,1,0
      1,$N,1,1,5 2,$N,1,1,'y+x*$N' -a[-2--1] x -z[-1] 0,5
      4,$N,1,1,1 -y[-3--1] -a[-4--1] y -nm[-1] obj3d
      @{!,w},@{!,h} -nm[-1] img
      -wait -1
    -endif

    # Compute bobs coordinates.
    r={$ry+$rx*cos(6*$rz*$t)+(1-$rx)*sin(6*$rt*$t)}
    (0;{30*$ry*($N-1)}) ($t;{2*pi*($N-1)/$N+$t}) -r[-2,-1] 1,$N,1,1,3
    -+[-2] {360*sin($rz*$t)} -*[-2] {pi/180}
    --sin[-2,-1] -cos[-4,-3] -*[-4,-2] $r -*[-3,-1] $rcx -+[-4,-3] -+[-2,-1]
    -*[-2] {@{!,w}/2} -*[-1] {@{!,h}/2} -a[-2,-1] x
    --+[-1] $R --[-2] $R -a[-2,-1] y -z[-1] 0,2 -y[-1] -j[obj3d] [-1],0,8 -rm[-1]

    # Draw bobs, map colors and display.
    -object3d[img] [obj3d],50%,50%,0,-1,2,0,0
    -and[img] 255 --map[img] [colormap] -w[-1] -rm[-1] -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_spline
#@gmic : Launch spline curve editor.
x_spline :
  -e[] "\n
------ Spline curve editor --------------------------\n
----\n
---- Mouse to insert/move/delete points.\n
---- Key 'R' to reset the curve.\n
---- Key 'SPACE' to shows/hide spline curve.\n
---- Key 'P' to shows/hide control points.\n
---- Key 'ENTER' to shows/hide control polygon.\n
---- Key 'T' to shows/hide point tangents.\n
---- Key 'I' to shows/hide point indices.\n
---- Key 'C' to shows/hide point coordinates.\n
---- Keys '+' and '-' to increase/decrease roundness.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------------------"

  # Init display and variables.
  -v -
  -if @# -a x -n 0,255 -to_rgb -else (0;0^0;128^0;0) -r[-1] 512,512,1,3,3 -name[-1] "[G'MIC] Spline Editor" -endif
  -w[0] @{0,w},@{0,h},0,0,-1,-1,@{-1,n} -r[0] @{!,w},@{!,h},1,3,1
  -i[1] 1        # Point coordinates
  roundness=0.5  # Curve roundness
  visuflags=23   # Visualisation flags
  nearest=-1     # Nearest point
  active=-1      # Active point

  # Start event loop.
  -do

    # Init coordinates [1] if necessary.
    -if {@{1,#}==1}
      -rm[1] roundness=0.5 nearest=-1 active=-1
      -i[1] ({0.2*w},{0.2*h};\
             {0.2*w},{0.8*h};\
             {0.8*w},{0.8*h};\
             {0.8*w},{0.2*h})
    -endif

    # Estimate screen-normalized coordinates [2], curve tangents [3] and tangent orientations [4].
    [1] ({@{!,w}/@{0,w}},{@{!,h}/@{0,h}}) -*[-2,-1]                        # Normalized coordinates.
    --shift[2] 0,-1,0,0,2 --shift[2] 0,1,0,0,2 --[-2,-1] -*[-1] $roundness # Curve tangents.
    --s[-1] x -sqr[-2,-1] -+[-2,-1] -sqrt[-1] -r[-1] 2 --/[-2,-1] -rm[-2]  # Tangent orientations.

    # Display curve, control points, polygon and tangents.
    --r[0] @{!,w},@{!,h},1,3
    -if {$visuflags&4} -polygon[-1] @{2,h},@2,0.3,128,200,255 -endif
    -repeat @{1,h}
      -line[-1] @{2,0-3},0.3,255,255,0
      -if {$visuflags&1} -spline[-1] @{2,0-1},@{3,0-1},@{2,2-3},@{3,2-3},32,1,255 -endif
      -if {$visuflags&8} -line[-1] {@{2,0}-@{4,0}*20},{@{2,1}-@{4,1}*20},{@{2,0}+@{4,0}*20},{@{2,1}+@{4,1}*20},1,0,255,0 -endif
      -if {$visuflags&16} -t[-1] $>,{@{2,0}-3},{@{2,1}-18},13,1,255,255,0 -endif
      -if {$visuflags&32} -t[-1] "("{round(@{1,0})}","{round(@{1,1})}")",{@{2,0}-16},{@{2,1}+10},13,1,100,200,255 -endif
      -shift[1-4] 0,-1,0,0,2
    -done
    -if {$visuflags"&2"} -repeat @{1,h}
      -ellipse[-1] @{2,0-1},4,4,0,1,0,0,0 -ellipse[-1] @{2,0-1},2,2,0,1,255,100,155 -shift[2] 0,1,0,0,2
    -done -endif
    -w[-1] -rm[3,4,-1] -wait

    # Handle key events.
    -if @{!,SPACE} visuflags={$visuflags+if($visuflags&1,-1,1)} -wait -1 -endif  # Show/hide spline.
    -if @{!,P} visuflags={$visuflags+if($visuflags&2,-2,2)} -wait -1 -endif      # Show/hide points.
    -if @{!,ENTER} visuflags={$visuflags+if($visuflags&4,-4,4)} -wait -1 -endif  # Show/hide polygon.
    -if @{!,T} visuflags={$visuflags+if($visuflags&8,-8,8)} -wait -1 -endif      # Show/hide tangents.
    -if @{!,I} visuflags={$visuflags+if($visuflags&16,-16,16)} -wait -1 -endif   # Show/hide indices.
    -if {@{!,C}" && "!@{!,CTRLLEFT}" && "!@{!,CTRLRIGHT}} visuflags={$visuflags+if($visuflags&32,-32,32)} -wait -1 -endif # Show/hide coordinates.
    -if {@{!,PADADD}" && "$roundness<1} roundness={$roundness*1.1} -wait -1 -endif    # Increase roundness.
    -if {@{!,PADSUB}" && "$roundness>0.1} roundness={$roundness*0.9} -wait -1 -endif  # Decrease roundness.
    -if {@{!,R}" && "!@{!,CTRLLEFT}" && "!@{!,CTRLRIGHT}} -rm[-1] -i[1] 1 -wait -1 -endif # Reset curve.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,D}} -w[] {@{!,w}*1.5},{@{!,h}*1.5} -endif # Increase window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,C}} -w[] {@{!,w}/1.5},{@{!,h}/1.5} -endif # Decrease window size.
    -if {(@{!,CTRLLEFT}" || "@{!,CTRLRIGHT})" && "@{!,R}} -w[] @{0,w},@{0,h} -endif             # Reset window size.
    -if @{!,r} -w[] -endif # Resize window if necessary.

    # Set/unset active point.
    -if {@{!,b}==0} active=-1                                   # Unset active point if mouse button is released.
    -elif {@{!,x}>=0" && "@{!,b}" && "$active==-1}              # Find new active point.
      [2] (@{!,x},@{!,y}) --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1] # Compute distance vector to points.
      (@{-1,c}) nearest=@{-1,1} -rm[-1]                         # Set nearest point.
      -if {@{-1,m}<64} active=$nearest -endif                   # Set it as active point, if near enough.
      -rm[-1]
    -endif
    -rm[2]

    # Move active point.
    -if {@{!,b}&1" && "@{!,x}>=0" && "$active!=-1}
      -=[1] {@{!,x}*@{0,w}/@{!,w}},0,$active
      -=[1] {@{!,y}*@{0,h}/@{!,h}},1,$active

    # Delete nearest point.
    -elif {@{!,b}&2" && "@{!,x}>=0" && "@{1,h}>3}
      -l[1] -s y -rm[$nearest] -a y -endl -wait -1

    # Insert new active point.
    -elif {@{!,b}&1" && "@{!,x}>=0}
      xy=({@{!,x}*@{0,w}/@{!,w}},{@{!,y}*@{0,h}/@{!,h}})              # Point coordinates in the image basis.
      --shift[1] 0,-1,0,0,2 -+[-1] [1] -/[-1] 2                       # Compute center of segments.
      $xy --[-2,-1] -sqr[-1] -s[-1] x -+[-2,-1]                       # Compute distance vector to segments.
      (@{-1,c}) ns=@{-1,1} -rm[-2,-1]                                 # Get nearest segment.
      -l[1] -s y -i[{$ns+1}] $xy -a y -endl                           # Insert new point at right position.
      active={$ns+1}                                                  # Set new active point as newly inserted.
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}

  # Render spline as a tertiary mask for output.
  --shift[1] 0,-1,0,0,2 --shift[1] 0,1,0,0,2 --[-2,-1] -*[-1] $roundness
  [0],[0],1,1,2 -rm[0]
  -repeat @{1,h} -spline[-1] @{0,0-1},@{1,0-1},@{0,2-3},@{1,2-3},128,1,1 -shift[0] 0,-1,0,0,2 -shift[1] 0,-1,0,0,2 -done
  -flood[-1] 0,0,0,0,0,1,0

  # Exit properly.
  -rm[0,1] -w 0 -v +

#@gmic x_tetris
#@gmic : Launch tetris game.
x_tetris :
  -e[] "\n
------ Tetris --------------------------------------------\n
----\n
---- This is a G'MIC implementation of the Tetris game.\n
----\n
---- Arrow keys to move/rotate the triominos.\n
---- Key 'SPACE' to make the current triomino falling.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------------------"
  -v - -rm

  # Init board and triominos shapes.
  -i[m0] 4,1,1,1,1,1,1,1
  -i[m4] 3,2,1,1,1,0,0,1,1,1
  -i[m8] 3,2,1,1,0,0,1,1,1,1
  -i[m12] 2,2,1,1,1,1,1,1
  -i[m16] 3,2,1,1,0,1,1,1,1,0
  -i[m20] 3,2,1,1,0,1,0,1,1,1
  -i[m24] 3,2,1,1,1,1,0,0,1,1
  -if {?<0.25}  # Enable extended set.
    -i[m28] 2,1,1,1,1,1
    -i[m32] 2,2,1,1,1,1,0,1
    -i[m36] 3,1,1,1,1,1,1
    -i[m40] 1,1,1,1,1
    -i[m44] 3,2,1,1,1,1,1,1,0,1
    -i[m48] 3,3,1,1,1,1,1,1,0,1,1,1,1
  -endif
  -repeat @# i={4*$>} -l[m$i] -repeat 3 --rotate[0] {90*($>+1)} -nm[-1] m{$i+$>+1} -done -endl -done
  N=@#

  # Render triomino colored sprites.
  -i[colors] 3,$N,1,1,'?(16,224)' -r[-1] 3,400% -i[mask] (0,-1,0;1,0,-1;0,1,0) -*[-1] 120
  -repeat $N
    --r[m$>] 500%,500%,1,3 --correlate[-1] [mask],0 -r[-1] 200%,200%,1,1,3 -r[-2] [-1] -*[-2,-1] -c[-1] 30%,100%
    --r[m$>] [-1],[-1],1,3 --replace_color[-1] 0,0,1,1,1,@{colors,{3*$>}-{3*$>+2}} -rv[-3,-1] -+[-3,-1] -c[-2] 0,255
    -channels[-1] 0 -*[-1] 255 -a[-2,-1] c -nm[-1] s$>
  -done
  -rm[colors,mask]
  fact={@{s0,w}/@{m0,w}}

  # Generate board and background.
  W=12 H=20
  -i[board] $W,$H -i[curr_board] [board]
  -i[render] {$fact*$W},{$fact*$H},1,3 -i[curr_render] [render] --channels[-1] 0 -nm[-1] curr_render_mask
  --rows[render] 0,50% -plasma[-1] 1,2 -noise[-1] 20 -blur_y[-1] 40%,1 --mirror[-1] y -a[-2,-1] y -r[-1] [render]
  -n[-1] 0,64 -blur_x[-1] 1 100%,100% -noise[-1] 0.5,2 -b[-1] 1 -*[-1] 300 -+[-2,-1] -c[-1] 0,255 -nm[-1] background

  # Start game.
  time=@| score=0 fall_mode=0 gameover=0 n=-1 nn={round(?(0,$N-1))}
  -do
    -wait {if($fall_mode,-1,-20)}

    # In case of game over.
    -if $gameover
      --j[background] [curr_render],0,0,0,0,0.7,[curr_render_mask],255
      -text_outline[-1] "Game\nOver!",30,30%,32,2,1,255 -w[-1] -rm[-1]
      -continue
    -endif

    # Check for completed lines and select new random triomino.
    -if {$n<0}
      -l[board] -s y i=-1 -repeat @# -if @{$<,m} i=$<,$i -endif -done
      0 -rm[$i] -a y score={$score+2^(narg($i)-1)-1} -r $W,$H,1,1,0,0,0,1 -nm board -endl
      -if {narg($i)>1} -l[render] -s y,$H 0 -rm[$i] -a y -r {$fact*$W},{$fact*$H},1,3,0,0,0,1 -nm render -endl -endif
      n=$nn nn={round(?(0,$N-1))} x={$W/2} y=0 do_render=1 fall_mode=0
    -endif

    # Render board at current time.
    -if $do_render
      -rm[curr_board,curr_render,curr_render_mask]
      -i[curr_board] [board] -j[curr_board] [m$n],{$x-int(@{m$n,w}/2)},$y,0,0,1,[m$n]
      -i[curr_render] [render] -sh[s$n] 3,3 -j[curr_render] [s$n],{$fact*($x-int(@{m$n,w}/2))},{$fact*$y},0,0,1,[-1],255 -rm[-1]
      --*[curr_board] 255 -r[-1] [curr_render],[curr_render] -nm[-1] curr_render_mask
      0 -t[-1] "Score : "$score"    Next :",4,0,32,1,164 -r[-1] 40%,40%,1,3,2 --neq[-1] 0 -*[-1] 255
      -j[curr_render] [-2],0,0,0,0,1,[-1],255 -j[curr_render_mask] [-1],0,0,0,0,1,[-1],255 -rm[-2,-1]
      --*[m$nn] 196 -r[-1] 300%,300%,1,3 -j[curr_render,curr_render_mask] [-1],{@{curr_render,w}-w-4},3,0,0,1,[-1],196 -rm[-1]
      do_render=0
    -endif

    --shift[background] 0,{-13*@|*1.04^$score},0,0,2
    -j[-1] [curr_render],0,0,0,0,1,[curr_render_mask],255
    -w[-1] {2*w},{2*h},0,"[G'MIC] Tetris" -rm[-1] -cursor[0] 0

    # Manage user interactions.
    -if @{!,SPACE} fall_mode=1 -endif
    -if {@{!,ARROWUP}" || "@{!,ARROWLEFT}" || "@{!,ARROWRIGHT}}
      an={if(@{!,ARROWUP},n=$n+1;if(n%4,n,n-4),$n)}
      nx={w2=int(@{m$an,w}/2);max(w2,min($x-@{!,ARROWLEFT}+@{!,ARROWRIGHT},$W-(@{m$an,w}%2)-w2))}
      --j[board] [m$an],{$nx-int(@{m$an,w}/2)},$y,0,0,-1,[m$an]
      -if {@{-1,M}==1} x=$nx n=$an -endif
      -rm[-1]
      do_render=1
    -endif

    -if {@{!,ARROWDOWN}" || "@|-$time>0.9^int($score/2)" || "$fall_mode}   # Piece goes down.
      y={$y+1}
      --j[board] [m$n],{$x-int(@{m$n,w}/2)},$y,0,0,-1,[m$n]
      -if {@{-1,M}>1" || "$y+@{m$n,h}>$H}
        -if {$y<=1} gameover=1 -endif  # Game over!
        -j[board] [curr_board] -j[render] [curr_render] n=-1
      -endif
      -rm[-1]
      time=@| do_render=1
    -endif

  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_tictactoe
#@gmic : Launch tic-tac-toe game.
x_tictactoe :
  -e[] "\n
------ Tic-Tac-Toe game -----------------\n
----\n
---- Use mouse to select positions of the\n
---- symbols. Close window to exit game.\n
----\n
-----------------------------------------"
  -v -                            # Become quiet.

  # Allocate variables.
  message=0                       # [-7] : State message.
  counter=0                       # [-6] : Turn counter (0 to 8).
  player=0                        # [-5] : Current player (0 or 1).
  state=0                         # [-4] : Board state.
  tmp3=0                          # [-3] : Temporary variable 3.
  tmp2=0                          # [-2] : Temporary variable 2.
  tmp1=0                          # [-1] : Temporary variable 1.
  -_x_tictactoe2                  # Generate board.
  -w[-1] -1,-1,0," "              # Init display window.

  # Start main loop.
  -do

    # Set state message depending on the current player.
    -if $player message="Tic-Tac-Toe (O to play)"
    -else message="Tic-Tac-Toe (X to play)"
    -endif

    # Select position by the user.
    -do                                                                       # Enter event loop.
      -w[] {w},{h},0,"[G'MIC] "$message -wait                                 # Wait for events and force window size if necessary.
      -if {!@!} -w[] 0 -rm -v + -return -endif                                # Quit properly if window has been closed.
      -if {@{!,b}&1" && "@{!,x}>20" && "@{!,y}>20" && "@{!,x}<400" && "@{!,y}<400} # If mouse button has been pressed on the board area.
        tmp3={int((@{!,x}-15)/130)}                                                # Get x-coord of the selected position (0,1 or 2).
        tmp2={int((@{!,y}-15)/130)}                                                # Get y-coord of the selected position (0,1 or 2).
        tmp1={4^($tmp2*3+$tmp3)}                                                   # Get state code of the selected position.
        -if {int($state/$tmp1)%4} tmp1=-1 -endif                                   # Check availability of the selected position.
      -else tmp1=-1 -endif                                                    # If no mouse button, do nothing but loop.
    -while {$tmp1<0}                                                          # Go on until a valid position has been selected.

    # Draw symbol on selected position and update board state.
    -_x_tictactoe{$player%2}                                                  # Generate the symbol sprite and his mask.
    -j[-3] [-2],{"130*"$tmp3" + 15+?(-5,5)"},\                                # Draw symbol at its position (with some fuzzyness).
                {"130*"$tmp2" + 15+?(-5,5)"},0,0,1,[-1]
    -rm[-2--1]                                                                # Delete the sprite and the mask (not needed anymore).
    -w[-1]                                                                    # Update display window.
    state={$state+(1+$player)*$tmp1}                                          # Update the board state.

    # Check for a winning configuration.
    (21,1344,86016,4161,16644,66576,65793,4368;\                              # The list of winning configurations.
     0,0,0,0,1,2,0,0;\                                                        # Corresponding X coords for the stroke.
     0,1,2,0,0,0,0,0;\                                                        # Corresponding Y coords for the stroke.
     3,3,3,4,4,4,5,6)                                                         # Corresponding indice of the stroke sprite.
    -repeat {w}                                                               # Start to check configurations.
      tmp1=@{-1,$>}                                                           # Save the current configuration code (used several times).
      -if {($state&$tmp1)==$tmp1||($state&(2*$tmp1))==2*$tmp1}                # If a winner has been found.
        -_x_tictactoe@{-1,($>,3)}                                               # Generate the stroke symbol and his mask.
        -j[-4] [-2],{130*@{-3,($>,1)}+?(-5,5)},\                              # And display it on the board at its position.
                        {130*@{-3,($>,2)}+?(-5,5)},0,0,1,[-1] -rm[-2--1]
        -if {($state&$tmp1)==$tmp1} -w[-2] -1,-1,0,"Tic-Tac-Toe (X won!)"
        -else -w[-2] -1,-1,0,"Tic-Tac-Toe (O won!)"                           # Update display window.
        -endif
        -do -wait -w[] @{!,w},@{!,h} -while @!                                  # Wait for the window to be closed.
        -rm -w[] 0 -v + -return                                                 # And return properly.
      -endif
    -done                                                                     # Go on until all configurations have been checked.
    -rm[-1]                                                                   # Delete winning configuration data.

    player={($player+1)%2}                                                  # Select next player.
    counter={$counter+1}                                                    # Increment turn counter.
  -while {$counter<9}                                                       # Loop to next move until all positions have been filled.

  # Here, the game has been ended without winners.
  -w[] -1,-1,0,0,"Tic-Tac-Toe (Tied game!)"                                # Change window title.
  -do -wait -w[] @{!,w},@{!,h} -while @!                                    # Wait for the window to be closed.
  -w[] 0 -rm -v +                                                           # Return properly.

# Generate Tic-Tac-Toe graphics.
_x_tictactoe : # Apply a hand-drawing effect.
  -spread[-1] 4 -b[-1] 6 -sharpen[-1] 0.8 -n[-1] 0,1

__x_tictactoe : # Apply color to last image and generate corresponding opacity mask.
  --f[-1] 1-i --n[-2] $2,255 --n[-3] $3,255 -n[-4] $1,255 -a[-4,-2,-1] c

_x_tictactoe0 : # Generate a 'X' and his mask.
  128,128,1,1,1 -line[-1] 15%,15%,85%,85%,1,0 -line[-1] 15%,85%,85%,15%,1,0 -erode[-1] 12 -_x_tictactoe -deform[-1] 4 -__x_tictactoe 40,40,160

_x_tictactoe1 : # Generate a 'O' and his mask.
  128,128,1,1,1 -ellipse[-1] 50%,50%,22%,22%,0,1,0 -ellipse[-1] 50%,50%,15%,15%,0,1,1 -_x_tictactoe -deform[-1] 4 -__x_tictactoe 160,40,160

_x_tictactoe2 : # Generate the board.
  391,391,1,1,"!(x%130) || !(y%130)" -r[-1] 421,421,1,1,0,0,0.5,0.5 -dilate[-1] 3 -_x_tictactoe -f[-1] 1-i
  100%,100% -noise[-1] 10 -b[-1] 8,0 -sharpen[-1] 1.5 -n[-1] 220,255 -*[-2,-1] -to_rgb[-1]

_x_tictactoe3 : # Generate an horizontal stroke and his mask.
  421,130,1,1,1 -line[-1] 10%,60%,90%,60%,1,0 -erode[-1] 6 -_x_tictactoe -rotate[-1] {?(-6,6)},1,1,50%,50% -__x_tictactoe 180,10,10

_x_tictactoe4 : # Generate a vertical stroke and his mask.
  -_x_tictactoe3 -transpose[-2--1]

_x_tictactoe5 : # Generate a ++ diagonal stroke and his mask.
  421,421,1,1,1 -line[-1] 10%,10%,90%,90%,1,0 -erode[-1] 6 -_x_tictactoe -__x_tictactoe 180,10,10

_x_tictactoe6 : # Generate a +- diagonal stroke and his mask.
  421,421,1,1,1 -line[-1] 10%,90%,90%,10%,1,0 -erode[-1] 6 -_x_tictactoe -__x_tictactoe 180,10,10

#@gmic x_waves
#@gmic : Launch the image waves demo.
x_waves :
  -e[] "\n
------ Image waves ----------------------\n
----\n
---- Left mouse button to drop balls.\n
---- Right mouse button to rotate view.\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
-----------------------------------------"
  -v -
  -if {!@#} -l[] # Generate fractal image
    200,200 x={-1.06-?*0.1} y={-0.26-?*0.1}
    -mandelbrot $x,$y,{$x+0.1},{$y+0.1},256
    16,1,1,3,? -r[-1] 256,1,1,3,3 -shift[-1] 1
    -map[0] [-1] -rm[-1] -r2dx 100
    --mirror y --mirror x -+ -n 0,255
  -endl -else -k[0] -r[0] 100,100,1,3,2 -endif
  -i[0] (20;80;0^20;80;0^20;80;0) -r[0] 400,300,1,3,3 -water[0] 100,2
  -w[0] @{0,w*1.25},@{0,h*1.25},0,"[G'MIC] Image waves"
  w={w} -elevation3d[-1] 0 -rv3d[-1]
  -sh[-1] 8,{7+3*i[6]},0,0 -r[-1] 3,{h/3},1,1,-1
  (0,1,0;1,0,1;0,1,0) -/[-1] 2
  -ball[] 20,200,255,128,1,0.7,3.5
  0 $w,$w [-1]
  -l3d {$w/2},-200,-1000 -sl3d 0.4 -ss3d 0.8 -f3d 500 time0=@|
  -do
    --convolve[-1] [3],1 --[-1] [-3] -rm[-3] -b[-1] 0.8 --[-1] {ia} # Update height map.
    -r[-1] 1,{$w*$w},1,1,-1 -j[2] [-1],2,0 -r[-1] $w,$w,1,1,-1      # Set 3d object coordinates.
    [1]
    -if @{5,h} --l[5] -rows 0,2
      nb={w}
      -i[0] ({'CImg3d'}) -i[1] ($nb,$nb) -transpose[2]
      (1,0;1,{$nb-1}) -r[-1] 2,$nb,1,1,3 -round[-1]
      1,{4*$nb},1,1,1 -y -a y
    -endl [4] -sprites3d[-2,-1] -+3d[-2,-1] -endif
    --3d[-1] {$w/2},{$w/2} -*3d[-1] @{0,0.9*max(w,h)/$w} # Center and scale 3d object.
    -r3d[-1] 0,0,1,{if(@{!,b}&2,-@{!,x}*360/@{!,w},@|*30)} -r3d[-1] 1,0,0,-120 # Get rotated 3d object.
    --object3d[0] [-1],50%,65%,30,1,3,0,0 -w[-1] -rm[-2,-1] -wait 20
    -if {@{!,b}&1||(@|-$time0)>1} ({?*$w};{?*$w};70;0) -a[5,-1] x time0={@|-?} -endif # Insert new ball.
    -if @{5,h} -l[5,-1] # Manage ball motion and collision.
      -sh[0] 2,2,0,0 -sh[0] 3,3,0,0 --[-2] [-1] -+[-1] 0.2 -rm[-2,-1]
      -s[0] x -repeat {@#-1} coords=@{$<,0-1} -if {@{$<,2}<i($coords)} -=[-1] {80+@{-1,($coords)}},$coords -rm[$<] -endif -done
      -if {@#==1} -i[0] 0 -else -a[0--2] x -endif
      -endl
    -endif
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm -w 0 -v +

#@gmic x_whirl : _opacity>=0
#@gmic : Launch the fractal whirls demo.
#@gmic : Default values: 'opacity=0.2'.
x_whirl : -check ${1=0.2}>=0
  -e[] "\n
------ Fractal whirls ----------------------------\n
----\n
---- Keys 'ESC' or 'Q' to exit.\n
----\n
--------------------------------------------------"
  -v -
  5,5,1,3 256,256,1,3 [-1] -w[-1] 480,480,0,"[G'MIC] Fractal whirls"
  tangle=0 tzoom=0 xc={(w-@{-3,w})/2} yc={(h-@{-3,h})/2}
  -do
    -rand[-3] 0,255 -j[-2] [-3],$xc,$yc,0,0
    -rotate[-2] {8*sin($tangle)},0,0,{w/2+?(-2,2)},{h/2},{1.03+0.02*sin($tzoom)}
    tangle={$tangle+0.001} tzoom={$tzoom+0.02}
    -j[-1] [-2],0,0,0,0,$1 -w[-1] -wait 20
  -while {@!" && "!@{!,ESC}" && "!@{!,Q}}
  -rm[-3,-2] -w[] 0 -v +

#------------------------------------
#
#@gmic :: PINK-library operators
#
#------------------------------------

_wrbytepnk :
  -output_pink3d ${1}.pnk

_xpink :
  filename=@{-file_rand}
  prefix=pink.
  -if {!@{-is_windows}}
    -x "which "${prefix}${1}" >/dev/null 2>&1"
    -if {@{}!=0} prefix="" -x "which "$1" >/dev/null 2>&1"
	  -if {@{}!=0} -error "executable (pink.)"$1" not found in PATH, status = "@{}"!! Returning!!\n" -return -endif
	-endif
    -output_pink3d ${filename}.pnk -x ${prefix}${1}" "${filename}".pnk $2 "${filename}"_o.pnk >/dev/null 2>&1"
  -else
    -output_pink3d ${filename}.pnk -x $1" "${filename}".pnk $2 "${filename}"_o.pnk"
  -endif
  status=@{}
  -file_rm ${filename}.pnk
  -if {$status!=0\ &&\ {$1'!='seuilauto} -error "exec Status is "${status}"." -return
  -elif ${filename}_o.pnk -i ${filename}_o.pnk -file_rm ${filename}_o.pnk -k[-1]
  -else -error "exec Error!!" -endif

_xpinks :
  s=@{-1,s} -if {$s>1} -s[-1] c -endif
  -repeat @# -l[@{>,-1}]  -_xpink $1,"$2" -k[-1] -endl -done
  -if {$s>1} -a[-$s--1] c -endif

_xframe :
  -line 0%,0%,100%,0% -line 0%,100%,100%,100% -line 0%,0%,0%,100% -line 100%,0%,100%,100%

#@gmic output_pink3d : filename
#@gmic : Save selected images as P5-coded PPM files (PINK extension for 3d volumetric images).
output_pink3d :
  -e[^-1] "Output image$? as file '$1' (in 3d pink extension of P5-coded PPM format)."
  -v - -if {@#==1} filename0="$1"
  -else -repeat @# filename$>=@{-filename\ "\"$1\"",$>} -done
  -endif
  -repeat @# -l[$>]
    -if {d==1} -o[-1] ppm:${filename$>}  # 2d image, save as regular PPM format.
    -else                                # 3d image, save as PINK PPM extension.
      ({'P5\n{w}\ {h}\ {d}\n255\n'})
      --channels[-2] 0 -y[-1] x -a[-2,-1] x
      -o[-1] raw:${filename$>},uchar
      -rm[-1]
    -endif
  -endl -done -v +

#@gmic pink
#@gmic : Pink wrapper name,p1, .. ,pn (requires the PINK library to be installed).
#@gmic : (http://pinkhq.com/)
#@gmic : prepares input, calls external "name input p1 ... pn output" and reads output (/tmp)
#@gmic : $ image.jpg --pink asfr,5 -pink[0] asf,5
#@gmic : $ image.jpg --blur 2 -pink maxima,4
pink : -v -
  -if {$#>1} ({"'${2--1}'"}) -replace[-1] {','},{"' '"} p=@{-1,t} -rm[-1] -else p=" " -endif
  -v + -e[^-1] "Call pink package with cmd: \"$1$? "$p"$?\"." -v -
  -repeat @# -l[@{>,-1}] -_xpinks $1,$p -endl -done -v +

#@gmic pink_grayskel : _connectivity={ 4 | 8 | 6 | 26 }, _lambda=0
#@gmic : (http://pinkhq.com/grayskel_8c.html)
#@gmic : Grayscale homotopic skeleton (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'lambda=0'.
#@gmic : $ image.jpg --pink_grayskel , --pink_grayskel[0] ,10 --pink_grayskel[0] ,100 -append_tiles 2
pink_grayskel : -skip ${1=4},${2=0}
  -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  -repeat @# -l[@{>,-1}] -_xpinks "grayskel","null $1 $2" -endl -done

#@gmic pink_heightmaxima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@gmic : (http://pinkhq.com/heightmaxima_8c.html)
#@gmic : Heightmaxima filtering (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'height=1'.
#@gmic : $ image.jpg --blur 2 --pink_heightminima ,15 --pink_heightmaxima[0,1] ,15 --[-3,-1] --[-3,-1] -keep[-1,-2]
pink_heightmaxima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=1}
  -e[^-1] "Filter by heightmaxima exec with connectivity $1 height $2."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -repeat @# -l[@{>,-1}] -_xpink "heightmaxima","$1 $2" -k[-1] -endl -done
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#@gmic pink_heightminima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@gmic : (http://pinkhq.com/heightminima_8c.html)
#@gmic : Heightminima filtering (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'height=1'.
#@gmic : $ image.jpg --blur 2 --pink_heightminima ,15 --pink_heightmaxima[0,1] ,15 --[-3,-1] --[-3,-1] -keep[-1,-2]
pink_heightminima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=1}
  -e[^-1] "Apply filter by heightminima exec with connectivity $1 height $2."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -repeat @# -l[@{>,-1}] -_xpink "heightminima","$1 $2" -k[-1] -endl -done
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#@gmic pink_htkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@gmic : (http://pinkhq.com/htkern_8c.html)
#@gmic : (http://pinkhq.com/htkernu_8c.html)
#@gmic : Grayscale ultimate homotopic thinning/thickening without condition (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'type=""'.
#@gmic : $ image.jpg --pink_htkern ,u --pink_htkern[0] , ---[-1,-2] -remove[0]
pink_htkern : -skip ${1=4},${2=""}
  -repeat @# -l[@{>,-1}] -_xpinks htkern$2,"null $1" -endl -done

#@gmic pink_lvkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@gmic : (http://pinkhq.com/lvkern_8c.html)
#@gmic : (http://pinkhq.com/lvkernu_8c.html)
#@gmic : Grayscale ultimate leveling thinning/thickening without condition (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'type=""'.
#@gmic : $ image.jpg -pink_lvkern ,u
pink_lvkern : -skip ${1=4},${2=""}
  -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  -repeat @# -l[@{>,-1}] -_xpinks lvkern${2},"null $1" -endl -done

#@gmic pink_reg_minima : _connectivity={ 4 | 8 | 6 | 26 }
#@gmic : (http://pinkhq.com/minima_8c.html)
#@gmic : Regional minima (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4'.
#@gmic : $ image.jpg --blur 2 -pink_reg_minima ,
pink_reg_minima : -check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  -e[^-1] "Compute regional minima exec with connectivity $1."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -repeat @# -l[@{>,-1}]  -_xpink "minima","$1" -k[-1] -endl -done
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#@gmic pink_skelcurv : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@gmic : (http://pinkhq.com/skelcurv_8c.html)
#@gmic : Curvilinear binary skeleton guided by a priority function or image (requires the PINK library to be installed).
#@gmic : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% {w},{h} -fill[-1] 'if(x>w/2,255,0)' tp=@{-path_tmp} -output[-1] ${tp}/inhibit.pgm -remove[-1] --pink_skelcurv[0] , --pink_skelcurv[0] ,,${tp}/inhibit.pgm -exec "rm "${tp}"/inhibit.pgm"
#@gmic : $ image.jpg -threshold 50% --pink_skelcurv , --pink_skelcurv[-2] ,8
pink_skelcurv : -skip ${1=0},${2=4},${3=""}
  -e[^-1] "Curvilinear binary skeleton guided by a priority function or image from image$?, prio=$1, connectivity=$2, inhibit=$3."
  -repeat @# -l[@{>,-1}] -_xpinks "skelcurv","$1 $2 $3" -endl -done

#@gmic pink_skelend : _connectivity={ 4 | 8 | 6 | 26 },_n=0
#@gmic : (http://pinkhq.com/skelend_8c.html)
#@gmic : Homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4' and 'n=0'.
#@gmic : $ image.jpg -threshold 50% --pink_skelend , --pink_skelend[-2] ,-1
pink_skelend : -skip ${1=4},${2=0}
  -repeat @# -l[@{>,-1}] -_xpinks "skelend","$1 $2" -endl -done

#@gmic pink_skeleton : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@gmic : (http://pinkhq.com/skeleton_8c.html)
#@gmic : Ultimate binary skeleton guided by a priority image (requires the PINK library to be installed).
#@gmic : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% --pink_skeleton[-1] ,
 pink_skeleton : -skip ${1=0},${2=4},${3=""}
  -repeat @# -l[@{>,-1}] -_xpinks "skeleton","$1 $2 $3" -endl -done

#@gmic pink_skelpar : _algorithm={0..29},_nsteps=_1,_inhibit=""
#@gmic : (http://pinkhq.com/skelpar_8c.html)
#@gmic : Parallel binary skeleton (requires the PINK library to be installed).
#@gmic : Default values: 'algorithm=4', 'nsteps=-1' and 'inhibit=""'.
#@gmic : $ image.jpg -threshold 50% --pink_skelpar[-1] 0 --pink_skelpar[-1] 2
pink_skelpar : -skip ${1=4},${2=-1},${3=""}
  -repeat @# -l[@{>,-1}] -_xframe -_xpinks "skelpar","$1 $2 $3" -endl -done

#@gmic pink_wshed : _connectivity={ 4 | 8 | 6 | 26 },_inverse={ 0 | 1 },_height=0
#@gmic : (http://pinkhq.com/wshedtopo_8c.html)
#@gmic : Watershed (requires the PINK library to be installed).
#@gmic : Default values: 'connectivity=4', 'inverse=0' and 'height=0'.
#@gmic : $ image.jpg --pink_wshed ,1,5 -pink_wshed[0] ,,5
pink_wshed : -check "${1=4}==4 || $1==8 || $1==6 || $1==26" -skip ${2=0},${3=0}
  -e[^-1] "Compute wshedtopo exec with connectivity $1 inversion $2 height $3."
  -v - -repeat @# -l[@{>,-1}]
    s=@{-1,s} -if {$s>1} -s[-1] c -endif
    -if {d==1}
      -check "${1=4}==4 || $1==8"
      -repeat @# -l[@{>,-1}]
        -if {$2!=0} -negative -endif
        -f max(min(i,255),0)
        -if {$3>=0} -pink heightminima,$1,$3 -endif
        -pink wshedtopo,$1
        -if {$2!=0} -negative -endif
      -endl -done
    -else
      -check "$1==6 || $1==26"
      -repeat @# -l[@{>,-1}]
        -if {$2!=0} -negative -endif
        -f max(min(i,255),0)
        -if {$3>=0}
          -pink heightminima,$1,$3
        -endif
        -pink wshedtopo,$1
        -if {$2!=0} -negative -endif
      -endl -done
    -endif
    -if {$s>1} -a[-$s--1] c -endif
  -endl -done -v +

#------------------------------
#
#@gmic :: Convenience functions
#
#------------------------------

#@gmic alert : _title,_message,_label_button1,_label_button2,...
#@gmic : Display an alert box and wait for user's choice.
#@gmic : If a single image is in the selection, it is used as an icon for the alert box.
#@gmic : Default values: 'title=[G'MIC Alert]' and 'message=This is an alert box.'.
alert : -skip "${1=[G'MIC Alert]},${2=This is an alert box.},${3=OK}"
  -if {@#==1}
    -e[0--3] "Display alert box, with image$?, title '$1', message '$2' and buttons '${3--1}'."
  -else
    -e[0--3] "Display alert box, with title '$1', message '$2' and buttons '${3--1}'."
  -endif
  -v -

  -if {@#==1} logo= -else logo=[] -endif
  --l$logo

    # Manage alert icon.
    -if {@#==1} -to_rgb
    -else # No logo provided, generate default logo (alert).
      64,64 -polygon 3,50%,10%,10%,90%,90%,90%,1,1 -b 3 -ge 50%
      --erode[-1] 5 --[-1] [-2] -==[-1] 0
      -polygon[-1] 4,47%,43%,53%,43%,53%,66%,47%,66%,1,0 -circle[-1] 50%,76%,2,1,0
      --*[0] 255 [-1] 100%,100% -a[-3--1] c --[-1] '3*(y-h/2)'
      -*[-1] [-2] -rm[-2] -*[0] 255 -rv -a c
      -drop_shadow 3,3,1 -i[0] 100%,100%,1,3,200 -blend alpha
    -endif
    -channels -1,2

    # Create buttons graphics.
    $=arg
    -repeat {$#-2} label=${arg{$>+3}} 0 -text[-1] $label,0,0,14,1,-200 -done
    -r[^0] {min(128,max(64,@{-max_w[^0]}+12))},{min(48,max(24,@{-max_h[^0]}+12))},1,1,0,0,0.5,0.5
    -+[^0] 200 -to_rgb[^0]
    -mv[0] @#
    [0],[0],1,1,'(y-h/2)' -*[-1] -2 -c[-1] -30,30 -+[0--3] [-1] -rm[-1] -c[^-1] 0,255  # Add shading to buttons.

    -repeat {@#-1} -l[$<]

      # Create selected buttons.
      --rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
      -rectangle[-1] 1,1,{w-2},{h-2},1,0xFFFFFFFF,0
      -line[-1] 2,{h-3},{w-3},{h-3},1,150 -line[-1] {w-3},{h-3},{w-3},2,1,150
      -line[-1] 1,1,{w-3},1,1,255 -line[-1] 1,1,1,{h-3},1,255
      -rectangle[-1] 4,4,{w-5},{h-5},1,0xAAAAAAAA,0

      # Create clicked buttons.
      --shift[-2] 1,1,0,0,2
      -rectangle[-1] 0,0,100%,100%,1,0xFFFFFFFF,0
      -rectangle[-1] 1,1,{w-2},{h-2},1,0xFFFFFFFF,150
      -rectangle[-1] 4,4,{w-5},{h-5},1,0xAAAAAAAA,0

      # Create default aspect.
      -rectangle[-3] 0,0,100%,100%,1,0xFFFFFFFF,0
      -line[-3] 1,{h-2},{w-2},{h-2},1,150 -line[-3] {w-2},{h-2},{w-2},1,1,150
      -line[-3] 0,0,{w-2},0,1,255 -line[-3] 0,0,0,{h-2},1,255

      # Create coordinates image.
      -i[0] 100%,100% -=[0] 1,0,0

    -a c -endl -done

    # Render alert box graphics.
    --l
      -channels 0,3 -sh 1,100% --[50%--1] 200 -rm[50%--1] -frame 8,8,0
      -if {@#<6} -a[^-1] x -else -append_tiles[^-1] , -endif
      0 -text[-1] "$2",0,0,14,1,0,-200,-200,-200 -r[-1] {w+16},{h+8},1,4,0
      -a[-2,-1] x,0.5 -rv -a y,0.5
      -sh 1,100% -+[-1] 200 -rm[-1]
      -rectangle 0,0,100%,100%,1,0xFFFFFFFF,0
      -line 0,0,{w-2},0,1,0,255,255,255 -line 0,0,0,{h-2},1,0,255,255,255
    -endl
    -rm[-2]
    --channels[-1] 0

    # Retrieve (x,y) coordinates of the buttons and fill active area.
    (0,{w-1}) (0;@{-2,h-1}) -r[-2,-1] [-3],3 -a[-2,-1] c -round[-1] -rv[-2,-1] -*[-2,-1]
    -discard[-1] 0 -r[-1] {h/2},2,1,1,-1
    -channels[-2] 1,3 -rv[-2,-1]
    100%,100% -repeat @{-3,w} x0=@{-3,($>,0)} y0=@{-3,($>,1)} -rectangle[-1] $x0,$y0,{$x0+@{0,w}-1},{$y0+@{0,h}-1},1,{1+$>} -done
    -a[-2,-1] c

    # Enter event loop.
    -repeat 9 -if {!@{!$>}} disp=$> -break -endif -done   # Find available display window.
    -if {!narg($disp)} -error[0--4] "Cannot open display window for alert box." -endif

    selected={if($#==3,0,-1)} clicked=-1
    -do

      # Render current view.
      --channels[-1] 0,2
      -if {$clicked>=0}
        x0=@{-3,($clicked,0)} y0=@{-3,($clicked,1)}
        -sh[$clicked] 7,9
        -j[-2] [-1],$x0,$y0 -rm[-1]
      -elif {$selected>=0}
        x0=@{-3,($selected,0)} y0=@{-3,($selected,1)}
        -sh[$selected] 4,6
        -j[-2] [-1],$x0,$y0 -rm[-1]
      -endif
      -w$disp[-1] 100%,100%,0,"$1" -rm[-1] -wait

      # Handle user interactions.
      xm=@{!$disp,x} ym=@{!$disp,y} bm={@{!$disp,b}&1} val={i($xm,$ym,0,3)}
      -if {$bm" && "$val} clicked={$val-1}
      -elif {$bm" && "!$val" && "$clicked>=0} selected=$clicked clicked=-1
      -elif {!$bm" && "$clicked>=0" && "$clicked==$val-1} -break
      -endif
      -if @{!$disp,ARROWRIGHT} selected={($selected+1)%@{-2,w}} -wait -1
      -elif @{!$disp,ARROWLEFT} selected={($selected-1)%@{-2,w}+($selected==-1)} -wait -1
      -elif {$selected>=0" && "@{!$disp,ENTER}} clicked=$selected -break
      -endif

    -while {@{!$disp}" && "!@{!$disp,ESC}}

    # Return result (indice of clicked button or '-1').
    -w$disp 0 -rm -u $clicked
  -endl
  -v +

#@gmic arg : n,_arg1,...,_argN
#@gmic : Return the n-th argument of the specified argument list.
arg :
  -v - $=arg -u ${arg{1+($1)}} -v +

#@gmic at : _x,_y,_z
#@gmic : Return a specified vector-valued point (x,y,z) from the latest of the selected images.
at : -skip ${1=0},${2=0},${3=0}
  -v - --z[-1] ${1-3},${1-3} -u @-1 -rm[-1] -v +

#@gmic autocrop_coords : value1,value2,... | auto
#@gmic : Return coordinates (x0,y0,z0,x1,y1,z1) of the autocrop that could be performed on the latest of the selected images.
#@gmic : Default value: 'auto'
autocrop_coords : -skip ${1=auto}
  -v -
  is_auto={$1'=='auto}
  w={w} h={h} d={d}
  value={i(w-1,h-1,d-1)} --=[-1] {1+$value},100%,100%,100% -_autocrop$is_auto[-1] ${1--1} -=[-1] $value,100%,100%,100%
  x0={$w-w} y0={$h-h} z0={$d-d} -rm[-1]
  --_autocrop$is_auto[-1] ${1--1}
  x1={$x0+w-1} y1={$y0+h-1} z1={$z0+d-1} -rm[-1]
  -u $x0,$y0,$z0,$x1,$y1,$z1
  -v +

_autocrop0 : -autocrop $*
_autocrop1 : -skip $* -autocrop

#@gmic average_color
#@gmic : Return the average color of the latest of the selected images.
average_color :
  -v -
  res=""
  -repeat {s-1} -sh[-1] {1+$>},{1+$>} res=$res,{ia} -rm[-1] -done
  -sh[-1] 0,0 -u {ia}$res -rm[-1]
  -v +

#@gmic basename : file_path,_variable_name_for_folder
#@gmic : Return the basename of a file path, and opt. its folder location.
#@gmic : When specified 'variable_name_for_folder' must starts by an underscore
#@gmic : (global variable accessible from calling function).
basename : -skip ${2=unused}
  -v -
  -l[] ({"'$1'"}) -replace 92,47 -s +,47
  -if {i==47} -a y $2=@{-1,t} -u ""
  -elif {@#==1} -u @{-1,t} $2=""
  -else -a[^-1] y -u @{-1,t} $2=@{-2,t}
  -endif
  -rm -endl
  -v +

#@gmic bin : binary_int1,...
#@gmic : Print specified binary integers into their octal, decimal, hexadecimal and string representations.
bin :
  -v - dec=@{-bin2dec\ ${^0}} -v +
  -e[^-1] "Convert binary integer"@{-arg\ 1+($#>1),"",s}" '${^0}' to octal '"@{-dec2oct\ $dec}"',
           decimal '"$dec"', hexadecimal '"@{-dec2hex\ $dec}"' and string '"@{-dec2str\ $dec}"'."

#@gmic bin2dec : binary_int1,...
#@gmic : Convert specified binary integers into their decimal representations.
bin2dec :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_bin2dec :
  ({'@{-struncase\ $1}'})
  is_negative=0
  -if {@{-1,0}==45} -z[-1] 1,100% is_negative=1 -endif
  -f[-1] "if(i>=48 && i<=49,(i-48)*2^(w-1-x),nan)"
  -u {if($is_negative,-1,1)*@{-1,+}}
  -rm[-1]

# compress_gmic
# Compress .gmic custom command files for the 'gmic' command line tool,
# by removing empty lines, and useless comments (non starting with '#@gmic').
compress_gmic :
  -e[] "" -v -
  head_std={'"#@gmic"'}
  -s -,10 N=@#
  -repeat @#
    -if {!($>%100)} -v + -e[] "\r  Process : "{round($>/$N*100)}% -v - -endif
    -if {i=={'#'}}
      head=@{-1,0-{min(5,h-1)}}
      -if {{$head'!='$head_std}" || "(i[6]!={'" "'}" && "i[6]!={':'})} -rm[-1] -continue
      -endif
    -else
      -l[-1] -split +,32,35 -if {@#>2} -k[0] -endif -a y -endl
      -autocrop[-1] 32 -if {!w} -rm[-1] -continue -endif
    -endif
  -mv[-1] 0 -done
  -i[1--2] (10) -a y
  -v + -e[] "\r Process : 100%"

# compress_gmic_gimp
# Compress .gmic custom command files for the GIMP plug-in,
# by removing empty lines, and useless comments (non starting with '#@gimp').
compress_gmic_gimp :
  -e[] "" -v -
  head_std={'"#@gimp"'}
  -s -,10 N=@#
  -repeat @#
    -if {!($>%100)} -v + -e[] "\r  Process : "{round($>/$N*100)}% -v - -endif
    -if {i=={'#'}}
      head=@{-1,0-{min(5,h-1)}}
      -if {$head'!='$head_std} -rm[-1] -continue
      -endif
    -else
      -l[-1] -split +,32,35 -if {@#>2} -k[0] -endif -a y -endl
      -autocrop[-1] 32 -if {!w} -rm[-1] -continue -endif
    -endif
  -mv[-1] 0 -done
  -i[1--2] (10) -a y
  -v + -e[] "\r Process : 100%"

#@gmic dec : decimal_int1,...
#@gmic : Print specified decimal integers into their binary, octal, hexadecimal and string representations.
dec :
  -e[^-1] "Convert decimal integer"@{-arg\ 1+($#>1),"",s}" '${^0}' to binary '"@{-dec2bin\ ${^0}}"',
           octal '"@{-dec2oct\ ${^0}}"', hexadecimal '"@{-dec2hex\ ${^0}}"' and string '"@{-dec2str\ ${^0}}"'."

#@gmic dec2str : decimal_int1,...
#@gmic : Convert specifial decimal integers into its string representation.
dec2str :
  -v - -u {`${^0}`} -v +

#@gmic dec2bin : decimal_int1,...
#@gmic : Convert specified decimal integers into their binary representations.
dec2bin :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_dec2bin : -check isint($1)
  res="" r={abs($1)}
  -do res={$r%2}$res r={int($r/2)} -while $r
  -u @{-arg\ 1+($1>=0),-,""}$res

#@gmic dec2hex : decimal_int1,...
#@gmic : Convert specified decimal integers into their hexadecimal representations.
dec2hex :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_dec2hex : -check isint($1)
  res="" r={abs($1)}
  -do res=@{-_dec2hex_{$r%16}}$res r={int($r/16)} -while $r
  -u @{-arg\ 1+($1>=0),-,""}$res

_dec2hex_0 : -u 0
_dec2hex_1 : -u 1
_dec2hex_2 : -u 2
_dec2hex_3 : -u 3
_dec2hex_4 : -u 4
_dec2hex_5 : -u 5
_dec2hex_6 : -u 6
_dec2hex_7 : -u 7
_dec2hex_8 : -u 8
_dec2hex_9 : -u 9
_dec2hex_10 : -u a
_dec2hex_11 : -u b
_dec2hex_12 : -u c
_dec2hex_13 : -u d
_dec2hex_14 : -u e
_dec2hex_15 : -u f

#@gmic dec2oct : decimal_int1,...
#@gmic : Convert specified decimal integers into their octal representations.
dec2oct :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_dec2oct : -check isint($1)
  res="" r={abs($1)}
  -do res={$r%8}$res r={int($r/8)} -while $r
  -u @{-arg\ 1+($1>=0),-,""}$res

#@gmic fact : value
#@gmic : Return the factorial of the specified value.
fact : -check isint($1)
  -v - res=1 -repeat $1 res={$res*($>+1)} -done -u $res -v +

#@gmic file_mv : filename_src,filename_dest
#@gmic : Rename or move a file from a location $1 to another location $2.
file_mv :
  -e[^-1] "Move file '$1' to location '$2'."
  -v - -if @{-is_windows} -x "move "$1" "$2 -else -x "mv "$1" "$2 -endif -v +

#@gmic file_rand
#@gmic : Return a random filename for storing temporary data.
file_rand :
  -v -
  -do filename=@{-path_tmp}@{-file_slash}gmic@%{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}{round(?(0,9))}
  -while $filename
  -u $filename
  -v +

#@gmic file_rm : filename
#@gmic : Delete a file.
file_rm :
  -e[^-1] "Remove file '$1'."
  -v -
  -if @{-is_windows}
    1 -nm[-1] "$1" dir=@{-1,f} base=@{-1,b} ext=@{-1,x} -rm[-1] com=""
    -if {narg($dir)} com="cd \""$dir"\\\" && " -endif
    -if {narg($ext)} com=${com}"del \""$base.$ext"\"" -else com=${com}"del \""$base"\"" -endif
    -x $com
  -else
    -x "rm -f \"$1\""
  -endif
  -v +

#@gmic file_slash
#@gmic : Return '/' or '\' as a path separator for filenames.
file_slash :
  -v - -if @{-is_windows} -u "\\" -else -u "/" -endif -v +

#@gmic filename : filename,_number1,_number2,...,_numberN
#@gmic : Return a filename numbered with specified indices.
filename : -skip "${1=default}"
  -v -
  -if {$#==1} -u "$1"
  -else
  (${2--1}) -name[-1] "$1" -u @{-1,f}@{-1,b}
  -repeat {w}
    -u @{}_{int(i/100000)%10}{int(i/10000)%10}{int(i/1000)%10}{int(i/100)%10}{int(i/10)%10}{i%10}
    -shift[-1] -1
  -done
  -if {narg({'@{-1,x}'})} -u @{}.@{-1,x} -endif
  -rm[-1]
  -endif
  -v +

#@gmic fitratio_wh : min_width,min_height,ratio_wh
#@gmic : Return a 2d size 'width,height' which is bigger than 'min_width,min_height' and has the specified w/h ratio.
fitratio_wh :
  -v - -if {$3*$2>$1} -u {int($3*$2)},$2 -else -u $1,{int($1/$3)} -endif -v +

#@gmic fitscreen : width,height,_depth
#@gmic : Return the 'ideal' size WxH for a window intended to display an image of specified size on screen.
fitscreen : -check "$1>0 && $2>0 && ${3=1}>0"
  -v -
  w={if($3>1,$1+$3,$1)}
  h={if($3>1,$2+$3,$2)}
  Mw={int(0.85*@{!,u})}
  Mh={int(0.85*@{!,v})}
  -if {$w<128} h={int($h*128/$w)} w=128 -endif
  -if {$h<128} w={int($w*128/$h)} h=128 -endif
  -if {$w>$Mw} h={max(1,int($h*$Mw/$w))} w=$Mw -endif
  -if {$h>$Mh} w={max(1,int($w*$Mh/$h))} h=$Mw -endif
  w={max($w,128)}
  h={max($h,128)}
  -u $w,$h
  -v +

#@gmic gcd : a,b
#@gmic : Return the GCD (greatest common divisor) between a and b.
gcd : -check "isint($1) && isint($2) && $1*$2!=0"
  -v - -_gcd {max(abs($1),abs($2))},{min(abs($1),abs($2))} -v +

_gcd :
  r={$1%$2} -if $r -u @{-_gcd\ $2,$r} -else -u $2 -endif

#@gmic hex : hexadecimal_int1,...
#@gmic : Print specified hexadecimal integers into their binary, octal, decimal and string representations.
hex :
  -v - dec=@{-hex2dec\ ${^0}} -v +
  -e[^-1] "Convert hexadecimal integer"@{-arg\ 1+($#>1),s,""}" '${^0}' to binary '"@{-dec2bin\ $dec}"',
           octal '"@{-dec2oct\ $dec}"', decimal '"$dec"' and string '"@{-dec2str\ $dec}"'."

#@gmic hex2dec : hexadecimal_int1,...
#@gmic : Convert specified hexadecimal integers into their decimal representations.
hex2dec :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_hex2dec :
  ({'@{-struncase\ $1}'})
  is_negative=0
  -if {@{-1,0}==45} -z[-1] 1,100% is_negative=1 -endif
  -f[-1] "if(i>=48 && i<=57,i-48,if(i>=97 && i<=102,i-87,nan))*16^(w-1-x)"
  -u {if($is_negative,-1,1)*@{-1,+}}
  -rm[-1]

#@gmic hex2str : hexadecimal_string
#@gmic : Convert specified hexadecimal string into a string.
hex2str : -skip ${1=""}
  -v -
  -if {!narg("$1")} -return -endif
  ({'$*'})
  -if {w<2} -rm[-1] -u "" -return -endif
  -r[-1] 2,{w/2},1,1,-1 -f[-1] 'if(i>=97,i-87,i-48)' -f[-1] 'if(x==0,i*16+i(x+1),0)' -columns[-1] 0
  -u @{-1,t} -rm[-1]
  -v +

#@gmic img2str
#@gmic : Return the content of the latest of the selected image as a special G'MIC input string.
img2str :
  -v -
  -u "("
  -repeat {s} c=$>
    -repeat {d} z=$>
      -repeat {h} y=$>
        --crop[-1] 0,$y,$z,$c,100%,$y,$z,$c
        -u @{}@-1
        -rm[-1]
        -if {$y!=h-1} -u @{}; -endif
        -e @{}
      -done
      -if {$z!=d-1} -u @{}/ -endif
    -done
    -if {$c!=s-1} -u @{}^ -endif
  -done
  -u @{}")"
  -v +

#@gmic img2text : _line_separator
#@gmic : Return text contained in a multi-line image.
#@gmic : Default value: 'line_separator= '.
img2text : -skip "${1= }"
  -v - --l -s y -s -,0 -y x -if {@#>1} -i[1--2] ({'"$1"'}) -endif -a x -u @{0,t} -rm -endl -v +

#@gmic img82hex
#@gmic : Convert selected 8bits-valued vectors into their hexadecimal representations (ascii-encoded).
img82hex :
  -e[^-1] "Convert 8bits-valued vector$? into hexadecimal representations (ascii-encoded)."
  -v - -mod 256 -y
  -repeat @#
    --f[$>] 'v=int(i)&15;v+if(v<10,48,87)'  # lower digit.
    -f[$>] 'v=int(i)>>4;v+if(v<10,48,87)'   # higher digit.
    -a[$>,-1] x
  -done -v +

#@gmic hex2img8
#@gmic : Convert selected hexadecimal representations (ascii-encoded) into 8bits-valued vectors.
hex2img8 :
  -e[^-1] "Convert hexadecimal representation$? (ascii-encoded) into 8bits-valued vectors."
  -v - -repeat @#
    -s[-1] x,2 -f[-2,-1] 'if(i>=97,i-87,i-48)' -*[-2] 16 -+[-2,-1]
  -mv[-1] 0 -done -v +

#@gmic is_3d
#@gmic : Return 1 if all of the selected image are 3d objects, 0 otherwise.
is_3d :
  -v - -u 1 -l -check3d 1 -onfail -u 0 -endl -v +

#@gmic is_percent : string
#@gmic : Return 1 if specified string ends with a '%', 0 otherwise.
is_percent :
  -v - -u {arg(-1,{'"$1"'})==37} -v +

#@gmic is_windows
#@gmic : Return 1 if current computer OS is Windows, 0 otherwise.
is_windows :
  -v - -u {narg($OS)==1" && "narg($WINDIR)==1} -v +

#@gmic mad
#@gmic : Return the MAD (Maximum Absolute Deviation) of the last selected image.
#@gmic : The MAD is defined as MAD = med_i|x_i-med_j(x_j)|
mad :
  -v - ---[-1] @{-med[-1]} -abs[-1] -med[-1] -u {1.4826*@{}} -rm[-1] -v +

#@gmic max_w
#@gmic : Return the maximal width between selected images.
max_w :
  -v - -u {arg(1,@{-_max_whds\ 4})} -v +

#@gmic max_h
#@gmic : Return the maximal height between selected images.
max_h :
  -v - -u {arg(2,@{-_max_whds\ 4})} -v +

#@gmic max_d
#@gmic : Return the maximal depth between selected images.
max_d :
  -v - -u {arg(3,@{-_max_whds\ 4})} -v +

#@gmic max_s
#@gmic : Return the maximal spectrum between selected images.
max_s :
  -v - -u {arg(4,@{-_max_whds\ 4})} -v +

#@gmic max_wh
#@gmic : Return the maximal wxh size of selected images.
max_wh :
  -v - -_max_whds 2 -v +

#@gmic max_whd
#@gmic : Return the maximal wxhxd size of selected images.
max_whd :
  -v - -_max_whds 3 -v +

#@gmic max_whds
#@gmic : Return the maximal wxhxdxs size of selected images.
max_whds :
  -v - -_max_whds 4 -v +

_max_whds :
  w=0 h=0 d=0 s=0
  -repeat @#
    w={max($w,w)}
    h={max($h,h)}
    d={max($d,d)}
    s={max($s,s)}
  -mv[-1] 0 -done
  -if {$1>=4} -u $w,$h,$d,$s
  -elif {$1==3} -u $w,$h,$d
  -elif {$1==2} -u $w,$h
  -else -u $w
  -endif

#@gmic med
#@gmic : Return the median value of the last selected image.
med :
  -v - --sort[-1] -u @{-1,{w*h*d*s/2}} -rm[-1] -v +

#@gmic color_med
#@gmic : Return the median color value of the last selected image.
color_med :
  -v - -u "" s="" -repeat {s} --channels[-1] $> -u @{}$s@{-med[-1]} s=, -rm[-1] -done -v +

#@gmic min_w
#@gmic : Return the minimal width between selected images.
min_w :
  -v - -u {arg(1,@{-_min_whds\ 4})} -v +

#@gmic min_h
#@gmic : Return the minimal height between selected images.
min_h :
  -v - -u {arg(2,@{-_min_whds\ 4})} -v +

#@gmic min_d
#@gmic : Return the minimal depth between selected images.
min_d :
  -v - -u {arg(3,@{-_min_whds\ 4})} -v +

#@gmic min_s
#@gmic : Return the minimal s size of selected images.
min_s :
  -v - -_min_s @{-_min_whds\ 4} -v +

_min_s :
  -u $4

#@gmic min_wh
#@gmic : Return the minimal wxh size of selected images.
min_wh :
  -v - -_min_whds 2 -v +

#@gmic min_whd
#@gmic : Return the minimal wxhxd size of selected images.
min_whd :
  -v - -_min_whds 3 -v +

#@gmic min_whds
#@gmic : Return the minimal wxhxdxs size of selected images.
min_whds :
  -v - -_min_whds 4 -v +

_min_whds :
  w={w} h={h} d={d} s={s}
  -repeat @#
    w={min($w,w)}
    h={min($h,h)}
    d={min($d,d)}
    s={min($s,s)}
  -mv[-1] 0 -done
  -if {$1>=4} -u $w,$h,$d,$s
  -elif {$1==3} -u $w,$h,$d
  -elif {$1==2} -u $w,$h
  -else -u $w
  -endif

#@gmic normalize_filename : filename
#@gmic : Return a "normalized" version of the specified filename, without spaces and capital letters.
normalize_filename :
  -v - ({'"$1"'}) -f[-1] 'if(i>=65&&i<=90,i+32,if(i==32,95,i))' -u @{-1,t} -rm[-1] -v +

#@gmic oct : octal_int1,...
#@gmic : Print specified octal integers into their binary, decimal, hexadecimal and string representations.
oct :
  -v - dec=@{-oct2dec\ ${^0}} -v +
  -e[^-1] "Convert octal integer"@{-arg\ 1+($#>1),"",s}" '${^0}' to binary '"@{-dec2bin\ $dec}"', decimal '"$dec"',
           hexadecimal '"@{-dec2hex\ $dec}"' and string '"@{-dec2str\ $dec}"'."

#@gmic oct2dec : octal_int1,...
#@gmic : Convert specified octal integers into their decimal representations.
oct2dec :
  -v - res=@{-_$0\ $1} -repeat {$#-1} res=$res,@{-_$0\ @{-arg\ $>+2,${^0}}} -done -u $res -v +

_oct2dec :
  ({'@{-struncase\ $1}'})
  is_negative=0
  -if {@{-1,0}==45} -z[-1] 1,100% is_negative=1 -endif
  -f[-1] "if(i>=48 && i<=55,(i-48)*8^(w-1-x),nan)"
  -u {if($is_negative,-1,1)*@{-1,+}}
  -rm[-1]

#@gmic padint : number,_size>0
#@gmic : Return a integer with 'size' digits (eventually left-padded with '0').
padint : -skip ${2=4}
  -v - -u "" -repeat $2 -u @{}{int($1/10^$<)%10} -done -v +

#@gmic path_gimp
#@gmic : Return a path to store GIMP configuration files for one user (whose value is OD-dependent).
path_gimp :
  -if {narg({'${GIMP2_DIRECTORY}'})} -u ${GIMP2_DIRECTORY} -return -endif
  -if {narg({'${USERPROFILE}'})} -u ${USERPROFILE}
  -elif {narg({'${HOME}'})} -u ${HOME}
  -else -u ""
  -endif
  -if @{}/.gimp-2.8/pluginrc -u @{}/.gimp-2.8
  -elif @{}/.gimp-2.6/pluginrc -u @{}/.gimp-2.6
  -else -u @{-path_tmp}
  -endif -v +

#@gmic path_tmp
#@gmic : Return a path to store temporary files (whose value is OS-dependent).
path_tmp :
  -v - -u ""
  -if {narg({'${TMP}'})} -u ${TMP}
  -elif {narg({'${TEMP}'})} -u ${TEMP}
  -elif {narg({'${TMPDIR}'})} -u ${TMPDIR}
  -elif {narg({'${HOME}'})} -u "/tmp"
  -else -u ""
  -endif
  -v +

#@gmic path_user
#@gmic : Return a path to store persistent configuration files for one user (whose value is OS-dependent).
path_user :
  -v - -u ""
  -if {narg({'${APPDATA}'})} -u ${APPDATA}
  -elif {narg({'${HOME}'})} -u ${HOME}
  -else -u ""
  -endif
  -v +

#@gmic quote : string
#@gmic : Return a "quotified" version of the string.
quote :
  -v - -u "$*" -v +

#@gmic region_feature : region_label,feature,_default_value
#@gmic : Return feature for a specified region.
#@gmic : This function requires two images [img,region_label] in the selection.
#@gmic : Argument 'feature' is a string that corresponds to the way the feature would
#@gmic : be asked for the entire image.
#@gmic : Default value: 'default_value=0'.
#@gmic : $ image.jpg --luminance -quantize[-1] 2 -label[-1] 0,1 mean=@{"-region_feature[0,1] 10,\"{ia}\""} sum=@{"-region_feature[0,1] 10,\"@{-1,+}\""}
region_feature : -skip "${3=0}"
  -v -
  s=@{-2,s} --channels[-1] 0 -==[-1] $1 -^[-1] -1 --[-1] 1 -r[-1] [-3] -+[-1] [-3]
  -l[-1]
    -s[-1] -,inf -a y                            # Keep only pixel values inside the selected region.
    -if @# -r[-1] 1,{h/$s},1,$s,-1 -u $2 -rm[-1] # If region is not empty, compute the feature.
    -else -u $3                                  # Otherwise set a default return value.
    -endif
  -endl
  -v +

#@gmic reset
#@gmic : Reset global parameters of the interpreter environment.
reset :
  -e[^-1] "Reset global parameters of the interpreter environment."
  -v -1 -db3d -b3d -m3d -md3d -f3d -l3d -sl3d -ss3d -v

#@gmic RGB
#@gmic : Return a random int-valued RGB color.
RGB :
  -v - -u {round(?(255))},{round(?(255))},{round(?(255))} -v +

#@gmic RGBA
#@gmic : Return a random int-valued RGBA color.
RGBA :
  -v - -u {round(?(255))},{round(?(255))},{round(?(255))},{round(?(255))} -v +

#@gmic str : string
#@gmic : Print specified string into its binary, octal, decimal and hexadecimal representations.
str : -skip $1
  -v - dec={'$*'} -v +
  -e[^-1] "Convert string '$*' to binary '"@{-dec2bin\ $dec}"', octal '"@{-dec2oct\ $dec}"', decimal '"$dec"' and
           hexadecimal '"@{-dec2hex\ $dec}"'."

#@gmic str2hex : string
#@gmic : Convert specified string into a sequence of hexadecimal values.
str2hex :
  -v - ({'"$*"'}) -rows[-1] 0,1 -f[-1] 'if(y==0,int(i/16),i(x,y-1)%16)' -f[-1] 'if(i<=9,48+i,87+i)' -transpose[-1] -u @{-1,t} -rm[-1] -v +

#@gmic stresc : val1,...,valN
#@gmic : Return escaped string from specified ascii codes.
stresc :
  -v - ($*) -c[-1] 32,255 -y[-1] [-1]
  -f[-2] 'if(i==32||i==34||i==36||i==44||i==64||i==92||i==123||i==125,92,-1)' -a[-2,-1] x
  -discard[-1] -1 -u @{-1,t} -rm[-1] -v +

#@gmic strcat : string1,string2,...
#@gmic : Return the concatenation of all strings passed as arguments.
strcat :
  -v - $=s res="$1" -repeat {$#-1} res=$res${s{$>+2}} -done
  -u $res -v +

#@gmic strcmp : string1,string2
#@gmic : Return 1 if the two strings are equal, 0 otherwise.
strcmp :
  -v - (0,{'"$1"'}) ({w},{'"$2"'}) -=[-2] {w} --[-2,-1] -abs[-1] -u {!@{-1,+}} -rm[-1] -v +

#@gmic strlen : string1
#@gmic : Return the length of specified string argument.
strlen :
  -v - ({'"$1"'}) -u {w} -rm[-1] -v +

#@gmic strreplace : string,search,replace
#@gmic : Search and replace substrings in an input string.
strreplace :
  -v -
  ls=@{-strlen\ "$2"}
  lr={@{-strlen\ "$3"}-1}
  -l[] ({'"$1"'}) -s +,{'"$2"'} -s y,-$ls
  -repeat @# -if {@{$>,t}'=='"$2"} -rows[$>] 0,$lr -f[$>] {'"$3"'} -endif -done
  -a y -u @{-1,t} -rm -endl
  -v +

#@gmic struncase : string
#@gmic : Return a lower-case version of the specified string.
struncase :
  -v - ({'"$*"'}) -+[-1] 'if(i>=65&&i<=90,32,0)' -u @{-1,t} -rm[-1] -v +

#@gmic strver
#@gmic : Return the current version number of the G'MIC interpreter, as a string.
strver :
  -v - ({'@.'}) -r[-1] 7 -f[-1] 'if(x%2,{'.'},i)' -u @{-1,t} -rm[-1] -v +

#@gmic tic
#@gmic : Initialize tic-toc timer.
#@gmic : Use it in conjunction with '-toc'.
tic :
  -e[^-1] "Initialize timer."
  -v - -if {!narg($__ticpos)} __ticpos=0 -endif __tic$__ticpos=@| __ticpos={$__ticpos+1} -v +

#@gmic toc
#@gmic : Display elapsed time of the tic-toc timer since the last call to '-tic'.
#@gmic : Use it in conjunction with '-tic'.
toc :
  -v - __ticpos={$__ticpos-1} -v +
  -e[^-1] "Elapsed time : "{_@|-${__tic$__ticpos}}" s".

#@gmic variance_noise
#@gmic : Return the estimated noise variance of the last selected image.
variance_noise :
  -v - --laplacian[-1] -u {@{-mad[-1]}/sqrt(if(d==1,20,42))} -rm[-1] -v +

#-----------------------------
#
#@gmic :: Others
#
#-----------------------------

#@gmic gpt : _scorefile,_number_of_sessions>=0
#@gmic : Generate score board for the GPT championship (GREYC Poker Tour).
#@gmic : $ -gpt ,
gpt : -skip "${1=https://tschumperle.users.greyc.fr/gpt.raw}" -skip ${2=0},${3=0}
  -e[^-1] "Generate score board for GPT-like championship (GREYC Poker Tour), from file '$1'."
  -v -

  # Load score file and generate score field.
  #------------------------------------------
  -rm -i raw:$1,uchar -s[-1] -,10 -transpose                           # Split score file into lines.
  -repeat @# -if {i=={'#'}} -rm[-1] -else -mv[-1] 0 -endif -done       # Remove comment lines.
  -repeat @# -l[$>]
    -s -,{'\ '}
    -if @#
      -if {@#!=4} -error[0--4] "Invalid score file (line "{$>+1}" defines "@#" items instead of 4)." -endif
      player$>_name=@{0,t}
      player$>_url=@{1,t}
      player$>_file=@{2,t}
      (@{3,t}) -rm[0-3]
    -endif
  -endl -done
  -+ 1 -a y,1 -- 1
  -if {$2>0} -z[-1] {max(0,w-$2)},100%          # Keep only last Nth sessions.
  -elif {$2<0} -z[-1] {w-1-((w-1)%-$2)},100%    # Keep only sessions of the last Nth-session tournament.
  -endif

  # Remove non-players in 'alternate' score boards.
  #------------------------------------------------
  -if $2 -s y -repeat @# -if {@{$<,M}<0}
    i=$< -repeat {@#-$i}
      player{$i+$>}_name=${player{$i+$>+1}_name}
      player{$i+$>}_url=${player{$i+$>+1}_url}
      player{$i+$>}_file=${player{$i+$>+1}_file}
    -done
    -rm[$<] -endif -done -a y
  -endif
  -nm[-1] scores

  # Set global variables.
  #-----------------------
  row_height={if($2,24,48)}

  # Compute session winners and losers
  # (must be done before rounding scores to integers!).
  #----------------------------------------------------
  --l[scores] -s y -max -endl --==[scores,-1] -rm[-2]
  -nm[-1] winners
  --l[scores] -replace[-1] -1,1e8 -s y -min -endl --==[scores,-1] -rm[-2]
  -nm[-1] losers
  --l[winners] -s y -+ -endl
  -nm[-1] nb_winners
  --l[losers] -s y -+ -endl
  -nm[-1] nb_losers

  # Compute players ranks for each session.
  # (must be done before rounding scores to integers!).
  #----------------------------------------
  --l[scores] -s x -r 2,100%,1,1,0 -f 'if(x,y,i)' -sort -,y
  -r 3,100%,1,1,0,0,1,0 -f 'if(x,i,y+1)'
  -f '>if(x,i,if(i(1,y)==i(1,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -mirror x -sort +,y -z 1,2 -f 'if(i(0,y)==-1,-1,i)'
  -z 1,1 -a x -endl
  -nm[-1] ranks

  # Round scores to nearest integer.
  #---------------------------------
  -round[scores]

  # Compute number of players per session.
  #---------------------------------------
  --l[scores] -s x -discard -1 -f h -rows 0 -a x -endl
  -nm[-1] nb_players

  # Compute min and max scores per session.
  #----------------------------------------
  --l[scores] -s y -max -endl
  -nm[-1] max_scores
  --l[scores] -replace[-1] -1,1e8 -s y -min -endl
  -nm[-1] min_scores

  # Compute number of games per player.
  #-------------------------------------
  --l[scores] -ge 0 -s x -+ -endl
  -nm[-1] nb_games

  # Compute index of first games.
  #-------------------------------
  --l[scores] -neq -1 -s y -* 'w-x' -f xM -a y -z 0,0 -endl
  -nm[-1] first_game

  # Compute absences malus.
  #-------------------------
  --lt[scores] 0
  --l[-1] -s x -+ -endl --[-1] [first_game] # nb_absences since first played game.
  -l[-2] -f 'if(i,i,-x)' -s y -label -repeat @# n={@{$>,M}} -if $n -histogram[$>] $n,1,$n -else -f[$>] 0 -endif -done
  -r 1,1,1,1,2 -a y -- 1 -max 0 -round -endl -*[-2,-1] -round[-1]
  -nm[-1] abs_malus

  # Compute player scores and corresponding ranks.
  #------------------------------------------------
  --l[scores] -f 'if(i==-1,0,i-100)' -s x -+ -endl
  -if $3 -abs[-1] -endif
  --[-1] [abs_malus]
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,'y+1' -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -nm[-1] rank
  --shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] score
  sum_score=@{score,+}

  # Compute player best scores and corresponding ranks.
  #----------------------------------------------------
  --l[scores] -s x -max -- 100 -endl
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,'y+1' -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] best_score

  # Compute previous player scores and corresponding ranks.
  #--------------------------------------------------------
  --l[scores] -columns 0,{w-2} -f 'if(i==-1,0,i-100)' -s x -+ -endl --[-1] [abs_malus]
  -if $3 -abs[-1] -endif
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,'y+1' -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] previous_score

  # Compute player chips.
  #----------------------
  --l[scores] -f 'if(i==-1,0,i-100)' -s x -+ -endl
  -nm[-1] chips
  sum_chips=@{chips,+}
  -v +
  -e "Sum of chips : "$sum_chips
  -e "Sum of scores : "$sum_score
  -v -

  # Compute player ranking trends.
  #-------------------------------
  ---[previous_score,score] -columns[-1] 1
  -nm[-1] trend

  # Compute player highest chips count.
  #------------------------------------
  --l[scores] -s y -discard -1 -unroll x -- 100 -cumul -f iM -a y -z 0,0 -endl
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,'y+1' -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] highest_chips

  # Compute player lowest chips count.
  #------------------------------------
  --l[scores] -s y -discard -1 -unroll x -- 100 -cumul -f im -a y -z 0,0 -endl
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,'y+1' -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] lowest_chips

  # Compute player performances and corresponding ranks.
  #-----------------------------------------------------
  ---[scores] [min_scores] [max_scores] --[-1] [min_scores] -/[-2,-1] -*[-1] 100
  -l[-1] -f 'if(i<0,-1,i)' -s y -discard -1 -f 'if(ia<0,0,ia)' -rows 0 -a y -round 1 -endl
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,y+1 -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] performance

  # Compute player average scores and corresponding ranks.
  #--------------------------------------------------------
  --l[scores] -s y -discard -1 -- 100 -r 1,1,1,1,2 -a y -endl
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,y+1 -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] average

  # Compute player coffee balances and corresponding ranks.
  #--------------------------------------------------------
  --!=[scores] -1                            # Coffee won.
  --*[losers,nb_players] -/[-1] [nb_losers]  # Coffee paid.
  --[-2,-1] -l[-1] -s x -+ -endl -round[-1] -*[-1] 0.4
  --f[-1] y -a[-2,-1] x -sort[-1] -,y
  1,100%,1,1,y+1 -a[-2,-1] x -mirror[-1] x
  -f[-1] '>if(x,i,if(i(2,y)==i(2,y-1),i(0,y-1),i))'  # Manage ax-aequo ranks.
  -shift[-1] -1,0,0,0,2 -sort[-1] +,y -columns[-1] 1,100%
  -nm[-1] coffee_balance

  # Compute arrow sprites for trends.
  #----------------------------------
  -cone3d 1.5,2 -r3d[-1] 0,1,0,90 -box3d 4,1,0 -+3d[-1] 0,-0.5 -+3d[-2,-1] -r3d[-1] 0,1,0,180
  -c3d[-1] -*3d[-1] 17 -col3d[-1] 1
  128,128 -object3d[-1] [-2],50%,50%,0,1,2 -nm[-1] arrow_eq_mask
  --*[-1] 200 --*[-2] 200 --*[-3] 200 -a[-3--1] c -nm[-1] arrow_eq
  -r3d[-3] 0,0,1,35
  128,128 -object3d[-1] [-4],50%,50%,0,1,2 -nm[-1] arrow_up_mask
  --*[-1] 64 --*[-2] 255 --*[-3] 64 -a[-3--1] c -nm[-1] arrow_up
  -r3d[-5] 0,0,1,-70
  128,128 -object3d[-1] [-6],50%,50%,0,1,2 -nm[-1] arrow_down_mask
  --*[-1] 255 --*[-2] 64 --*[-3] 32 -a[-3--1] c -nm[-1] arrow_down
  -dilate[arrow_eq_mask,arrow_up_mask,arrow_down_mask] 3
  -rm[-7]

  # Render score board.
  #--------------------
  board=@#

  # Row of labels.
  i=@#
  -_gpt_field "Rank",48,$row_height,16,1,6
  -_gpt_field " ",$row_height,$row_height,16,1,6
  -_gpt_field "Name",150,$row_height,16,1,6
  -_gpt_field "Score",80,$row_height,16,1,6
  -_gpt_field "Chips\n[malus]",80,$row_height,24,1,6
  -_gpt_field "Played",48,$row_height,12,1,6
  -_gpt_field "Won/\nLost",48,$row_height,24,1,6
  -if $2 -_gpt_field "Trd",$row_height,$row_height,12,1,6
  -else -_gpt_field "Trend",$row_height,$row_height,12,1,6
  -endif
  -if $2 -_gpt_field "Stats",{2*$row_height},$row_height,12,1,6
  -else -_gpt_field "Statistics",{4*$row_height+2},$row_height,12,1,6
  -endif
  -_gpt_field "Last\n(rank)",64,$row_height,24,1,6
  -_gpt_field "Best\n(rank)",64,$row_height,24,1,6
  -_gpt_field "Highest\nchips (rank)",64,$row_height,24,1,6
  -_gpt_field "Lowest\nchips (rank)",64,$row_height,24,1,6
  -_gpt_field "Performance\n   (rank)",64,$row_height,24,1,6
  -_gpt_field "Average\n[std] (rank)",100,$row_height,24,1,6
  -_gpt_field "Coffee balance\n     (rank)",80,$row_height,24,1,6
  -a[$i--1] x

  # Retrieve maximum ranks for every field.
  max_players=@{nb_players,M}
  --z[rank] 0,0 max_rank={iM} -rm[-1]
  --z[performance] 1,1 max_performance_rank={iM-1} -rm[-1]
  --z[best_score] 1,1 max_best_score_rank={iM-1} -rm[-1]
  --z[average] 1,1 max_average_rank={iM-1} -rm[-1]
  --z[coffee_balance] 1,1 max_coffee_balance_rank={iM} -rm[-1]

  # Loop on each player row.
  -repeat @{rank,h}
    p=@{rank,(1,$>)}
    n=@{nb_games,(0,$p)}
    c={if(@{nb_games,(0,$p)}==0,0,v=@{score,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_rank-1,4,if(v==$max_rank,5,0))))}
    i=@#

    # Rank.
    t_rank=@{score,(1,$p)}
    -_gpt_field $t_rank,48,$row_height,16,1,$c

    # Avatar.
    -if @{-path_tmp}/${player${p}_file} @{-path_tmp}/${player${p}_file}
    -else ${player${p}_url}${player${p}_file} -o[-1] @{-path_tmp}/${player${p}_file}
    -endif
    -to_rgb[-1] --[-1] 255 -rr2d[-1] {$row_height-2},{$row_height-2},2,2 -+[-1] 255 -frame[-1] 1,1,0

    # Name.
    t_name=@{-_gpt_remove_underscore\ ${player${p}_name}}
    0 -t[-1] $t_name,0,0,32,1,255,255,255
    -r[-1] 100%,100%,1,4
    -sh[-1] 0,2 -*[-1] '(2-c)*0.9*y/h' -rm[-1]
    -drop_shadow[-1] 1,1,1
    -_gpt_field " ",225,{1.5*$row_height},20,1,$c -mv[-1] -2
    -blend[-2,-1] alpha
    -r2dy[-1] $row_height
    -z[-1] 1,1,{w-2},{h-2} -frame[-1] 1,1,0

    # Score.
    t_score=@{score,(0,$p)}
    -if {$t_score>0} t_score=+$t_score -endif
    -_gpt_field $t_score,80,$row_height,20,$n,$c

    # Chips [malus]
    t_chips=@{chips,(0,$p)}
    t_malus={-@{abs_malus,(0,$p)}}
    -if {$t_chips>0} t_chips=+$t_chips -endif
    -_gpt_field $t_chips\ [$t_malus],80,$row_height,16,$n,$c

    # Played
    t_nb_games=@{nb_games,(0,$p)}
    -_gpt_field $t_nb_games,48,$row_height,16,$n,$c

    # Won/lost.
    --rows[winners] $p
    t_won=@{-1,+}
    --rows[losers] $p
    t_lost=@{-1,+}
    -rm[-2,-1]
    -_gpt_field $t_won/$t_lost,48,$row_height,16,$n,$c

    # Trend.
    -if {!$n} {$row_height-2},{$row_height-2},1,3,255 -frame[-1] 1,1,0
    -else
      t_trend={-@{trend,(0,$p)}}
      -_gpt_field " ",128,128,16,$n,$c
      -if {$t_trend>0} t_trend=+$t_trend -j[-1] [arrow_up],0,0,0,0,1,[arrow_up_mask]
      -elif {$t_trend<0} -j[-1] [arrow_down],0,0,0,0,1,[arrow_down_mask]
      -else -j[-1] [arrow_eq],0,0,0,0,1,[arrow_eq_mask]
      -endif
      -r2dy[-1] $row_height

      -if $2
        -z[-1] 1,1,{w-2},{h-2} -frame[-1] 1,1,0
      -else
        -if {$t_trend>0} -_gpt_field "\n\n    "$t_trend,$row_height,$row_height,48,$n,0
        -elif {$t_trend<0} -_gpt_field "\n\n"$t_trend"     ",$row_height,$row_height,48,$n,0
        -else -_gpt_field " ",$row_height,$row_height,48,$n,0
        -endif
        -/[-1] 255 -*[-2,-1]
      -endif

    -endif

    # Statistics.
    -if {!$n} {if($2,2*$row_height,4*$row_height+2)},{$row_height},1,3,255
    -else
      {3*$row_height},{1.5*$row_height},1,3,255

      # Histogram of session ranks.
      --rows[ranks] $p,$p -histogram[-1] $max_players,1,$max_players
      -graph[-2] [-1],3,0,0,0,0.2,0,64,255
      -rm[-1]

      # Plot of results.
      --rows[scores] $p
      -discard[-1] -1 --[-1] 100 -cumul[-1] sa={ia} sm={im} sM={iM}
      -grid[-2] {max(20,100/max(1,h-1))}%,10,0,0,0.6,0xCCCCCCCC,0
      (0,0) -graph[-3] [-1],1,0,{$sM+10},{$sm-10},1,0 -rm[-1]
      ($sa,$sa) -graph[-3] [-1],1,0,{$sM+10},{$sm-10},1,0x55555555,0,150,0 -rm[-1]
      -graph[-2] [-1],2,0,{$sM+10},{$sm-10},1,255,32,48 -rm[-1]
      -r2dy[-1] {$row_height}

      # Pie-chart of sessions ranks.
      -if {!$2}
        1,$row_height,1,3,0        # Separator
        --rows[ranks] $p -histogram[-1] $max_players,1,$max_players -y[-1]
        ip=@#
        (1,10,255,242,153)
        (2,10,222,222,222)
        (3,10,232,209,196)
        ({$max_players-1},10,255,204,204)
        ($max_players,10,255,153,153)
        -if {$max_players==1} -rm[-4--1]
        -elif {$max_players==2} -rm[-3--1]
        -elif {$max_players==3} -rm[-2--1]
        -elif {$max_players==4} -rm[-2]
        -elif {$max_players>5} -a[-3,-2] y -r[-2] 100%,{$max_players-3},1,1,3 -round[-2]
        -endif
        -a[$ip--1] y
        -j[-1] [-2],1,0 -rm[-2]

        256,256,1,3,255 -piechart[-1] 57,0,0,0,@-2,"abs.",{@{scores,w}-@{nb_games,(0,$p)}},255,255,255 -frame[-1] 10,10,255
        1,$row_height,1,3,0
        256,256,1,3,255 -piechart[-1] 57,0,0,0,@-4 -frame[-1] 10,10,255
        -rm[-4] -r2dy[-3,-1] $row_height
        -a[-5--1] x
      -endif

    -endif
    -z[-1] 1,1,{w-2},{h-2} -frame[-1] 1,1,0

    # Last score.
    t_last_score=@{scores,(100%,$p)}
    -if {$t_last_score==-1} t_last=abs.
    -else
      t_last_score={$t_last_score-100}
      -if {$t_last_score>0} t_last_score=+$t_last_score -endif
      t_last_rank=@{ranks,(100%,$p)}
      t_last=$t_last_score\ ($t_last_rank)
    -endif
    c={v=@{ranks,(100%,$p)};if(v>=1&&v<=3,v,if(v==@{nb_players,-1}-1,4,if(v==@{nb_players,-1},5,0)))}
    -_gpt_field $t_last,64,$row_height,16,$n,$c

    # Best score.
    t_best_score={v=@{best_score,(0,$p)};if(v==-1,-1,v)}
    t_best_rank=@{best_score,(1,$p)}
    -if {$t_best_score>0} t_best_score=+$t_best_score
    -elif {$t_best_score==-1} t_best_score=abs.
    -endif
    c={v=@{best_score,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_best_score_rank-1,4,if(v==$max_best_score_rank,5,0)))}
    -_gpt_field $t_best_score\ ($t_best_rank),64,$row_height,16,$n,$c

    # Highest chips.
    t_highest_chips={v=@{highest_chips,(0,$p)};if(v==-1,-1,v)}
    t_highest_rank=@{highest_chips,(1,$p)}
    -if {$t_highest_chips>0} t_highest_chips=+$t_highest_chips
    -elif {$t_highest_chips==-1} t_highest_chips=abs.
    -endif
    c={v=@{highest_chips,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_best_score_rank-1,4,if(v==$max_best_score_rank,5,0)))}
    -_gpt_field $t_highest_chips\ ($t_highest_rank),64,$row_height,16,$n,$c

    # Lowest chips.
    t_lowest_chips={v=@{lowest_chips,(0,$p)};if(v==-1,-1,v)}
    t_lowest_rank=@{lowest_chips,(1,$p)}
    -if {$t_lowest_chips>0} t_lowest_chips=+$t_lowest_chips
    -elif {$t_lowest_chips==-1} t_lowest_chips=abs.
    -endif
    c={v=@{lowest_chips,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_performance_rank,4,if(v==$max_performance_rank+1,5,0)))}
    -_gpt_field $t_lowest_chips\ ($t_lowest_rank),64,$row_height,16,$n,$c

    # Performance.
    t_performance=@{performance,(0,$p)}
    t_performance_rank=@{performance,(1,$p)}
    c={v=@{performance,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_performance_rank-1,4,if(v==$max_performance_rank,5,0)))}
    -_gpt_field $t_performance%\ ($t_performance_rank),64,$row_height,16,$n,$c

    # Average [std].
    --rows[scores] $p -discard[-1] -1
    t_average={if(i==-1,0,round(ia-100))}
    -if {$t_average>0} t_average=+$t_average -endif
    t_average_std={if(i==-1,0,round(sqrt(iv)))}
    -rm[-1]
    t_average_rank=@{average,(1,$p)}
    c={v=@{average,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_average_rank-1,4,if(v==$max_average_rank,5,0)))}
    -_gpt_field $t_average\ [$t_average_std]\ ($t_average_rank),100,$row_height,16,$n,$c

    # Coffee balance.
    t_coffee_balance={_@{coffee_balance,(0,$p)}}
    -if {$t_coffee_balance>0} t_coffee_balance=+$t_coffee_balance -endif
    t_coffee_rank=@{coffee_balance,(1,$p)}
    c={v=@{coffee_balance,(1,$p)};if(v>=1&&v<=3,v,if(v==$max_coffee_balance_rank-1,4,if(v==$max_coffee_balance_rank,5,0)))}
    -_gpt_field $t_coffee_balance\$\ ($t_coffee_rank),80,$row_height,16,$n,$c

    # Append all fields into a single row.
    -if {!$n} -f[$i,{$i+2}--1] "i*(0.7+0.3*(((x+y)%8)!=0))" -endif  # Add hatches for absent player.
    -a[$i--1] x

  -done

  # Title.
  avg_nb_players={round(@{nb_players,a},0.5)}
  -if {$2==0} t_title="** GREYC Poker Tour ** Session \#"@{scores,w}"   (avg. \#player = "$avg_nb_players")"
  -elif {$2>0} t_title="** GREYC Poker Tour ** Last "@{scores,w}" sessions  (avg. \#player = "$avg_nb_players")"
  -else t_title="** GREYC Poker Tour ** Session \#"@{scores,w}"/"{-$2}" (avg. \#player = "$avg_nb_players")"
  -endif
  0 -t[-1] $t_title,0,0,57,1,255 -r[-1] 100%,100%,1,4 -drop_shadow[-1] 5,5,2
  -r2dy[-1] 24 -r[-1] {@{$board,w}-2},{1.5*$row_height-2},1,4,0,0,0.5,{if($2,0.9,0.6)}
  -i[-2] 1,3,1,3,32,0,64,32,64,128,64,200,256 -r[-2] [-1],[-1],1,3,3 -blend[-2,-1] alpha
  -if {$2>0} -shift[-1] 0,0,0,1,2 -elif {$2<0} -mirror[-1] c -endif
  -frame[-1] 1,1,0
  -mv[-1] $board

  # Session winner(s).
  -if {!$2}
    --columns[scores] 100% --f[-1] y -a[-2,-1] x -sort[-1] -,y
    -f[-1] 'if(i(0,y)==i(0,0),i,-1)' -autocrop[-1] -1 -nm[-1] session_winners # Keep only winners.
    nb_session_winners={h}
    t_session_winners=""
    -repeat $nb_session_winners
      i=@{session_winners,(1,$>)}
      t_session_winners=${player${i}_name}"__"${t_session_winners}
      @{-path_tmp}/${player{@{session_winners,(1,$>)}}_file} --[-1] 255 -rr2d[-1] 56,56,2,2 -+[-1] 255 -frame[-1] 1,1,0
    -done
    t_session_winners=@{-_gpt_remove_underscore\ $t_session_winners}
    0 -t[-1] "Session winner"@{-if\ {$nb_session_winners==1}\ -u\ \"\"\ -else\ -u\ s\ -endif}" : "$t_session_winners,0,0,57,1,255
    -r[-1] 100%,100%,1,4 -drop_shadow[-1] 5,5,2
    -r2dy[-1] 24 -r[-1] {@{$board,w}-2},{1.5*$row_height-2},1,4,0,0,0.1,0.5
    -i[-2] 1,2,1,3,0,128,128,255,64,128 -r[-2] [-1],[-1],1,3,3 -blend[-2,-1] alpha
    -if {$2>0} -shift[-1] 0,0,0,1,2 -elif {$2<0} -mirror[-1] c -endif
    -repeat $nb_session_winners -j[-1] [{-2-$<}],{w-64-$>*64},7 -done
    -frame[-1] 1,1,0
    -mv[-1] {$board+1}
    -rm[-{$nb_session_winners+1}--1]
  -endif

  # Session loser(s).
  -if {!$2}
    --columns[losers] 100% --f[-1] y -a[-2,-1] x -sort[-1] -,y
    -f[-1] 'if(i(0,y),i,-1)' -autocrop[-1] -1 -nm[-1] session_losers # Keep only losers.
    nb_session_losers={h}
    t_session_losers=""
    -repeat $nb_session_losers
      i=@{session_losers,(1,$>)}
      t_session_losers=${player${i}_name}"__"${t_session_losers}
      @{-path_tmp}/${player{@{session_losers,(1,$>)}}_file} --[-1] 255 -rr2d[-1] 56,56,2,2 -+[-1] 255 -frame[-1] 1,1,0
    -done
    t_session_losers=@{-_gpt_remove_underscore\ $t_session_losers}
    0 -t[-1] "Session loser"@{-if\ {$nb_session_losers==1}\ -u\ \"\"\ -else\ -u\ s\ -endif}" : "$t_session_losers,0,0,57,1,255
    -r[-1] 100%,100%,1,4 -drop_shadow[-1] 5,5,2
    -r2dy[-1] 24 -r[-1] {@{$board,w}-2},{1.5*$row_height-2},1,4,0,0,0.1,0.5
    -i[-2] 1,2,1,3,128,255,0,128,64,128 -r[-2] [-1],[-1],1,3,3 -blend[-2,-1] alpha
    -if {$2>0} -shift[-1] 0,0,0,1,2 -elif {$2<0} -mirror[-1] c -endif
    -repeat $nb_session_losers -j[-1] [{-2-$<}],{w-64-$>*64},7 -done
    -frame[-1] 1,1,0
    -rm[-{$nb_session_losers+2}--2]
  -endif

  # Append rows together.
  -a[$board--1] y

  # Add final shadow.
  100%,100%,1,1,255 -a[-2,-1] c -drop_shadow[-1] 6,6,4 -i[-2] {w},{h},1,3,255 -blend[-2,-1] alpha

  # Quit properly.
  -k[$board] -v +

_gpt_remove_underscore :
  ({'"$1"'}) -replace[-1] {'_'},{'\ '} -u @{-1,t} -rm[-1]

# $1 : Text - $2 : Width - $3 : Height - $4 : Font size - $5 : Text - $6 : Color code.
_gpt_field :
  -if {!$5} {$2-2},{$3-2},1,3,255 -frame[-1] 1,1,0 -return -endif
  0 -t[-1] "$1",0,0,57,1,1 -*[-1] -1 -+[-1] 1
  -r2dy[-1] $4 --[-1] 1 -r[-1] {$2-2},{$3-2},1,1,0,0,0.5,0.5 -+[-1] 1
  -frame[-1] 1,1,0
  [-1]x2
  -if {$6==1} -*[-3] 255 -*[-2] 242 -*[-1] 153
  -elif {$6==2} -*[-3] 222 -*[-2] 222 -*[-1] 222
  -elif {$6==3} -*[-3] 232 -*[-2] 209 -*[-1] 196
  -elif {$6==4} -*[-3] 255 -*[-2] 204 -*[-1] 204
  -elif {$6==5} -*[-3] 255 -*[-2] 153 -*[-1] 153
  -elif {$6==6} -*[-3] 240 -*[-2] 240 -*[-1] 240
  -else -*[-3--1] 255
  -endif
  -a[-3--1] c

#-------------------------------------
#
# Define menu entries for
# the G'MIC plug-in for GIMP
#
#-------------------------------------

# Function that returns the list of external sources to be included in the GIMP plug-in.
gimp_filter_sources :
  ({'gmic'})
  ({'http://gmic.sourceforge.net/update@..gmic'},1) # Override default filters.

# Function used for filters based on parallelization with spatial splitting.
gimp_parallel_overlap :
  -apply_parallel_overlap "$1",$3,{if($2,2^($2-1),0)}

# Function that updates filters definitions on the G'MIC web server.
# It sorts and merges filters from all available sources, and save
# a single update file on the G'MIC server. It also print on the standart
# output (stdout), the list of available filters.
# $1 = update version number.
# $2 = enable/disable filters list output on stdout.
update_gmic_gimp : -skip ${1=@.},${2=1}
  -v -

  # Create substitution list to force filters having a particular location.
  -_update_gmic_gimp_move "/Testing/J&#233;J&#233;/Rays","/Patterns"
  -_update_gmic_gimp_move "/Testing/Iain~fergusson/Halftone~shapes","/Patterns"
  -_update_gmic_gimp_move "/Testing/Iain~fergusson/Simple~local~contrast","/Details"
  -_update_gmic_gimp_move "/Testing/Garagecoder/Aurora","/Artistic"
  -_update_gmic_gimp_move "/Testing/Garagecoder/Despeckle","/Repair"
  -_update_gmic_gimp_move "/Testing/Garagecoder/HSL~adjustment","/Colors"
  -_update_gmic_gimp_move "/Testing/Garagecoder/HSV~select","/Colors"
  -_update_gmic_gimp_move "/Testing/Garagecoder/Stereo~image","/Stereoscopic~3d"
  -_update_gmic_gimp_move "/Testing/Garagecoder/Undo~anaglyph","/Stereoscopic~3d"
  -_update_gmic_gimp_move "/Testing/Naggobot/Blockism","/Artistic"
  -_update_gmic_gimp_move "/Testing/Samj/Chalk~it~up","/Artistic"
  -_update_gmic_gimp_move "/Testing/Samj/Denim~texture","/Patterns"
  -_update_gmic_gimp_move "/Testing/Zonderr/Spiral","/Rendering"

  # Define useful sub-commands.
  -m "parent : -l[] ({'$""1'}) -s -,{'/'} -if @# -rm[-1] -endif -i[0--1] (47) -a y -u @{0,t} -rm -endl" # Command to return parent of a path.
  -m "_max : ({'\"$""1\"'}) ({'\"$""2\"'}) -f[-2,-1] 'if(i>=97&&i<=122,i-32,i)' -r[-2,-1] {max(w,@{-2,w})},1,1,1,0 --[-2,-1] -autocrop[-1] 0 "\
     "-u {i>0} -rm[-1]" # Command to compare two strings (eq. to strcasecmp).
  -m "load_gmic : "\
     "_nb_sources={$_nb_sources+1} filename=@{\"-basename $""1\"} "\
     "-v + -e[] \"  \"$_nb_sources\". \"$filename\"  \" -v - "\
     "-l[] "\
     "  -i raw:$""1,uchar -v + -e[] \"      [retrieved from source '$""1']\n\" -v - "\
     "  -l "\
     "    -o raw:/tmp/$filename,uchar "\
     "    -x \"scp /tmp/\"$filename\" ronounours,gmic@web.sourceforge.net:htdocs/include/\" "\
     "    -v + -e[] \"      [archived]\n\" -v - "\
     "  -onfail -v + -e[] \"      [could not be archived!]\n\" -v - -endl "\
     "-onfail -l[] "\
     "  source=http://gmic.sourceforge.net/include/$filename "\
     "  -i raw:$source,uchar -v + -e[] \"      [retrieved from archive '\"$source\"']\n\" -v - "\
     "  -onfail -v + -e[] \"      [error, not reachable!]\n\" -v -"\
     "  -endl -endl"
  -m "calibrate_name : "\
     "-autocrop 32 "\
     "-f 'if(i>=65&&i<=90,i+32,i)' "\
     "-replace {'_'},32 -autocrop 32 "\
     "-replace_seq \""{'rgb'}"\",\""{'RGB'}"\" "\
     "-replace_seq \""{'lab'}"\",\""{'Lab'}"\" "\
     "-replace_seq \""{'hsv'}"\",\""{'HSV'}"\" "\
     "-replace_seq \""{'hsl'}"\",\""{'HSL'}"\" "\
     "-replace_seq \""{'ycbcr'}"\",\""{'YCbCr'}"\" "\
     "-replace_seq \""{'cmyk'}"\",\""{'CMYK'}"\" "\
     "-replace_seq \""{'b&amp;w'}"\",\""{'B&amp;W'}"\" "\
     "-replace_seq \""{'gimp'}"\",\""{'GIMP'}"\" "\
     "-replace_seq \""{'roddy'}"\",\""{'Roddy'}"\" "\
     "-replace_seq \""{'crt'}"\",\""{'CRT'}"\" "\
     "-replace_seq \""{'colorabstractionpaint'}"\",\""{'"Color abstraction paint"'}"\" "\
     "-replace_seq \""{'g'},39,{'mic'}"\",\""{'G'},39,{'MIC'}"\" "\
     "-f 'if(y==0&&i>=97&&i<=122,i-32,i)' "

  # Copy latest command definitions on sourceforge server if necessary.
  -if {$1==@.}
    -v + -e[] "> Upload latest version of commands on Sourceforge server.\n" -v -
    -x "scp "$HOME/work/src/gmic/src/gmic_def.gmic" ronounours,gmic@web.sourceforge.net:htdocs/gmic_def."$1
  -endif

  # Get command source files and archive them.
  -v + -e[] "> Load and archive .gmic source files.\n" -v -
  _nb_sources=0
  -load_gmic http://gmic.sourceforge.net/gmic_def.$1
  -load_gmic http://gmic.sourceforge.net/compatibility.gmic
  -load_gmic http://s406833247.websitehome.co.uk/gmic/garagecoder.gmic
  -load_gmic http://gentlemanbeggar.bplaced.net/gentlemanbeggar_gmic.gmic
  -load_gmic http://www.iain.bplaced.net/iain_fergusson.gmic
  -load_gmic http://www.h-ps.demon.co.uk/GMIC/jayprich.gmic
  -load_gmic https://raw.github.com/jboulanger/jboulanger-gmic/master/jboulanger.gmic
  -load_gmic http://karo03.bplaced.net/gmic/karos.gmic
  -load_gmic http://www.saunalahti.fi/naggobot/naggobot.gmic
  -load_gmic http://gmic.sourceforge.net/photocomix.gmic
  -load_gmic http://gmic.sourceforge.net/ronounours.gmic
  -load_gmic http://gmic.sourceforge.net/samj.gmic
  -load_gmic http://gmic.sourceforge.net/tomkeil.gmic
  -load_gmic http://docgmic.tuxfamily.org/zonderr.gmic

  # Merge them together.
  -i[0] (10) -i[2--1] ({"'\n#@gimp ________________\n'"}) -y -a y -discard 13
  -s +,{'"#@gimp"'}
  -repeat {int((@#-1)/2)} -a[{$>+1},{$>+2}] y -done
  -nm[0] !header

  # Parse filter tree.
  -v + -e[] "> Start source parsing.\n" -v -
  progress_factor={100/(@#-1)}
  merge_request=0
  merge_start=0
  nb_filters=0
  offset=0
  path=/

  -repeat @#
    ind={$>-$offset}
    -if {@{{$ind-1},-1}==10" && "{{`@{$ind,0-5}`}'=='"#@gimp"}" && "(@{$ind,6}==32" || "@{$ind,6}=={'_'})} -l[$ind] # Line starts by '#@gimp[_] '

      is_folder=0
      -s +,10
      -if {@{0,6}=={'_'}} --rows[0] 9,100% -rows[0] 0,8 # Treat a localized filter as a regular filter.
      -else --rows[0] 6,100% -rows[0] 0,5
      -endif
      -autocrop[-1] 32 -mv[-1] 1

      -if {@{1,0}!={':'}} # Found a new filter or folder definition.
        -l[1]

          # Format string by removing special character sequences.
          -s +,{':'}
          -replace_seq[0] @{-quote\ {'<b>'}},32
          -replace_seq[0] @{-quote\ {'</b>'}},32
          -replace_seq[0] @{-quote\ {'<i>'}},32
          -replace_seq[0] @{-quote\ {'</i>'}},32
          -replace[0] {'/'},{'-'}
          -replace[0] {','},{';'}
          -autocrop[0] 32

          -if {@#>1} # Found new filter.
            -calibrate_name[0] --replace[0] 32,{'~'} name=$path@{-1,t} -rm[-1]
            merge_request=1
            nb_filters={$nb_filters+1}
            -i[0,1] (32) -a y
            -v + -e[] "  "$nb_filters". "$name" ("{round($>*$progress_factor)}"%)." -v -

          -else # Found new folder (opt. parent(s)).
            -if {i=={'_'}} # Folder has parents before creating it.
              -do path=@{"-parent[] "$path} -shift 0,-1,0,0 -while {i=={'_'}}
              -autocrop 0 -autocrop 32
              -if {w} -calibrate_name -replace 32,{'~'} path=$path@{0,t}/ -endif # Folder name specified after the underscore(s).
            -else # Folder name don't start with '_'.
              -autocrop 32 -calibrate_name -replace 32,{'~'} path=$path@{0,t}/
            -endif
            is_folder=1

          -endif # -if {@#>1}
        -endl # -l[-1]

        -if $is_folder -rm[0,1] -i[0] (10) # Discard folder definition (will be recreated afterwards).
        -else -nm[0] $name -endif

      -else # Found possibly a filter argument.

        -if {@#>=3} -l[1]
          -s +,{'='}
          -if {@#>=3} -if {@{1,0}=={'='}}
            -rows[0] 1,100% -calibrate_name[0]
            -i[0] ({':'};32) -i[2] (32)
          -endif -endif
        -endl -endif
        -i[1] (32)

      -endif # -if {i!={':'}}
      -a y

    -endl -endif

    -if {$merge_request" && "$ind>0} # Merge previous lines.
      -a[$merge_start-{$ind-1}] y
      offset={$offset+$ind-$merge_start-1}
      merge_start={$merge_start+1}
      merge_request=0
    -endif

  -done

  -a[$merge_start--1] y # Final merge.

  # Force filters to move if necessary.
  -v + -e[] "\n> Force filters to move, if necessary." -v -
  -repeat @# ind=$> -repeat $_nbm -if {@{$ind,n}'=='${_to_move$>}}
   -v + -e[] "  "$ind". Move '"@{$ind,n}"' to '"${_move_to$>}"'." -v -
   -name[$ind] ${_move_to$>}/@{$ind,b}
  -endif -done -done

  # Sort filter code by lexicographical order.
  -v + -e[] "\n> Sort filters by lexicographic order." -v -
  -_update_gmic_gimp_sort 0,{@#-1}

  # Remove duplicate filters.
  -v + -e[] "\n> Remove duplicate filters." -v -
  pname=@{-1,n}
  -repeat {@#-1} cname=@{$<,n}
    -if {$cname'=='$pname}
      -v + -e[] "  "$<". Remove duplicate '"$cname"'." -v -
      -rm[$<]
    -else pname=$cname -endif
  -done

  # Rebuild folder structure.
  -v + -e[] "\n> Rebuild folder structure." -v -
  -m "nb_levels : -l[] ({'$""1'}) -s -,{'/'} -u @# -rm -endl"  # Command to count number of folders in a given path.

  path=/
  -repeat @# -l[$>]
    npath=@{"-parent "@{0,n}}

    -if {$path'!='$npath} # Need to change the path.
      nc=@{"-nb_levels[] "$path}
      nn=@{"-nb_levels[] "$npath}

      # Get the minimal basis path in common and the number of up/down operations.
      nb_up=0
      nb_down=0
      basis=$path nbasis=$npath
      -do
        nc=@{"-nb_levels[] "$basis}
        nn=@{"-nb_levels[] "$nbasis}
        -if {$nc>$nn} basis=@{"-parent[] "$basis} nb_up={$nb_up+1}
        -elif {$nn>$nc} nbasis=@{"-parent[] "$nbasis} nb_down={$nb_down+1}
        -elif {$nbasis'!='$basis} basis=@{"-parent[] "$basis} nb_up={$nb_up+1} nbasis=@{"-parent[] "$nbasis} nb_down={$nb_down+1}
        -endif
      -while {$nbasis'!='$basis}

      # Deduce the G'MIC command to apply.
      command=
      -if $nb_up 1,$nb_up,1,1,{'_'} command="#@gimp "@{-1,t}"\n" -rm[-1] -endif
      -if $nb_down -l[]
        ({'$npath'}) -s -,{'/'} -k[-$nb_down--1] -replace {'~'},32
        level={@{"-nb_levels "$path}-$nb_up}
        balise=@{"-if "{$level<=0" && "{$npath'!='/About/}}" -u b -else -u i -endif"}
        -repeat @#
          command=$command"#@gimp <"$balise">"@{$>,t}"</"$balise">\n"
          balise="i"
        -done -rm
      -endl -endif
      -if {narg($command)} name=@{0,n} -i[0] ({'$command'}) -y[0] -a y -nm $name
      -endif

      path=$npath
    -endif

  -endl -done

  # Save reordered .gmic file.
  -v + -e[] "> Save output .gmic file.\n" -v -
  --a y -if {h>1} -r[-1] 1,{h-1},1,1,0,0,0,1 -endif # Remove leading '\n'.
  -o[-1] raw:$HOME/.update$1.gmic,uchar
  -x "scp "$HOME/.update$1.gmic" ronounours,gmic@web.sourceforge.net:htdocs/"update$1.gmic
  -rm[-1]

  # Display list of filters (sorted alphabetically) on stdout.
  -if $2
    -v + -e[] "> Output list of filters in stdout.\n" -v -
    -exec "date +%Y,%m,%d >"@{-path_tmp}/date.dlm
    @{-path_tmp}/date.dlm
    -echo_stdout "*** List of filters in the G'MIC plug-in for GIMP ("$nb_filters" filters, on "{i}/{i(1)}/{i(2)}") ***\n"
    -rm[-1]
    -echo_stdout "* List of filters, sorted by path:\n"
    -repeat @# -l[$>]
      ({'@{0,n}'}) -if {i!={'!'}}
        -r[-1] {w-1},1,1,1,0,0,1
        -replace_seq[-1] @{-quote\ {'&amp;'}},{'&'}
        -replace_seq[-1] @{-quote\ {'"&#233;"'}},{'e'}
        -replace_seq[-1] {'/'},@{-quote\ {'~/~'}}
        -replace[-1] {'~'},32
        -echo_stdout[] "  "@{-1,t}
      -endif -rm[-1]
    -endl -done
    -echo_stdout "\n* List of filters, sorted alphabetically:\n"
    -repeat @#
      name=@{$>,b}
      path=@{$>,f}
      -nm[$>] $name"~(in~'"$path"')"
    -done
    -_update_gmic_gimp_sort 0,{@#-1}
    -repeat @# -l[$>]
      ({'@{0,n}'}) -if {i!={'!'}}
        -replace_seq[-1] @{-quote\ {'&amp;'}},{'&'}
        -replace_seq[-1] @{-quote\ {'"&#233;"'}},{'e'}
        -replace[-1] {'~'},32
        -echo_stdout[] "  "@{-1,t}
      -endif -rm[-1]
    -endl -done
    -echo_stdout "\n*** End of list ***\n"
  -endif

  # All done, exiting.
  -rm -v + -e[] "> All done !\n"

# String sorting algorithm (quicksort).
_update_gmic_gimp_sort :
  mid={int(($1+$2)/2)}
  -if @{"-_max[] "@{$1,n},@{$mid,n}} -rv[$1,$mid] -endif
  -if @{"-_max[] "@{$mid,n},@{$2,n}} -rv[$2,$mid] -endif
  -if @{"-_max[] "@{$1,n},@{$mid,n}} -rv[$1,$mid] -endif
  -if {$2-$1>=3}
    pivot=@{$mid,n}
    i=$1 j=$2
    -do
      -if @{"-_max[] "$pivot,@{$i,n}} -do i={$i+1} -while @{"-_max[] "$pivot,@{$i,n}} -endif
      -if @{"-_max[] "@{$j,n},$pivot} -do j={$j-1} -while @{"-_max[] "@{$j,n},$pivot} -endif
      -if {$i<=$j} -rv[$i,$j] i={$i+1} j={$j-1} -endif
    -while {$i<=$j}
    -if {$1<$j} -_update_gmic_gimp_sort $1,$j -endif
    -if {$i<$2} -_update_gmic_gimp_sort $i,$2 -endif
  -endif

_update_gmic_gimp_move :
  -if {!narg($_nbm)} _nbm=0 -endif
  _to_move${_nbm}="$1" _move_to${_nbm}="$2" _nbm={$_nbm+1}

# Generate a splitted preview, with arguments "command",_split_type.
# 'split_type' can be { 0=no split | 1=forw. horiz. | 2=forw. vert. | 3=back. horiz. | 4=back. vert. | 5=dupl. horiz. | 6=dupl. vert. }
_before :
  33,11 -t[-1] "Before",1,-1,13,1,1
_after :
  26,11 -t[-1] "After",1,-1,13,1,1

gimp_split_preview :
  -repeat @#
    -if {$2==0} -e[] "$1" -l[-1] $1 -endl -mv[-1] 0 -continue -endif  # No split.
    -if {!($2%2)} # Vertical split.
      -s[-1] x,2
      -if {$2==2} -l[-1] $1 -endl -to_colormode[-2,-1] 0 -_before -_after    # Forward vertical.
      -elif {$2==4} -l[-2] $1 -endl -to_colormode[-2,-1] 0 -_after -_before  # Backward vertical.
      -else -rm[-1] --l[-1] $1 -endl -to_colormode[-2,-1] 0 -_before -_after # Duplicate vertical.
      -endif
      -line[-3] 0,0,0,@{-3,h},1,0,0,0,255 -a[-4,-3] x
    -else # Horizontal split.
      -s[-1] y,2
      -if {$2==1} -l[-1] $1 -endl -to_colormode[-2,-1] {max(@{-2,s},s)} -_before -_after   # Forward horizontal.
      -elif {$2==3} -l[-2] $1 -endl -to_colormode[-2,-1] {max(@{-2,s},s)} -_after -_before # Backward horizontal.
      -else -rm[-1] --l[-1] $1 -endl -to_colormode[-2,-1] 0 -_before -_after               # Duplicate horizontal.
      -endif
      -line[-3] 0,0,@{-3,w},0,1,0,0,0,255 -a[-4,-3] y
    -endif
    --dilate[-2,-1] 3 -*[-4,-3] 255 -to_colormode[-4,-3] @{-5,s} # If splited, display "before/after" text.
    -j[-5] [-4],1,1,0,0,0.8,[-2] -j[-5] [-3],{@{-5,w}-w-1},{@{-5,h}-h-1},0,0,0.8,[-1]
    -rm[-4--1]
  -mv[-1] 0 -done

# Generate a 'no-preview' image.
gimp_no_preview :
  -_gimp_no_preview "No preview\navailable","$*"

_gimp_no_preview :
  -if {@#>0} -k[0] -else 256,256,1,1,128 -endif
  118,50 -t[-1] "$1",2,1,24,1,255 -r[-1] [-2],[-2],1,1,0,0,0.5,0.5 -to_colormode[-1] @{-2,s}
  (1.5,0,1.5;0,0,0;1.5,0,1.5) -r[-1] [-3],3 -*[-3,-1] -c[-2] 0,255 -or
  -skip "$*"

# Do not forget to ucomment this entry for a deprecated version of the G'MIC plug-in!
# #@gimp <span foreground="red"><b>  UPDATE INFORMATION</b></span> : _none_, gimp_logo_en
# #@gimp : note = note{"A <b>new version</b> of the G'MIC plug-in for GIMP is available!
# #@gimp : You are strongly encouraged to download and install this updated version, by clicking on one of the following urls :"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Windows version :</u></span>"}
# #@gimp : url = link{"Download G'MIC plug-in for Windows (32 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_win32.exe"}
# #@gimp : url = link{"Download G'MIC plug-in for Windows (64 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_win64.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them into folder\n
# #@gimp :              <i>C:\\Program Files\\GIMP\\lib\\gimp\\2.0\\plug-ins\</i>"}
# #@gimp : note = note{"\n<span foreground="purple"><u>Linux version :</u></span>"}
# #@gimp : url = link{"Download plug-in for Linux (32 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_linux32.zip"}
# #@gimp : url = link{"Download plug-in for Linux (64 bits)","http://downloads.sourceforge.net/gmic/gmic_gimp_linux64.zip"}
# #@gimp : note = note{"<b>Installation </b>: unzip the archive files and copy them in folder\n
# #@gimp :              <i>/usr/lib/gimp/2.0/plug-ins/</i>"}
# #@gimp : note = note{"\nNote that there will be no updated filters anymore for your current plug-in version.
# #@gimp : Installing the G'MIC plug-in for GIMP is easy and fast, so there are no reasons not for doing it :).\n\n
# #@gimp : Best regards,\n\n <i>The G'MIC team.</i>"}


#----------------------
# English translations
#----------------------

#@gimp _<b>About</b>
#-------------------

#@gimp_en G'MIC for GIMP : _none_, gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nis proposed to you by"}
#@gimp_en : note = link("David Tschumperl\303\251","http://tschumperle.users.greyc.fr/")
#@gimp_en : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_en : note = note{"
#@gimp_en : This plug-in is based on our open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_en : available at:"}
#@gimp_en : note = link("http://gmic.sourceforge.net/")
#@gimp_en : note = note{"and"}
#@gimp_en : note = link("http://cimg.sourceforge.net/")
#@gimp_en : note = note{"\n
#@gimp_en : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at:\n\n
#@gimp_en : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_en :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_en : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gimp_en : "}
gimp_logo : -skip "${1=Plug-in for GIMP}"
  -if @# -k[0] -endif
  -to_rgb 0 -t[-1] "G'MIC",0,0,57,1,1 -label[-1]
  6,1,1,3 -rand[-1] 150,255 -point[-1] 0 -map[-2] [-1] -rm[-1]
  -expand_xy[-1] 10,0 -b[-1] 2 -r[-1] 200%,200%,1,3,6 -sqr[-1] -c[-1] 0,60% -n[-1] 0,255
  -warp_perspective[-1] 0.5,0,1,50,50,0 -shift[-1] 0,-10
  100%,100% -noise[-1] 0.8,2 -*[-1] 180 --blur_linear[-1] 20,0,45,0 -*[-1] 20 -max[-3--1]
  -sh[-1] 2,2 (0;128) -r[-1] [-2],3 -+[-2,-1] -min[-1] 255 -rm[-1]
  -text_outline[-1] "$1",32%,75%,13,3,1,255 -frame[-1] 1,1,128 -mv[-1] 0
  -if {@#>1} -*[^0] 0.45 -repeat {@#-1} -j[-1] [0],{(w-@{0,w})/2},{(h-@{0,h})/2} -mv[-1] 1 -done -rm[0] -endif

gimp_logo_old :
  -if @# ratio={w/h} -else ratio=1 -endif
  -rm 118,44,1,1 -t "G'MIC",3,-6,57,1,255 -r 100%,100%,10,1 -r 100%,100%,20,1,0,0,0.5,0.5,0.5 -b 1.5
  -isosurface3d 50%
  -col3d {?(150,255)},{?(150,255)},{?(150,255)}
  -sphere3d 8 -col3d[-1] {?(150,255)},{?(150,255)},{?(150,255)} -+3d[-1] 72,-6 -+3d -c3d[-1] -rv3d
  -db3d 0 -sl3d 0.2 -ss3d 1.3 -r3d[-1] 1,0,0,30 -f3d 120 -*3d[-1] 1.5
  230,120,1,3 -object3d[-1] [-2],50%,30%,0,1,4 -rm[-2] -t "$1",12%,75%,24,1,255
  -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -drop_shadow 6,6,2
  -i[-2] @{-fitratio_wh\ 230,120,$ratio},1,3
  -rand[-2] 0,255 -sh[-2] 0,0 -/[-1] 2 -rm[-1]
  -blur_radial[-2] 10 -sharpen[-2] 600
  -r[-1] [-2],[-2],1,4,0,0,0.5,0.5 -blend alpha

gimp_logo_en :
  -gimp_logo "Plug-in for GIMP\n     "[@{-strver}]

#---------------------
# French translations
#---------------------

#@gimp_fr G'MIC pour GIMP : _none_, gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\nvous est proposé par"}
#@gimp_fr : note = link("David Tschumperl\303\251","http://tschumperle.users.greyc.fr/")
#@gimp_fr : note = link{"( Equipe IMAGE / Laboratoire GREYC - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_fr : note = note{"
#@gimp_fr : Ce greffon est bas&#233; sur nos biblioth&#232;ques libres <b>G'MIC</b> et <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_fr : disponibles aux adresses :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/")
#@gimp_fr : note = note{"et"}
#@gimp_fr : note = link("http://cimg.sourceforge.net/")
#@gimp_fr : note = note{"\n
#@gimp_fr : Si vous appr&#233;ciez <b>G'MIC</b>, vous pouvez nous le faire savoir en nous envoyant une jolie carte
#@gimp_fr : postale de votre ville ou r&#233;gion, &#224; l'adresse :\n\n
#@gimp_fr : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_fr :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_fr : Envoyer une carte postale vous fera rentrer <i>de facto</i> dans le <i>Friends Hall of Fame</i> :) !
#@gimp_fr : "}
gimp_logo_fr :
  -gimp_logo "Greffon pour GIMP\n     "[@{-strver}]

#----------------------
# Catalan translations
#----------------------

#@gimp_ca G'MIC per al GIMP : _none_, gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing )</span>\n\n &#233;s una gentilesa de"}
#@gimp_ca : note = link("David Tschumperl\303\251","http://tschumperle.users.greyc.fr/")
#@gimp_ca : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_ca : note = note{"
#@gimp_ca : Aquest connector est&#224; basat en les biblioteques de codi obert <b>G'MIC</b> i <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_ca : disponibles a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/")
#@gimp_ca : note = note{"i"}
#@gimp_ca : note = link("http://cimg.sourceforge.net/")
#@gimp_ca : note = note{"\n
#@gimp_ca : Si t'agrada el <b>G'MIC</b>, pots enviar-nos una postal del lloc on vius, a :\n\n
#@gimp_ca : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_ca :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_ca : Tot aquell que envi&#239; una postal apareixer&#224; al <i>Friends Hall of Fame</i> :) !
#@gimp_ca : "}
gimp_logo_ca :
  -gimp_logo "  per al GIMP\n     "[@{-strver}]

#----------------------
# Untranslated filters
#----------------------

#@gimp Contributors : _none_, _none_
#@gimp : note = note{"
#@gimp : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gimp : A big hug to : \n\n
#@gimp : <b> -</b> <i>Sylvie Alexandre</i> <small>(packaging, testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Partha Bagchi</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>S&#233;bastien Bougleux</i> <small>(debugging)</small>
#@gimp : <b> -</b> <i>J&#233;rome Boulanger</i> <small>(testing &amp; code)</small>
#@gimp : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Aur&#233;lien Ceyden</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gimp : <b> -</b> <i>Patrick David</i> <small>(testing)</small>
#@gimp : <b> -</b> <i>Maxime Daisy</i> <small>(code &amp; testing)</small>
#@gimp : <b> -</b> <i>Iain Fergusson</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>Roberto Ferramosca</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing, code &amp; tutorials)</small>
#@gimp : <b> -</b> <i>Chris Fiedler</i> <small>(gfx)</small>
#@gimp : <b> -</b> <i>S&#233;bastien Fourey</i> <small>(ZArt code &amp; G'MIC online)</small>
#@gimp : <b> -</b> <i>Gentlemanbeggar</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>Claes Holmerson</i> <small>(tutorials)</small>
#@gimp : <b> -</b> <i>Arto Huotari</i> <small>(filters)</small>
#@gimp : <b> -</b> <i>Dan Leinir Turthra Jensen</i> <small>(debugging)</small>
#@gimp : <b> -</b> <i>Tom Keil</i> <small>(testing, filters &amp; tutorials)</small>
#@gimp : <b> -</b> <i>Andy Kelday</i> <small>(testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Angelo Lama</i> <small>(testing &amp; EKD integration)</small>
#@gimp : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gimp : <b> -</b> <i>Mark</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Mahvin</i> <small>(testing &amp; design)</small>
#@gimp : <b> -</b> <i>MareroQ</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Ramon Miranda</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Mauro Quercia</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>PhotoComiX</i> <small>(testing, translation &amp; filters)</small>
#@gimp : <b> -</b> <i>James Prichard</i> <small>(testing &amp; filters)</small>
#@gimp : <b> -</b> <i>Guilherme Razgriz</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Karsten Rodenacker</i> <small>(packaging &amp; code)</small>
#@gimp : <b> -</b> <i>Dani Sard&#224;</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Yuri Shemanin</i> <small>(debugging)</small>
#@gimp : <b> -</b> <i>Thorsten "otto" Stettin</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Stepanekos</i> <small>(translation)</small>
#@gimp : <b> -</b> <i>Bernd Zeimetz</i> <small>(packaging)</small>
#@gimp : <b> -</b> <i>Matthias Zepper</i> <small>(testing)</small>
#@gimp : <b> -</b>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/03/30</i>.</small>")

#@gimp Filter design : _none_, _none_
#@gimp : note = note{"
#@gimp : <b>G'MIC</b> is an <b>open</b> image processing framework. Thus, including
#@gimp : <b>user-defined filters</b> into this plug-in is possible.\n\n
#@gimp : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span>
#@gimp : file in your <i>Home</i> folder (or <i>Applications Data/</i> on Windows, without the first dot).
#@gimp : It will be read each time the plug-in is launched, or when the <i>Refresh</i>
#@gimp : button (under the central pane) is pressed. It must be a regular ASCII file, containing the declarations and
#@gimp : implementations of the filters (written in the <b>G'MIC</b> language) that will be added
#@gimp : to the list of available ones."}
#@gimp : note = note{"
#@gimp : Existing filters are already defined this way.
#@gimp : Writing a filter from scratch in <b>G'MIC</b> requires some skills, but
#@gimp : can be generally done in very few lines.\n\n
#@gimp : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> entry :</span>"}
#@gimp : note = note{"<tt>#@gimp My effect : my_effect, my_effect</tt>"}
#@gimp : note = note{"<tt>#@gimp : Sigma = float(2,0,10)</tt>"}
#@gimp : note = note{"<tt>my_effect :\n     --blur $1 -n 0,255 -xor</tt>"}
#@gimp : note = note{"
#@gimp : Look at the reference documentation to learn more.
#@gimp : By the way, you are encouraged to share your nice custom filters with us on our forums,
#@gimp : for inclusion into next releases of <b>G'MIC</b>.
#@gimp : "}
#@gimp : sep = separator()
#@gimp : note = link(0,"[1] G'MIC reference documentation","http://gmic.sourceforge.net/reference.shtml");
#@gimp : note = link(0,"[2] G'MIC on Flickr","http://www.flickr.com/groups/gmic/discuss/")
#@gimp : note = link(0,"[3] G'MIC on GimpChat","http://www.gimpchat.com/viewforum.php?f=28")
#@gimp : note = link(0,"[4] G'MIC on Google+","https://plus.google.com/117441237982283011318/posts")

#@gimp Filter sources : _none_, gimp_display_filter_sources
#@gimp : note = note{"Here you can see the filter sources currently enabled in your plug-in.
#@gimp : For most users, there will be only one URL listed there."}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/03</i>.</small>")
gimp_display_filter_sources :
  -if @# -k[0] -f 0 -else 256,256 -endif
  -l[] -gimp_filter_sources -y x -a y -onfail (0) -endl
  -text[0] "Enabled external sources:\n--------------------------------",5,5,13,1,255
  -if @{-is_windows} path=@{-path_user}/ -else path=@{-path_user}/. -endif
  i=1 -repeat {h}
    --rows[-1] $>
    -if {@{-1,0-3}'=='{'http'}}
      -text[0] [$i]" "@{-1,t},5,{32+15*$i},13,1,255 i={$i+1}
    -else
      -if $path@{-1,t} -text[0] [$i]" "@{-1,t}" (local file)",5,{32+15*$i},13,1,255 i={$i+1} -endif
    -endif
    -rm[-1]
  -done
  -rm[-1]

#@gimp Friends Hall of Fame : _none_, gimp_friends
#@gimp : note = note{"\n<span foreground="purple" underline="single">Donators :</span>"}
#@gimp : note = note{" <b>-</b> We've received <b>16</b> donations from <b>G'MIC</b> mega-enthusiasts so far.
#@gimp :               You could be the 17th donator :)"}
#@gimp : note = note{"<b><small>Note:</small></b> Donations are mainly used to help us making G'MIC more visible
#@gimp :              (cover expenses for open-source events, for instance). Also, it will motivate
#@gimp :              us to design more new image filters and effects. Feel free to donate
#@gimp :              if you appreciate G'MIC, by clicking on:"}
#@gimp : link = link{"Make a donation to the G'MIC project","http://sourceforge.net/donate/index.php?group_id=234931"}
#@gimp : sep = separator()
#@gimp : note = note{" <b>-</b> A big hug goes to these donators (recently received first) :"}
#@gimp : link = link(0,"[1] Matthias Zepper","http://www.matthias-zepper.de/")
#@gimp : link = link(0,"[2] Christian Mariucci","")
#@gimp : link = link(0,"[3] M. R.","")
#@gimp : link = link(0,"[4] Mark Link","")
#@gimp : link = link(0,"[5] Rolf Steinort","http://blog.meetthegimp.org/")
#@gimp : link = link(0,"[6] Pat David","http://blog.patdavid.net/")
#@gimp : link = link(0,"[7] Daniel Tauro","https://plus.google.com/112357088505488756823/posts")
#@gimp : link = link(0,"[8] Ben Langhinrichs","http://geniisoft.com/")
#@gimp : link = link(0,"[9] Paolo Pedaletti","http://www.openlabs.it/")
#@gimp : link = link(0,"[10] Ricardo Corin","http://blog.photomontager.com")
#@gimp : link = link(0,"[11] James Prichard","https://plus.google.com/115953666279509959258")
#@gimp : link = link(0,"[12] Matt Jones","https://plus.google.com/116658221461047313647")
#@gimp : link = link(0,"[13] Eddy Vervest","http://www.flickr.com/people/twekkel/")
#@gimp : link = link(0,"[14] Steven Shupe","http://www.flickr.com/photos/ssshupe/")
#@gimp : link = link(0,"[15] Flavio Casadei Della Chiesa","http://www.flaviocdc.net/wiki/")
#@gimp : link = link(0,"[16] Lyle Kroll","http://www.artwanted.com/artist.cfm?artid=10918")
#@gimp : sep = separator()
#@gimp : note = note{"\n<span foreground="purple" underline="single">Postcard senders :</span>"}
#@gimp : note = note{" <b>-</b> We've received <b>21</b> postcards from <b>G'MIC</b> enthusiasts so far.
#@gimp :               You could be the 22th sender :)"}
#@gimp : note = note{" <b>-</b> A big hug goes to these postcard senders (recently received first) :"}
#@gimp : link = link(0,"[1] Akky [Gimpchat] - Australia","http://cimg.sourceforge.net/img/postcard47.jpg")
#@gimp : link = link(0,"[2] Michel Thomas - Germany","http://cimg.sourceforge.net/img/postcard45.jpg")
#@gimp : link = link(0,"[3] Pierre-Yves - Ile de Batz/France","http://cimg.sourceforge.net/img/postcard44.jpg")
#@gimp : link = link(0,"[4] Family Hamacher - Trier/Germany","http://cimg.sourceforge.net/img/postcard43.jpg")
#@gimp : link = link(0,"[5] Benoit Gauzere and Francois Lozes - Hokusai/Japan","http://cimg.sourceforge.net/img/postcard41.jpg")
#@gimp : link = link(0,"[6] Dr. Rainer Teubner - Seligenstadt/Germany","http://cimg.sourceforge.net/img/postcard40.jpg")
#@gimp : link = link(0,"[7] Mauro Mitrino - Mantova/Italy","http://cimg.sourceforge.net/img/postcard39.jpg")
#@gimp : link = link(0,"[8] Werner Meier - Mettlach/Germany","http://cimg.sourceforge.net/img/postcard37.jpg")
#@gimp : link = link(0,"[9] Arto Huotari - Helsinki/Finland","http://cimg.sourceforge.net/img/postcard36.jpg")
#@gimp : link = link(0,"[10] Benoit Gauzere - California/USA","http://cimg.sourceforge.net/img/postcard33.jpg")
#@gimp : link = link(0,"[11] Arkadi Gelfond - Foster City - California/USA","http://cimg.sourceforge.net/img/postcard30.jpg")
#@gimp : link = link(0,"[12] Corinne Masimann - Neuchatel/Switzerland","http://cimg.sourceforge.net/img/postcard29.jpg")
#@gimp : link = link(0,"[13] Mahvin - Portland/USA","http://cimg.sourceforge.net/img/postcard27.jpg")
#@gimp : link = link(0,"[14] Vincent Roullier - Caen/France","http://cimg.sourceforge.net/img/postcard26.jpg")
#@gimp : link = link(0,"[15] M???? - Munich/Germany","http://cimg.sourceforge.net/img/postcard24.jpg")
#@gimp : link = link(0,"[16] F. Albior - Jaca/Spain","http://cimg.sourceforge.net/img/postcard23.jpg")
#@gimp : link = link(0,"[17] PhotoComIX - Frascati/Italy","http://cimg.sourceforge.net/img/postcard22.jpg")
#@gimp : link = link(0,"[18] Guy Poizat - Cabestany/France","http://cimg.sourceforge.net/img/postcard21.jpg")
#@gimp : link = link(0,"[19] Institut for Biomathematik und Biometrie - Neuherberg/Germany","http://cimg.sourceforge.net/img/postcard20.jpg")
#@gimp : link = link(0,"[20] Jaime - Barcelona/Spain","http://cimg.sourceforge.net/img/postcard14.jpg")
#@gimp : link = link(0,"[21] Jean-Michel Webbe - Guadeloupe/France","http://cimg.sourceforge.net/img/postcard15.jpg")
#@gimp : sep = separator()
#@gimp : note = note{"\nMay the force be with you!"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/04/26</i>.</small>")
gimp_friends :
  -if @# ratio={w/h} -else ratio=1 -endif
  -rm -_heart80x73 -scale3x -r 150%,150%,1,1,0,0,0.5,0.5
  --*[-1] 70 --*[-2] 110 --*[-3] 255 -*[-4] 255 -a c
  -blur_radial 4 -sharpen 300
  -i[-2] @{-fitratio_wh\ {w},{h},$ratio},1,3
  -rand[-2] 0,255 -sh[-2] 1,2 -/[-1] 2 -rm[-1]
  -blur_radial[-2] 10 -sharpen[-2] 600
  -r[-1] [-2],[-2],1,4,0,0,0.5,0.5 -blend alpha
  135,67,1,1,0 -t[-1] "Greetings to\n  all G'MIC\n  friends!",2,-2,24,1,1
  --dilate[-1] 3 -*[-2] 255 -to_rgb[-2] -j[-3] [-2],{(@{-3,w}-@{-2,w})/2},{(@{-3,h}-@{-2,h})/2.2},0,0,1,[-1]
  -rm[-2,-1]

_heart80x73 :
  40,73,1,1,0 -ellipse 22,22,20,20,0,1,1 -polygon 3,7,37,42,72,42,27,1,1 --mirror x -a x

#@gimp Gmicky / Roddy : gimp_gmicky, gimp_gmicky_preview
#@gimp : Mascot image = choice("Gmicky","Gmicky & Wilber","Roddy")
#@gimp : sep = separator()
#@gimp : note = note{"<b><i>Gmicky</i></b> is the name of the <b>G'MIC</b> mascot. He is a small and cute tiger who knows how to do magic.
#@gimp : <b><i>Gmicky</i></b> is a tiger, i.e. fast, agile and elegant, just as the <b>G'MIC</b> code is :).
#@gimp : As many magicians, <b><i>Gmicky</i></b> knows lot of gimmicks (<b>G'MIC</b>), and he is a direct and friendly competitor of
#@gimp : the ImageMagick's wizard, or the GraphicMagick's frog."}
#@gimp : note = note{"<b><i>Roddy</i></b> is another mascot designed specifically for the <i>Artistic / Rodilius</i> filter of <b>G'MIC</b>."}
#@gimp : note = note{"<b><i>Gmicky</i></b> and <b><i>Roddy</i></b> have been designed by "}
#@gimp : link = link("Mahvelous Mahvin","http://www.mahvin.com/")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Mahvin</i>.      Latest update: <i>2011/05/27</i>.</small>")
gimp_gmicky :
  -rm
  -if {$1==0} -gmicky
  -elif {$1==1} -gmicky_wilber
  -else -roddy
  -endif

gimp_gmicky_preview :
  w={w} h={h} -rm
  -if {$1==0}
    filename=@{-path_tmp}/gmicky_small.cimgz
    url=http://gmic.sourceforge.net/img/gmicky_small.cimgz
  -elif {$1==1}
    filename=@{-path_tmp}/gmicky_wilber_small.cimgz
    url=http://gmic.sourceforge.net/img/gmicky_wilber_small.cimgz
  -else
    filename=@{-path_tmp}/roddy_small.cimgz
    url=http://gmic.sourceforge.net/img/roddy_small.cimgz
  -endif
  -if $filename $filename -else -i $url -o $filename -endif
  -r2dy $h -- 255 -r $w,$h,1,3,0,0,0.5,0.5 -+ 255

#@gimp Links : _none_, _none_
#@gimp : note = note{"
#@gimp : Here is a list of links that might help you in finding additional information about the G'MIC project.
#@gimp : "}
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Documentation:</b></small>")
#@gimp : note = link{0,"Official G'MIC wiki.","https://sourceforge.net/p/gmic/wiki/Home/"}
#@gimp : note = link{0,"Screenshots of some of the plug-in filters.","http://gmic.sourceforge.net/gimp.shtml"}
#@gimp : note = link{0,"List of available plug-in filters.","http://gmic.sourceforge.net/gimp_filters.txt"}
#@gimp : note = link{0,"Reference documentation of the G'MIC language (html).","http://gmic.sourceforge.net/reference.shtml"}
#@gimp : note = link{0,"Reference documentation of the G'MIC language (pdf).","http://gmic.sourceforge.net/gmic_reference.pdf"}
#@gimp : sep = separator()
#@gimp : note = note("<small><b>News / Communities:</b></small>")
#@gimp : note = link{0,"G'MIC news on Google+.","https://plus.google.com/117441237982283011318/posts"}
#@gimp : note = link{0,"G'MIC community on Google+.","https://plus.google.com/u/0/b/117441237982283011318/communities/100367598461382347439"}
#@gimp : note = link{0,"G'MIC community on GimpChat.","http://www.gimpchat.com/viewforum.php?f=28"}
#@gimp : note = link{0,"G'MIC community on Flickr.","http://www.flickr.com/groups/gmic/discuss/"}
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/12/17</i>.</small>")

#@gimp Release notes : _none_, _none_
#@gimp : note = note{"
#@gimp : - <b>2009/01/13</b> : version <i>1.3</i> (initial plug-in release).\n
#@gimp : - <b>2010/09/03</b> : version <i>1.4</i>.\n
#@gimp : - <b>2011/07/07</b> : version <i>1.5.0.0</i>.\n
#@gimp : - <b>2012/03/01</b> : version <i>1.5.1.0</i>.\n
#@gimp : - <b>2012/10/15</b> : version <i>1.5.2.0</i>.\n
#@gimp : - <b>2013/01/07</b> : version <i>1.5.3.0</i>.\n
#@gimp : - <b>2013/01/28</b> : version <i>1.5.4.0</i>.\n
#@gimp : - <b>2013/03/08</b> : version <i>1.5.5.0</i>.\n
#@gimp : - <b>2013/06/03</b> : version <i>1.5.6.0</i>.\n
#@gimp : - <b>2013/09/09</b> : version <i>1.5.7.0</i>.\n
#@gimp : - <b>2013/12/07</b> : version <i>1.5.8.0</i>.\n
#@gimp : - <span foreground="purple"><b>2014/01/08</b> : version <i>1.5.8.2</i> (Current stable).</span>\n
#@gimp : "}
#@gimp : link = link("View latest changelog","http://www.flickr.com/groups/gmic/discuss/72157638741634925/")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2014/01/08</i>.</small>")

#@gimp _<b>Arrays &amp; tiles</b>
#--------------------------------

#@gimp Array [faded] : gimp_array_fade, gimp_array_fade_preview(1)
#@gimp : X-tiles = int(2,1,10)
#@gimp : Y-tiles = int(2,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Fade start = float(80,1,100)
#@gimp : Fade end = float(90,1,100)
#@gimp : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gimp : Size = _choice("Shrink", "Expand", "Repeat [Memory consuming!]")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_array_fade :
  -if {$7&1} -mirror x -endif -if {$7>1} -mirror y -endif
  -array_fade $1,$2,$5,$6,$8
  -shift -$3%,-$4%,0,0,2

gimp_array_fade_preview :
  -gimp_array_fade $1,$2,$3,$4,$5,$6,$7,0

#@gimp Array [mirrored] : gimp_array_mirror, gimp_array_mirror_preview(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Array mode = choice(2,"x-axis","y-axis","xy-axes","2xy-axes")
#@gimp : Initialization = choice("Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gimp : Expand size = _bool(false)
#@gimp : Crop = int(0,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_array_mirror : -skip ${7=0}
  -if {$5==1} -mirror x
  -elif {$5==2} -mirror y
  -elif {$5==3} -rotate 90
  -elif {$5==4} -rotate 180
  -elif {$5==5} -rotate 270
  -endif
  -if $7
    -if {$4==0} -columns 0,{100-$7}%
    -elif {$4==1} -rows 0,{100-$7}%
    -elif {$4==2} -z 0,0,{100-$7}%,{100-$7}%
    -elif {$4==3} -z {$7/2}%,{$7/2}%,{100-$7/2}%,{100-$7/2}%
    -endif
  -endif
  -shift -$2%,-$3%,0,0,2
  -array_mirror $1,$4,$6

gimp_array_mirror_preview :
  -gimp_array_mirror $1,$2,$3,$4,$5,0,$7

#@gimp Array [random] : array_random, array_random(1)
#@gimp : Source X-tiles = int(5,1,20)
#@gimp : Source Y-tiles = int(5,1,20)
#@gimp : Destination X-tiles = int(7,1,20)
#@gimp : Destination Y-tiles = int(7,1,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Array [random colors] : gimp_array_color, gimp_array_color(1)
#@gimp : X-tiles = int(5,1,20)
#@gimp : Y-tiles = int(5,1,20)
#@gimp : Opacity = float(0.5,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_array_color :
  -repeat @# -l[-1]
    $1,$2,1,3 -rand[-1] 0,255 -to_colormode[-1] @{-2,s} -r[-1] [-2] -*[-1] $3 -*[-2] {1-$3} -+[-2,-1]
  -endl -mv[-1] 0 -done

#@gimp Array [regular] : gimp_array, gimp_array_preview(1)
#@gimp : X-tiles = int(2,1,10)
#@gimp : Y-tiles = int(2,1,10)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gimp : Size = _choice("Shrink", "Expand", "Repeat [Memory consuming!]")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_array :
  -shift -$3%,-$4%,0,0,2
  -if {$5&1} -mirror x -endif -if {$5>1} -mirror y -endif
  -array $1,$2,$6

gimp_array_preview :
  -gimp_array $1,$2,$3,$4,$5,0

#@gimp Chessboard : gimp_chessboard, gimp_chessboard_preview(0)
#@gimp : First size = int(64,1,512)
#@gimp : Second size = int(64,1,512)
#@gimp : First offset = int(0,0,512)
#@gimp : Second offset = int(0,0,512)
#@gimp : Angle = float(0,0,180)
#@gimp : Opacity = float(0.5,0,1)
#@gimp : First color = color(0,0,0,255)
#@gimp : Second color = color(255,255,255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_chessboard :
  -to_rgba -chessboard ${1-14}

gimp_chessboard_preview :
  -gimp_split_preview "-gimp_chessboard $*",$-1

#@gimp Dices : gimp_dices, gimp_dices(0)
#@gimp : Resolution = float(2,1,10)
#@gimp : Size = int(24,8,64)
#@gimp : Color model = choice(1,"Black dices","White dices","Dices with colored numbers","Dices with colored sides")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/27</i>.</small>")
gimp_dices :

    # Create dice patterns.
    -repeat 6 {2*$2},{2*$2} -_dice$> -done
    -if {$3%2} -negative[-6--1] -endif
    -frame_round[-6--1] 10,10,0,0,128,128,128,0
    -r2dy[-6--1] $2 -a[-6--1] x

    -repeat {@#-1} -l[$>,-1]

      # Prepare input images.
      --luminance[0] -rv[1,2] -r[0,1] {100*$1/$2}%,{100*$1/$2}%,1,100%,2 -quantize[1] 6,0

      # Convert input image to dices pattern.
      -*[-2] $2 -channels[-2] 0,1 -r[-2] {$2*100}%,{$2*100}%
      $2,$2,1,2,'if(c,y,x)' -r[-1] [-3],[-3],1,2,0,2 -+[-3,-1] --warp[-1] [-2],0,0 -rm[-3]

      -if {$3<2} -rm[0] -mv[-1] 0
      -else -r[0] [2],[2],1,100% -rv[0,-1] -blend[0,-1] multiply
      -endif

    -endl -done -rm[-1]

_dice0 : -ellipse[-1] 50%,50%,5.2%,5.2%,0,1,255
_dice1 : -ellipse[-1] 25%,25%,5.2%,5.2%,0,1,255 -ellipse[-1] 75%,75%,5.2%,5.2%,0,1,255
_dice2 : -_dice1 -_dice0
_dice3 : -_dice1 -ellipse[-1] 25%,75%,5.2%,5.2%,0,1,255 -ellipse[-1] 75%,25%,5.2%,5.2%,0,1,255
_dice4 : -_dice3 -_dice0
_dice5 : -_dice3 -ellipse[-1] 25%,50%,5.2%,5.2%,0,1,255 -ellipse[-1] 75%,50%,5.2%,5.2%,0,1,255

#@gimp Extract objects : gimp_extract_objects, gimp_extract_objects_preview(1)
#@gimp : X-background = float(0,0,100)
#@gimp : Y-background = float(0,0,100)
#@gimp : Color tolerance = int(20,0,256)
#@gimp : Opacity threshold = int(50,0,100)
#@gimp : Minimal area = float(0.3,0,5)
#@gimp : Connectivity = choice("Low","High")
#@gimp : Output type = _choice(1,"Crop","Segmentation")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/07/11</i>.</small>")
#@gimp : note = link("Filter explained here","http://gimpchat.com/viewtopic.php?f=28&t=7905")
gimp_extract_objects :
  -if $5 min_area=$5% -else min_area=5 -endif
  -repeat @# -l[$<] -to_rgba
    x={$1%*(w-1)}
    y={$2%*(h-1)}
    color=@{-at\ $x,$y}
    -if $7 -replace_color $3,0,$color,0,0,0,0 -autocrop_components $4%,$min_area,$6,$7
    -else
      --replace_color $3,0,$color,0,0,0,0 -autocrop_components[-1] $4%,$min_area,$6,2
      -repeat {w} --z[0] @{1,i($>,0)},@{1,i($>,1)},@{1,i($>,3)},@{1,i($>,4)} -done -rm[0,1]
    -endif
  -endl -done

gimp_extract_objects_preview :
  -if $5 min_area=$5% -else min_area=5 -endif
  -repeat @# -l[$>] -to_rgba
    x={$1%*(w-1)}
    y={$2%*(h-1)}
    color=@{-at\ $x,$y}
    --replace_color $3,0,$color,0,0,0,0
    -autocrop_components[-1] $4%,$min_area,$6,2
    -repeat {w}
      xycoords=@{1,i($>,0)},@{1,i($>,1)},@{1,i($>,3)},@{1,i($>,4)}
      -rectangle[0] $xycoords,0.3,0,0,255,255
      -rectangle[0] $xycoords,1,0xFFFFFFFF,0,0,0,255
    -done
    -drgba[0]
    -text_outline[0] {w}" objects",2,2,13,2,0.3,255,255,255,255
    -k[0]
    -circle $x,$y,3,1,0,255,0
    -circle $x,$y,3,1,0xFFFFFFFF,0
  -endl -done

#@gimp Grid : gimp_imagegrid, gimp_imagegrid(0)
#@gimp : X-size = int(10,2,100)
#@gimp : Y-size = int(10,2,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_imagegrid :
  -imagegrid $1,$2

#@gimp Puzzle : gimp_puzzle, gimp_puzzle_preview(1)
#@gimp : note = note("<small><b>Pattern parameters:</b></small>")
#@gimp : X-tiles = int(5,2,32)
#@gimp : Y-tiles = int(5,2,32)
#@gimp : Curvature = float(0.5,0,1.5)
#@gimp : Connectors centering = float(0,0,1)
#@gimp : Connectors variability = float(0,0,2)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Blending parameters:</b></small>")
#@gimp : Relief smoothness = float(0.3,0,3)
#@gimp : Relief contrast = float(100,0,255)
#@gimp : Outline smoothness = float(0.2,0,3)
#@gimp : Outline contrast = float(255,0,255)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Recomposition parameters:</b></small>")
#@gimp : Scale = float(100,0,150)
#@gimp : Scale variations = float(0,0,100)
#@gimp : Angle = float(0,-180,180)
#@gimp : Angle variations = float(0,0,180)
#@gimp : Shuffle pieces = bool(0)
#@gimp : Additional outline = bool(0)
#@gimp : Output each piece on a different layer = _bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2014/01/06</i>.</small>")
gimp_puzzle :
  -repeat @# -l[$<]
    w={w} h={h} -to_rgb
    -puzzle $w,$h,$1,$2,$3,$4,$5
    --b[-1] $6%,0 -gradient[-1] xy -+[-2,-1] -n[-1] -$7,$7 -+[0,-1]  # Relief.
    --b[-1] $8%,0 -n[-1] 0,1 -*[-1] -1 -+[-1] 1 -n[-1] {(255-$9)/255},1 -*[0,-1] -c 0,255  # Outline.

    -if {$10!=100||$11||$12||$13||$14||$15||$16}

      # Decompose puzzle into set of pieces.
      ---[-1] 1 -label_fg[-1] 0
      --area_fg[-1] 0,0 -lt[-1] 50% -or[-3] [-1] -eq[-1] 0 -*[-2,-1]
      -distance[-2] 0 -*[-2] -1 -watershed[-1] [-2] -rm[-2] -label[-1] 0,0

      -repeat {iM+1}
        --==[1] $>
        coords=@{-autocrop_coords[-1]\ 0}
        --z[0] $coords -z[-2] $coords -rv[-2,-1] -*[-2] [-1] -*[-1] 255 -a[-2,-1] c
        x$>={arg(1,$coords)+round(w/2)} y$>={arg(2,$coords)+round(h/2)}
      -done
      -rm[0,1]

      # Recompose puzzle.
      -if $14 -sort_list +,? -endif

      -if $16  # One piece by layer.
        -repeat @# -l[$<]
          -r2dy {max(0.1,$10+$11*?(-1,1))}% -rotate {$12+$13*?(-1,1)}
          -if $15 -expand_xy 1,0 -endif
          cx={round(w/2)} cy={round(h/2)}
          -sh 100%,100% -if $15 -dilate[-1] 3 -endif
          -i[0] $w,$h,1,4
          -j[0] [-2],{${x$<}-$cx},{${y$<}-$cy},0,0,1,[-1],255 -rm[-2,-1]
        -endl -done

      -else # All pieces on the same layer.
        -i[0] $w,$h,1,{s}
        -repeat {@#-1}
          -r2dy[-1] {max(0.1,$10+$11*?(-1,1))}% -rotate[-1] {$12+$13*?(-1,1)}
          -if $15 -expand_xy[-1] 1,0 -endif
          cx={round(w/2)} cy={round(h/2)}
          -sh[-1] 100%,100% -if $15 -dilate[-1] 3 -endif
          -j[0] [-2],{${x$<}-$cx},{${y$<}-$cy},0,0,1,[-1],255 -rm[-2,-1]
        -done
      -endif

    -else -rm[-1]
    -endif
  -endl -done

gimp_puzzle_preview :
  -gimp_puzzle ${1-15},0

#@gimp Taquin : taquin, taquin(1)
#@gimp : X-tiles = int(7,1,20)
#@gimp : Y-tiles = int(7,1,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Tileable rotation : gimp_rotate_tileable, gimp_rotate_tileable(1)
#@gimp : Angle = float(45,0,360)
#@gimp : Maximum size factor = int(8,0,20)
#@gimp : Array mode = choice(0,"None","x-axis","y-axis","xy-axes","2xy-axes")
#@gimp : sep = separator(), note = note("<b>Note:</b> This filter implements the tileable rotation technique described by <b>Peter Yu</b>, at:")
#@gimp : l = link("[Peter Yu] Create rotated tileable patterns","http://www.peteryu.ca/tutorials/gimp/rotate_tileable_patterns")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/05/26</i>.</small>")
gimp_rotate_tileable :
  -if $3 -array_mirror 1,{$3-1},1 -endif
  -rotate_tileable $1,{if($3==0,$2,$2/2)}
  -repeat @#
    -if {@{$>,w}==1" && "@{$>,h}==1} -rm -_gimp_no_preview "  Invalid\nimage size" -return -endif
  -done

#@gimp Tiled rotation : gimp_rotate_tiles, gimp_rotate_tiles(1)
#@gimp : X-tiles = int(5,1,80)
#@gimp : Y-tiles = int(5,1,80)
#@gimp : Angle = float(15,0,360)
#@gimp : X-shadow = float(3,-20,20)
#@gimp : Y-shadow = float(3,-20,20)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_rotate_tiles :
  -to_rgba -rotate_tiles $3,$1,$2 -drop_shadow $4%,$5%,$6%

#@gimp Tiled normalization : gimp_normalize_tiles, gimp_normalize_tiles(1)
#@gimp : X-tiles = int(25,1,80)
#@gimp : Y-tiles = int(25,1,80)
#@gimp : Minimal value = float(0,0,255)
#@gimp : Maximal value = float(255,0,255)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_normalize_tiles :
  -repeat @# -l[-1] -split_tiles $1,$2 -n $3,$4 -append_tiles $1,$2 -endl -mv[-1] 0 -done

gimp_normalize_tiles :
  -apply_channels "-_gimp_normalize_tiles ${1-4}",$-1

#@gimp Tiled random shifts : gimp_shift_tiles, gimp_shift_tiles(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
#@gimp : Amplitude = float(10,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_shift_tiles :
  -to_rgba -shift_tiles $1,$2,$3
  -if {$4<1} -repeat @# -s[-1] c -*[-1] $4 -a[-4--1] c -mv[-1] 0 -done -endif

#@gimp Tiled parameterization : gimp_parameterize_tiles, gimp_parameterize_tiles(1)
#@gimp : X-tiles = int(10,1,30)
#@gimp : Y-tiles = int(10,1,30)
#@gimp : Fitting function = choice("Linear","Quadratic")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_parameterize_tiles :
  -if $3
    -quadratize_tiles $1,$2
  -else
    -linearize_tiles $1,$2
  -endif
  -c 0,255

#@gimp Tiled isolation : gimp_isolate_tiles, gimp_isolate_tiles(0)
#@gimp : X-size = float(10,0,100)
#@gimp : Y-size = float(10,0,100)
#@gimp : X-border = float(5,0,100)
#@gimp : Y-border = float(5,0,100)
#@gimp : Keep tiles square = bool(1)
#@gimp : Keep borders square = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/04/13</i>.</small>")
gimp_isolate_tiles :
  -repeat @# -l[$>] -to_rgba
    -if $5 sx={round(min(w,h)*max($1,$2)/100)} sy=$sx -else sx={round(w*$1/100)} sy={round(h*$2/100)} -endif
    -if $6 bx={max($3,$4)} by=$bx -else bx=$3 by=$4 -endif
    -s x,-$sx
    -repeat @# -l[$>] -s y,-$sy -r 100%,{100+$by}%,1,100%,0,0,0.5,0.5 -a y -endl -done
    -r {100+$bx}%,100%,1,100%,0,0,0.5,0.5 -a x
  -endl -done


#@gimp _<b>Artistic</b>
#----------------------

#@gimp Bokeh : bokeh, gimp_bokeh_preview(0)
#@gimp : note = note("<b><small>Global parameters:</small></b>")
#@gimp : Amplitude = float(250,0,600)
#@gimp : Smoothness = float(2,0,20)
#@gimp : Density = float(0.5,0,5)
#@gimp : sep = separator(), note = note("<b><small>Bokeh shape:</small></b>")
#@gimp : Size = int(24,1,64)
#@gimp : Outline size = float(10,0,100)
#@gimp : Outline amplitude = float(2,0,10)
#@gimp : Smoothness = float(0.7,0,5)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/04/24</i>.</small>")
gimp_bokeh_preview :
  -gimp_split_preview "-bokeh $*",$-1

#@gimp Cartoon : cartoon, gimp_cartoon_preview(0)
#@gimp : Smoothness = float(3,0,10)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(20,1,30)
#@gimp : Edge thickness = float(0.25,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : Color quantization = int(8,2,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_cartoon_preview :
  -gimp_split_preview "-cartoon $*",$-1

#@gimp Cubism : gimp_cubism, gimp_cubism_preview(1)
#@gimp : Iterations = int(2,0,10)
#@gimp : Density = float(50,0,200)
#@gimp : Thickness = float(10,0,50)
#@gimp : Angle = float(90,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(0,0,5)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/05</i>.</small>")
gimp_cubism :
  -repeat $1 -cubism ${2--1} -done

gimp_cubism_preview :
  -gimp_split_preview "-gimp_cubism $*",$-1

#@gimp Ellipsionism : gimp_ellipsionism, gimp_ellipsionism_preview(0)
#@gimp : Primary radius = float(20,1,100)
#@gimp : Secondary radius = float(10,1,100)
#@gimp : Smoothness = float(0.5,0,10)
#@gimp : Opacity = float(0.7,0,1)
#@gimp : Outline = float(8,1,3)
#@gimp : Density = float(0.5,0.1,2)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_ellipsionism :
  -ellipsionism ${^0}

gimp_ellipsionism_preview :
  -gimp_split_preview "-gimp_ellipsionism $*",$-1

#@gimp Felt pen : gimp_feltpen, gimp_feltpen_preview(0)
#@gimp : Amplitude = float(300,0,4000)
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Edge = float(20,0,100)
#@gimp : Thickness = int(5,2,32)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/25</i>.</small>")
gimp_feltpen :
  -repeat @# -l[$>] --gimp_hardsketchbw ${1-5},0,0 -blend hardlight -erode_oct $6 -endl -done

gimp_feltpen_preview :
  -gimp_split_preview "-gimp_feltpen $*",$-1

#@gimp Hope poster : gimp_poster_hope, gimp_poster_hope_preview(0)
#@gimp : Gamma = float(0,-3,3)
#@gimp : Smoothness = float(3,0,20)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/07</i>.</small>")
gimp_poster_hope :
  -apply_gamma {10^$1} -poster_hope $2

gimp_poster_hope_preview :
  -gimp_split_preview "-gimp_poster_hope $*",$-1

#@gimp Kuwahara : gimp_kuwahara, gimp_kuwahara_preview(0)
#@gimp : Iterations = int(2,1,20)
#@gimp : Radius = int(5,1,30)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/05/31</i>.</small>")
gimp_kuwahara :
  -apply_channels "-repeat $1 -kuwahara $2 -done",$3,0

gimp_kuwahara_preview :
  -gimp_split_preview "-gimp_kuwahara $*",$-1

#@gimp Lylejk's painting : gimp_lylejk_painting, gimp_lylejk_painting_preview(0)
#@gimp : Iterations = int(2,1,20)
#@gimp : Radius = int(4,1,30)
#@gimp : Canvas = float(10,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll, David Tschumperl&#233;</i>.      Latest update: <i>2011/09/21</i>.</small>")
#@gimp : note = link("Filter Explained here","http://www.gimpchat.com/viewtopic.php?f=10&t=2624")
gimp_lylejk_painting :
  -repeat @#
    --_gimp_lylejk_painting[-1] 10,10.49,0.75,0
    -smooth[-1] 300,0.26,1,0,7 -sharpen[-1] $3
    [-1] -rv[-3--1]
    -blend[-2,-1] lighten,0.5
    -blend[-2,-1] grainmerge,1
    -gimp_kuwahara[-1] $1,$2,0
    -texturize_canvas[-1] $3,4
  -mv[-1] 0 -done

gimp_lylejk_painting_preview :
  -gimp_split_preview "-gimp_lylejk_painting $*",$-1

_gimp_lylejk_painting :
  -apply_channels "-repeat $1 -b $3 -unsharp $3,$2 -c 0,255 -mv[-1] 0 -done",$4,0

#@gimp Painting : gimp_painting, gimp_painting_preview(0)
#@gimp : Abstraction = int(5,1,10)
#@gimp : Details scale = float(2.5,0,5)
#@gimp : Color = float(1.5,0,4)
#@gimp : Smoothness = float(50,0,1000)
#@gimp : Sharpen shades = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll, Angelo Lama, David Tschumperl&#233;</i>.\nLatest update: <i>2011/02/28</i>.</small>")
gimp_painting : -skip ${4=0},${5=0}
  -repeat @# -l[$>]
    -to_colormode {max(3,s)} -split_opacity -rv
    -repeat $1 -gimp_normalize_local[-1] 10,6,5,20,1,3 -done
    -gimp_anisotropic_smoothing[-1] {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
    -gimp_mix_lab[-1] 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
    -if $5 -gimp_segment_watershed[-1] 10,1,0 -endif
    -smooth[-1] $4,0,1,1,1
    -rv -a c
  -endl -done

gimp_painting_preview :
  -gimp_split_preview "-gimp_painting $*",$-1

#@gimp Pen drawing : gimp_pen_drawing, gimp_pen_drawing_preview(0)
#@gimp : Amplitude = float(10,0,30)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_pen_drawing :
  -drawing $1

gimp_pen_drawing_preview :
  -gimp_split_preview "-gimp_pen_drawing $*",$-1

#@gimp Polygonize : gimp_polygonize, gimp_polygonize_preview(0)
#@gimp : Amplitude = int(300,0,2000)
#@gimp : Smoothness = float(10,0,100)
#@gimp : Minimal area = float(10,0,100)
#@gimp : X-resolution = float(10,1,256)
#@gimp : Y-resolution = float(10,1,256)
#@gimp : Outline color = color(0,0,0,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/12/02</i>.</small>")
gimp_polygonize :
  -polygonize $1,$2,{$3^2},$4,$5
  -if $9 -repeat @# -l[$>]  # has outline.
    --norm -gradient[-1] xy,1 -neq[-2,-1] 0 -or[-2,-1] -r[-1] 100%,100%,1,4
    -replace_color[-1] 0,0,1,1,1,1,$6,$7,$8,$9
    -blend alpha
  -endl -done -endif

gimp_polygonize_preview :
  -gimp_split_preview "-gimp_polygonize $*",$-1

#@gimp Poster edges : gimp_poster_edges, gimp_poster_edges_preview(0)
#@gimp : Image smoothness = float(20,0,100)
#@gimp : Edge threshold = float(60,0,100)
#@gimp : Edge shade = float(5,0,30)
#@gimp : Edge thickness = float(0,0,5)
#@gimp : Edge antialiasing = float(10,0,100)
#@gimp : Posterization level = int(0,0,15)
#@gimp : Posterization antialiasing = float(0,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233; and David Revoy</i>.      Latest update: <i>2012/11/30</i>.</small>")
gimp_poster_edges :
  -if $1 -bilateral 10,$1 -endif
  -poster_edges ${2-7}

gimp_poster_edges_preview :
  -gimp_split_preview "-gimp_poster_edges $*",$-1

#@gimp Rodilius : gimp_rodilius, gimp_rodilius_preview(1)
#@gimp : Amplitude = float(10,0,30)
#@gimp : Thickness = float(10,0,100)
#@gimp : Sharpness = float(300,0,1000)
#@gimp : Orientations = int(5,2,36)
#@gimp : Offset = float(30,0,180)
#@gimp : Smoothness = int(0,0,5)
#@gimp : Color mode = choice(1,"Darker","Lighter")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Rod/GimpChat</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/03/05</i>.</small>")
gimp_rodilius :
  -apply_channels "-rodilius ${1-5,7} -repeat $6 -smooth 10,0,1,1,1,0.8,45 -sharpen 30 -done -c 0,255",$8,0

gimp_rodilius_preview :
  -gimp_split_preview "-gimp_rodilius $*",$-1

#@gimp Shapeism : gimp_shapeism, gimp_shapeism_preview(0)
#@gimp : Shape = choice(2,"Squares","Triangles","Circles","Diamond","Hexagon","Octagon","Stars","Custom")
#@gimp : Branches = int(7,2,16)
#@gimp : Thickness = float(0.38,0,1)
#@gimp : Angle = float(0,0,360)
#@gimp : note = note("<small><b>Note:</b> Parameters <i>Branches</i>, <i>Thickness</i> and <i>Angle</i> are used only for <i>Custom</i> shapes.</small>")
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator()
#@gimp : Scales = int(5,1,16)
#@gimp : Maximal size = int(32,1,256)
#@gimp : Minimal size = int(8,1,256)
#@gimp : Allow angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gimp : Spacing = int(1,-5,5)
#@gimp : Precision = int(5,1,10)
#@gimp : Edges = float(0.5,0,2)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Background = color(0,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/11</i>.</small>")
gimp_shapeism :
  -repeat @# -l[$>]
    -to_rgb
    --gradient_norm -b[-1] $13% -pow[-1] $12 -quantize[-1] $6,0,0
    100%,100%,1,2
    -repeat $6

      # Create map of possible locations.
      --channels[2] 100% --gt[1] $> -neq[-2] 0 -or[-2,-1] -a[2,-1] c

      # Create shape at given scale.
      size={if($6<=1,$7,$7+($8-$7)*$>/($6-1))}
      -if {$size<1} -break -endif
      -if $5 {2*$size},{2*$size} -_gimp_shapeism$1[-1] ${2-4} -r2dy[-1] $size
      -else $size,$size -_gimp_shapeism$1[-1] ${2-4}
      -endif
      --neq[-1] 0 -expand_xy[-2,-1] 1,0 -n[-2,-1] 0,1
      -if {$10<1} -dilate[-1] 3 -endif
      [-1] -a[-3--1] c

      # Pack sprites for given scale
      -rprogress "-pack_sprites[-2,-1] 1,100,$9,$10,$11",{$>*100/$6},{($>+1)*100/$6}
      -channels[-1] 0,1

    -done

    -rprogress 97
    -rm[1]
    -channels[-1] 0 --neq[-1] 0 -blend[0,-1] shapeaverage0 -*[1] 255 -a c
    -i[0] 100%,100%,1,4 -fc[0] $14,$15,$16,$17
    -blend alpha
    -rprogress 100
  -endl -done

gimp_shapeism_preview :
  -if @#>=1 -k[0] -else 256,256 -endif
  -_gimp_no_preview " ","$*"
  50%,50% -_gimp_shapeism$1[-1] ${2-4} -frame[-1] 1,1,0 -ge[-1] 50% -n[-1] 0,255 -r[-1] 100%,100%,1,4
  -r[-1] [0],0,0,0.5,0.5 -or

_gimp_shapeism0 : # Square
  -f 255 -skip $*

_gimp_shapeism1 : # Triangle
  -polygon 3,50%,0,0,100%,100%,100%,1,1 -skip $*

_gimp_shapeism2 : # Circle
  -_dt_circle {w} -rm[-2] -skip $*

_gimp_shapeism3 : # Diamond
  -_dt_diamond {w} -rm[-2] -skip $*

_gimp_shapeism4 : # Hexagon
  -star3d 3,1 -*3d[-1] @{0,min(w,h)/2} -object3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*

_gimp_shapeism5 : # Octogon
  -star3d 4,1 -*3d[-1] @{0,min(w,h)/2} -object3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*

_gimp_shapeism6 : # Star
  -star3d 5 -*3d[-1] @{0,min(w,h)/2} -object3d[0] [-1],50%,50%,0,1,2,0 -k[0] -skip $*

_gimp_shapeism7 : # Custom
  -star3d $1,$2 -*3d[-1] @{0,min(w,h)/2} -r3d[-1] 0,0,1,$3 -object3d[0] [-1],50%,50%,0,1,2,0 -k[0]

#@gimp Warhol : warhol, warhol(1)
#@gimp : X-tiles = int(3,1,10)
#@gimp : Y-tiles = int(3,1,10)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Color = float(40,0,60)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Whirl drawing : draw_whirl, gimp_draw_whirl_preview(0)
#@gimp : Amplitude = float(20,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_draw_whirl_preview :
  -gimp_split_preview "-draw_whirl $*",$-1


#@gimp _<b>Black &amp; white</b>
#-------------------------------

#@gimp Black &amp; white : gimp_blackandwhite, gimp_blackandwhite_preview(1)
#@gimp : Red level = float(0.299,0,1)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green level = float(0.587,0,1)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue level = float(0.114,0,1)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator()
#@gimp : Grain (shadows) = float(0,0,200)
#@gimp : Grain (midtones) = float(0,0,200)
#@gimp : Grain (highlights) = float(0,0,200)
#@gimp : Grain tone fading = float(2,0,10)
#@gimp : Grain scale = float(0,0,3)
#@gimp : Grain type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : sep = separator()
#@gimp : Local contrast = float(0,0,60)
#@gimp : Radius = int(16,1,512)
#@gimp : Contrast smoothness = float(4,0,10)
#@gimp : sep = separator()
#@gimp : Pseudo-gray dithering = int(0,0,5)
#@gimp : Use maximum tones = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/02/20</i>.</small>")
gimp_blackandwhite :
  -repeat @#
    -l[-1] -split_opacity -rv -to_rgb[-1] -s[-1] c          # Isolate opacity
    -*[-3] $1 -b[-3] $2%                                    # Red contrast + smoothness
    -*[-2] $3 -b[-2] $4%                                    # Green contrast + smoothness
    -*[-1] $5 -b[-1] $6%                                    # Blue contrast + smoothness
    -+[-3--1] -/[-1] {$1+$3+$5} -c[-1] 0,255                # (R,G,B) -> B&W

    -apply_gamma[-1] {10^$7}                                # Gamma correction
    --[-1] 128 -*[-1] $8 -+[-1] 128 -+[-1] $9 -c[-1] 0,255  # B&W contrast and brightness.

    -if {$12||$13||$14}
      100%,100% [-1]x2                                        # Create noise for shadows, midtones and highlights.
      -noise[-3] 100,$17 -b[-3] $16% -n[-3] -$12,$12          # Scaled grain on shadows.
      -noise[-2] 100,$17 -b[-2] $16% -n[-2] -$13,$13          # Scaled grain on midtones.
      -noise[-1] 100,$17 -b[-1] $16% -n[-1] -$14,$14          # Scaled grain on highlights.
      --tones[-4] 3 -b[-3--1] $15%                            # Get smoothed tones.
      -*[-6,-3] -*[-4,-2] -*[-2,-1]                           # Get noisy tones.
      -+[-4--1] -c[-1] 0,255                                  # Compose them with the B&W image.
    -endif

    -if {$10||$11}
      -/[-1] 255
      -i[-2] 100%,100%,1,1,$11
      -i[-3] 100%,100%,1,1,$10
      -a[-3--1] c -hsv2rgb[-1]
    -endif

    -rv -a c -endl -mv[-1] 0 -done                          # Re-compose opacity and loop to next image.
  -if $18 -normalize_local $18,$19,$20,2%,1,0,255 -endif
  -if $22 -n 0,255 -endif
  -if $21 -to_pseudogray $21,1 -endif

gimp_blackandwhite_preview :
  -gimp_split_preview "-gimp_blackandwhite $*",$-1

#@gimp B&amp;W stencil : gimp_stencilbw, gimp_stencilbw_preview(0)
#@gimp : Threshold = float(10,0,30)
#@gimp : Smoothness = float(10,0,30)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_stencilbw :
  -stencilbw $1,$2
  -if {$3||$4} -repeat @# -l[$>] -split_opacity
    -/[0] 255 -i[0] 100%,100%,1,1,$4 -i[0] 100%,100%,1,1,$3 -a[0-2] c -hsv2rgb[0]
  -a c -endl -done -endif

gimp_stencilbw_preview :
  -gimp_split_preview "-gimp_stencilbw $*",$-1

#@gimp Charcoal : gimp_charcoal, gimp_charcoal_preview(0)
#@gimp : Granularity = int(65,0,800)
#@gimp : Lowlights crossover point = int(70,0,255)
#@gimp : Highlights crossover point = int(170,0,255)
#@gimp : Boost contrast = bool(0)
#@gimp : Resize image for optimum effect = bool(1)
#@gimp : Add chalk highlights = bool(0)
#@gimp : Minimal highlights = int(50,0,255)
#@gimp : Maximal highlights = int(70,0,255)
#@gimp : Background color = color(255,255,255)
#@gimp : Foreground color = color(0,0,0)
#@gimp : Invert background/foreground = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/03/17</i>.</small>")
#@gimp : note = note("<small>Inspired from the Charcoal script by <i>micomicon</i> :</small>")
#@gimp : link = link("http://registry.gimp.org/node/25078")
gimp_charcoal :
  -repeat @# -l[$>] -split_opacity -l[0]
    -compose_channels max
    w={w} h={h}
    -if $5 -resize[-1] 150%,150%,1,1,6 -endif
    -if $4 -equalize[-1] -n[-1] 0,255 -endif
    -sharpen {$1*3} -cut 0,255
    -if $6 --t2 $7,$8 -endif  # Add highlights layer if required.
    -t2[0] $2,$3
    -if {!$15} -eq[0] 0 -endif
    -or
    --*[0] $10 --*[0] $11 -*[0] $9
    -append[-3--1] c -replace_color 0,0,0,0,0,$12,$13,$14
    -r $w,$h,1,100%,2
  -endl -a c -endl -done

gimp_charcoal_preview :
  -gimp_split_preview "-gimp_charcoal $*",$-1

#@gimp Colorize [comics] : gimp_colorize_comics, gimp_colorize_comics_preview(1)
#@gimp : note = note("<b>Layers ordering:</b>")
#@gimp : Input layers = choice{0,"Color spots + lineart","Lineart + color spots","Color spots + extrapolated colors + lineart","Lineart + color spots + extrapolated colors"}
#@gimp : Output layers = _choice{1,"Single (merged)","Extrapolated colors + lineart","Lineart + extrapolated colors","Color spots + extrapolated colors + lineart","Lineart + color spots + extrapolated colors"}
#@gimp : sep = separator()
#@gimp : Smoothness = float(0.05,0,1)
#@gimp : sep = separator(), note = note{"<b>Note:</b> You probably need to select <i>All</i> for the <i>Input layers</i> option on the left.\n
#@gimp : <i>Color spots</i> = your layer with color indications.\n
#@gimp : <i>Lineart</i> = your layer with line-art (b&amp;w or transparent).\n
#@gimp : <i>Extrapolated colors</i> = the G'MIC generated layer with flat colors.\n\n
#@gimp : <b>Warning:</b> Do not rely too much on the preview, it is probably not accurate !
#@gimp : "}
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;, Timoth&#233;e Giet, David Revoy</i>.      Latest update: <i>2013/06/19</i>.</small>")
#@gimp : link = link(0.5,"More infos on this filter","http://www.gimpchat.com/viewtopic.php?f=28&t=7567")
gimp_colorize_comics :
  -if {@#<2} -return -endif
  -if {$1<2} selection=0,1 -else selection=0,1,2 -endif
  -l[$selection]

    # Format input layers.
    -if {$1==0}              # Color strokes + drawing
    -elif {$1==1} -rv        # Drawing + color strokes
    -elif {$1==2} -rm[1]     # Color strokes + extrapolated colors + drawing
    -elif {$1==3} -rm[2] -rv # Drawing + color strokes + extrapolated colors.
    -endif

    # Here we have only 'color strokes + drawing' -> process.
    --to_rgba[0] -split_opacity[-1] -+[-2] 1 -neq[-1] 0 -*[-2,-1]  # Map of color labels to spread.
    --norm[1] -n[-1] 0,1 --histogram[-1] 2,0,1
    -if {i(0)>i(1)} -*[-2] -1 -+[-2] 1 -endif -rm[-1]              # Determine color model of the drawing.
    -b[-1] $3% -watershed[-2] [-1] -rm[-1]                         # Priority map.
    --[-1] 1
    # Here we have 'color strokes + drawing + extrapolated colors'.

    # Format output layers.
    -if {$2==0} -rm[0] -rv -blend[0,1] multiply
    -elif {$2==1} -rm[0] -rv
    -elif {$2==2} -rm[0]
    -elif {$2==3} -rv[1,2]
    -elif {$2==4} -rv[0,1]
    -endif
  -endl

gimp_colorize_comics_preview :
  -gimp_colorize_comics $1,0,$3

#@gimp Colorize [photographs] : gimp_recolorize, gimp_recolorize_preview(1)
#@gimp : Smoothness = int(2,0,6)
#@gimp : Anisotropy = float(0.2,0,1)
#@gimp : Output mode = choice("Merge brightness/colors","Split brightness/colors")
#@gimp : sep = separator()
#@gimp : note = note{"<b>Note:</b> This filter needs two layers to work properly. The bottom layer must be a B&amp;W image, while the
#@gimp : top layer contains color patches that will be extrapolated in a smart way (edge-directed) to fill the entire image. At the end,
#@gimp : you get a completely recolored image."}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/16</i>.</small>")
gimp_recolorize :
  -repeat {int(@#/2)}
    -if $3 s=$>,{$>+1} -else s={2*$>},{2*$>+1} -endif
    -l[$s] -rv[0,1]
      -channels[0] 0 -to_rgb[-2] # Convert to pure gray.
      -to_rgba[-1] -split_opacity[-1] -neq[-1] 0  # Retrieve mask of color patchs.
      -srgb2rgb[-3,-2] -rgb2lab8[-3,-2] -channels[-3] 0 -channels[-2] 1,2 # Now, list is [0]=lightness / [1]=chroma / [2]=mask.
      -+[-2] 1 -*[-2] [-1] --gradient_norm[-3] -*[-1] -1 -watershed[-3] [-1] -rm[-1] --[-2] 1 # Get first estimate for the color interpolation.
      --diffusiontensors[-3] $2,1,0.5,0.5 -eq[-2] 0 -*[-1] [-2] -rm[-2]
      -smooth[-2] [-1],{$1*80},0.8,60 -rm[-1]
      -a[-2,-1] c -lab82rgb[-1] -rgb2srgb[-1]
      -if $3 -rgb2hsv[-1] -s[-1] c -i[2] 100%,100%,1,1,1 -i[3] 100%,100%,1,2,0 -a[0-2] c -a[^0] c -hsv2rgb -rv -endif
    -endl
  -done

gimp_recolorize_preview :
  -gimp_recolorize $* -a x

#@gimp Colorize [with colormap] : gimp_bwrecolorize, gimp_bwrecolorize_preview
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Normalize = bool(0)
#@gimp : sep = separator()
#@gimp : Gradient preset = choice("User-defined","Black to white","White to black","Sepia","Solarize")
#@gimp : Interpolation type = choice(1,"Nearest","Linear","Cubic","Lanczos")
#@gimp : Preserve initial brightness = bool(0)
#@gimp : sep = separator(), note = note("<small><u>User-defined gradient :</u></small>")
#@gimp : Number of tones = int(5,2,8)
#@gimp : 1st tone = color(0,0,0,255)
#@gimp : 2nd tone = color(43,25,55,255)
#@gimp : 3rd tone = color(158,137,189,255)
#@gimp : 4th tone = color(224,191,228,255)
#@gimp : 5th tone = color(255,255,255,255)
#@gimp : 6th tone = color(255,255,255,255)
#@gimp : 7th tone = color(255,255,255,255)
#@gimp : 8th tone = color(255,255,255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_bwrecolorize :
  -remove_opacity
  -if $4 -n 0,255 -endif
  -if {$5==0}  # User-defined gradient
    (${9--2}) -r[-1] 4,$8,1,1,-1 -permute[-1] yzcx
  -elif {$5==1} # Black to white
    (0,255^0,255^0,255^255,255)
  -elif {$5==2} # White to black
    (255,0^255,0^255,0^255,255)
  -elif {$5==3} # Sepia
    (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200^255,255,255,255,255,255)
  -else         # Solarize
    (0,359^1,1^1,1^255,255) -r[-1] 256,1,1,4,3 -sh[-1] 0,2 -hsv2rgb[-1] -rm[-1]
  -endif
  -if {$6==0} -r[-1] 256,1,1,4,1
  -elif {$6==1} -r[-1] 256,1,1,4,3
  -elif {$6==2} -r[-1] 256,1,1,4,5 -c[-1] 0,255
  -else -r[-1] 256,1,1,4,6
  -endif
  -if {$7==1} -sh[-1] 0,2 -rgb2hsv[-1] -sh[-1] 2,2 -f[-1] x/w -hsv2rgb[-2] -rm[-2,-1] -endif
  -l[^-1] -luminance -apply_gamma {10^$1} -- 128 -* $2 -+ {$3+128} -c 0,255 -endl -map[^-1] [-1] -rm[-1]

gimp_bwrecolorize_preview :
  -gimp_split_preview "-gimp_bwrecolorize ${^0}",$-1

#@gimp Dithering : gimp_ditheredbw, gimp_ditheredbw_preview(0)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_ditheredbw :
  -repeat @# -l[$>] -split_opacity -l[0]
    -luminance -n 0,255 -apply_gamma {10^$1} -- 128 -* $2 -+ 128 -+ $3 -b $4 -c 0,255 -ditheredbw
    -if {$5||$6} -/ 255 -i[0] 100%,100%,1,2 -fc[0] $5,$6 -a c -hsv2rgb -endif
  -endl -a c -endl -done

gimp_ditheredbw_preview :
  -gimp_split_preview "-gimp_ditheredbw $*",$-1

#@gimp Hard sketch : gimp_hardsketchbw, gimp_hardsketchbw_preview(0)
#@gimp : Amplitude = float(300,0,4000)
#@gimp : Density = float(50,0,100)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Edge = float(20,0,100)
#@gimp : Fast approximation = bool(0)
#@gimp : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_hardsketchbw :
  -b $3
  -if {$7==4} -repeat @# -l[$>] --hardsketchbw $1,$2,$4,$5,$6 -blend hardlight -endl -done -return -endif
  -hardsketchbw $1,$2,$4,$5,$6
  -if {$7&1} -negative -endif
  -if {$7==2} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] -2 -+[-1] {2*255} -c[-1] 0,255 -rm[-1] -done
  -elif {$7==3} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] 2 -c[-1] 0,255 -rm[-1] -done
  -endif

gimp_hardsketchbw_preview :
  -gimp_split_preview "-gimp_hardsketchbw $*",$-1

#@gimp Hough sketch : gimp_houghsketchbw, gimp_houghsketchbw_preview(0)
#@gimp : Smoothness = float(1.25,0,10)
#@gimp : Density = float(10,0,70)
#@gimp : Radius = int(5,0,30)
#@gimp : Threshold = float(80,0,100)
#@gimp : Opacity = float(0.1,0,1)
#@gimp : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/05/18</i>.</small>")
gimp_houghsketchbw :
  -b $1 -n 0,255
  -if {$6==4} -repeat @# -l[$>] --houghsketchbw ${2-5} -blend hardlight -endl -done -return -endif
  -houghsketchbw ${2-5}
  -if {$6&1} -negative -endif
  -if {$6==2} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] -2 -+[-1] {2*255} -c[-1] 0,255 -rm[-1] -done
  -elif {$6==3} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] 2 -c[-1] 0,255 -rm[-1] -done
  -endif

gimp_houghsketchbw_preview :
  -gimp_split_preview "-gimp_houghsketchbw $*",$-1

#@gimp Ink wash : gimp_ink_wash, gimp_ink_wash(0)
#@gimp : note = note("Ink wash controls")
#@gimp : Size = float(0.14,0,4)
#@gimp : Amplitude = float(23,0,200)
#@gimp : sep = separator()
#@gimp : note = note("Check if you wish visual control on this step")
#@gimp : SKIP all other steps = bool(false)
#@gimp : note = note ("UNcheck to reactivate the other controls")
#@gimp : sep = separator()
#@gimp : Smoother Sharpness = float(0.5,0,2)
#@gimp : Smoother Edge Protection = float(0.54,0,1)
#@gimp : Smoother Softness = float(2.25,0,10)
#@gimp : sep = separator()
#@gimp : Stretch Contrast = choice("None","Automatic","Automatic & Contrast Mask","Manual Controls")
#@gimp : note = note ("To activate the sliders below chose 'Manual Controls'")
#@gimp :sep = separator()
#@gimp : LN Amplititude = float(2,0,60)
#@gimp : LN Size = float(6,0,64)
#@gimp : LN Neightborhood-Smoothness = float(5,0,40)
#@gimp : LN Average-Smoothness = float(20,0,40)
#@gimp : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update: <i>2011/4/5</i>.</small>")
#@gimp : note = link(0,"Forum thread about the filter discussion","http://gimpchat.com/viewtopic.php?f=10&t=914")
gimp_ink_wash :
  -repeat @# -l[$>] -split_opacity -l[0]
    -gimp_pencilbw[-1] $1,$2,0,0,0
    -if {$3==1} -continue
    -elif {$3==0} -gimp_anisotropic_smoothing[-1] 60,$4,$5,$6,1.1,0.8,30,2,0,1,1,0,1,16
    -endif
    -if {$7==1} -normalize_local[-1] 2,6,5,24,1,0,255
	-elif {$7==2}  -normalize_local[-1] 2,6,5,24,1,0,255 -gimp_contrast_swm 2,0,0.512
    -elif {$7==3} -gimp_normalize_local[-1] $8,$9,$10,$11,1,3,0
    -endif
  -endl -a c -endl -done

#@gimp Pencil : gimp_pencilbw, gimp_pencilbw_preview(0)
#@gimp : Size = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
#@gimp : Hue = float(0,0,360)
#@gimp : Saturation = float(0,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/03/05</i>.</small>")
gimp_pencilbw :
  -pencilbw $1,$2
  -if {$3||$4} -repeat @# -l[$>] -split_opacity
    -/[0] 255 -i[0] 100%,100%,1,1,$4 -i[0] 100%,100%,1,1,$3 -a[0-2] c -hsv2rgb[0]
  -a c -endl -done -endif

gimp_pencilbw_preview :
  -gimp_split_preview "-gimp_pencilbw $*",$-1

#@gimp Pencil portrait : gimp_pencil_portraitbw, gimp_pencil_portraitbw_preview(0)
#@gimp : Stroke length = float(30,0,500)
#@gimp : Stroke angle = float(120,0,180)
#@gimp : Contour threshold = float(1,0,3)
#@gimp : Opacity = float(0.5,0,1)
#@gimp : Color = color(144,79,21)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Ramon Miranda</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/12/11</i>.</small>")
gimp_pencil_portraitbw :
  -repeat @# -l[$>] -split_opacity -l[0]
    --b 2%
    --blend divide -rm[-2] -luminance[-1]
    -gimp_ink_wash[-2] 0,167,0,0.5,0.54,2.25,0,2,6,5,20
    --gimp_hardsketchbw[-1] 80,32,1.89,0.21,31.46,0,0
    --gimp_sketchbw[-2] 1,$2,180,$1,$3,0.03,0,0.6,0.1,0.6,0.25,1,0,1,0
    -blend[0,1] darken
    -blend[0,1] multiply,0.5
    -blend[0,1] lighten,$4
    -normalize_local ,
    -to_rgb --fc ${5-7} -blend softlight
  -endl -a c -endl -done

gimp_pencil_portraitbw_preview :
  -gimp_split_preview "-gimp_pencil_portraitbw $*",$-1

#@gimp Sketch : gimp_sketchbw, gimp_sketchbw_preview(0)
#@gimp : Number of orientations = int(2,1,16)
#@gimp : Starting angle = float(45,0,180)
#@gimp : Angle range = float(180,0,180)
#@gimp : Stroke length = float(30,0,1000)
#@gimp : Contour threshold = float(1,0,3)
#@gimp : Opacity = float(0.03,0,0.3)
#@gimp : Background intensity = float(0,0,2)
#@gimp : Density = float(0.6,0,5)
#@gimp : Sharpness = float(0.1,0,1.5)
#@gimp : Anisotropy = float(0.6,0,1)
#@gimp : Smoothness = float(0.25,0,10)
#@gimp : Coherence = float(1,0,10)
#@gimp : Boost stroke = bool(0)
#@gimp : Curved stroke = bool(1)
#@gimp : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_sketchbw :
  -if {$15==4} -repeat @# -l[$>] --sketchbw ${1-14} -blend hardlight -endl -done -return -endif
  -sketchbw ${1-14}
  -if {$15&1} -negative -endif
  -if {$15==2} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] -2 -+[-1] {2*255} -c[-1] 0,255 -rm[-1] -done
  -elif {$15==3} -r 100%,100%,1,4 -repeat @# -sh[$>] 3,3 -*[-1] 2 -c[-1] 0,255 -rm[-1] -done
  -endif

gimp_sketchbw_preview :
  -gimp_split_preview "-gimp_sketchbw $*",$-1

#@gimp Stamp : gimp_stamp, gimp_stamp_preview(0)
#@gimp : Auto-threshold = bool(1)
#@gimp : Threshold = int(50,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Sharpening = float(0,0,30)
#@gimp : Grain = float(0,0,100)
#@gimp : Invert colors = bool(false)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Antaron, Mahvin, David Tschumperl&#233;</i>.             Latest update: 2012/10/08.</small>")
gimp_stamp :
  -repeat @# -l[$>] -split_opacity
    -norm -noise $5
    -if $1 -otsu 256 -else -ge $2% -endif
    -b $3,0 -sharpen $4 -n 0,255
    -apply_curve 1,0,0,101,33,170,229,255,255
    -if $6 -negative -endif
  -a c -endl -done

gimp_stamp_preview :
  -gimp_split_preview "-gimp_stamp $*",$-1


#@gimp _<b>Colors</b>
#--------------------

#@gimp Abstraction : gimp_color_abstraction, gimp_color_abstraction_preview(0)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Levels = int(10,2,255)
#@gimp : Contrast = float(0.2,0.01,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/10/19</i>.</small>")
gimp_color_abstraction :
  -repeat @# -l[$>] -split_opacity -l[0] -to_rgb
    -b $1 -s c -quantize $2,1,0 -area 0 -^ $3 -n 0,255
  -endl -a c -endl -done

gimp_color_abstraction_preview :
  -gimp_split_preview "-gimp_color_abstraction $*",$-1

#@gimp Boost-fade : gimp_boost_fade, gimp_boost_fade_preview
#@gimp : Amplitude = float(5,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/10/12</i>.</small>")
gimp_boost_fade :
  -i[0] 640,480,1,3 -rand[0] 0,1 -b[0] {10-$1} -n[0] 0,255 -transfer_colors -rm[0]

gimp_boost_fade_preview :
  -gimp_split_preview "-gimp_boost_fade $*",$-1

#@gimp Channel processing : gimp_channel_processing, gimp_channel_processing_preview(1)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Value action = choice("None","Cut","Cut & Normalize","Normalize","Threshold")
#@gimp : Low value = float(0,0,100)
#@gimp : High value = float(100,0,100)
#@gimp : Quantization = int(256,1,256)
#@gimp : Equalization = bool(0)
#@gimp : Negation = bool(0)
#@gimp : sep = separator()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_channel_processing :
  -apply_gamma[-1] {10^$1}
  -if {$2!=1} --[-1] 128 -*[-1] $2 -+[-1] 128 -endif
  -+[-1] $3
  -b[-1] $4% -c[-1] 0,255
  -if {$5==1} -c[-1] $6%,$7%
  -elif {$5==2} -c[-1] $6%,$7% -n[-1] 0,255
  -elif {$5==3} -n[-1] $6%,$7%
  -elif {$5==4} -t2[-1] $6%,$7% -*[-1] 255
  -endif
  -if {$8!=256} -quantize[-1] $8,1,0 -endif
  -if $9 -equalize[-1] -endif
  -if $10 -negative[-1] -endif

gimp_channel_processing :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $11,$12
    -apply_channels[-1] "-_gimp_channel_processing $1,$2,$3,$4,$5,$6,$7,$8,$9,$10",$13,0
    -gimp_end_mix $11
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_channel_processing_preview :
  -gimp_split_preview "-gimp_channel_processing $*",$-1

#@gimp Color balance : gimp_balance_gamma, gimp_balance_gamma_preview
#@gimp : Neutral color = color(128,128,128)
#@gimp : Stretch colors = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/07/01</i>.</small>")
gimp_balance_gamma :
  -balance_gamma[0] ${1-3}
  -if $4 -repeat @# -l[$>] -split_opacity -l[0] -s c -n 0,255 -a c -endl -a c -endl -done -endif

gimp_balance_gamma_preview :
  -gimp_split_preview "-gimp_balance_gamma $*",$-1

#@gimp Colormap : gimp_colormap,gimp_colormap_preview
#@gimp : Colormap = choice[1,"Adaptive","Custom","Standard (256)","HSV (256)","Lines (256)","Hot (256)","Cool (256)","Jet (256)","Flag (256)","Cube (256)"]
#@gimp : Dithering = float(1,0,1)
#@gimp : sep = separator(), note = note("<small><i>For adaptive and custom colormaps only :</i></small>")
#@gimp : Number of tones = int(32,2,256)
#@gimp : sep = separator(), note = note("<small><i>For custom colormaps only :</i></small>")
#@gimp : Number of colors = int(8,2,8)
#@gimp : 1st color = color(0,0,0)
#@gimp : 2nd color = color(255,255,255)
#@gimp : 3rd color = color(255,0,0)
#@gimp : 4th color = color(0,255,0)
#@gimp : 5th color = color(0,0,255)
#@gimp : 6th color = color(255,255,0)
#@gimp : 7th color = color(255,0,255)
#@gimp : 8th color = color(0,255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/12/27</i>.</small>")
gimp_colormap :
  -repeat @# -l[$>] -split_opacity -to_rgb[0]
    -if {$1>=2}                # Pre-defined colormap.
      -index[0] {$1-2},$2,1
    -elif {$1==1}              # Custom colormap.
      (${5-28}) -z[-1] 0,{3*$4-1}
      -r[-1] 3,{w/3},1,1,-1 -permute[-1] yzcx -r[-1] $3,1,1,3,3
      -index[0] [-1],$2,1 -rm[-1]
    -else                      # Adaptive colormap.
      -autoindex[0] $3,$2,{if($3<=32,1,0)}
    -endif
    -a c
  -endl -done

gimp_colormap_preview :
  -gimp_split_preview "-gimp_colormap $*",$-1

#@gimp Curves : gimp_apply_curve, gimp_apply_curve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Display histogram = float(0,0,1)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_apply_curve :
  -apply_channels "-_gimp_apply_curve ${1-13}",$14,$15

_gimp_apply_curve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12

gimp_apply_curve_preview :
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_curve $*",$-1
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
    -if $-2
      [-1],[-1] -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,1 -neq[-1] 0 -*[-1] 255 -rm[-3]
      --xor[-2,-1] -j[-3] [-1],0,0,0,0,$16,[-2],255 -rm[-2,-1]
     -else -rm[-2] -endif
     100%,100% -graph[-1] [0],1,0,255,0,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
     -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
     -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
     -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
     -_gimp_apply_curve_preview 255,$12,6
  -mv[-1] 1 -done -rm[0]

_gimp_apply_curve_preview :
  -if {$1>=0}
    x={$1*100/255}% y={100-$2*100/255}%
    -ellipse[-1] $x,$y,3,3,0,1,0xFFFFFFFF,0,0,0 -ellipse[-1] $x,$y,2,2,0,1,0,255,0
    -t[-1] $3,$x,{$y*h-20},13,1,255
  -endif

#@gimp Curves [RGB]
#@gimp Red : gimp_apply_RGBcurve, gimp_apply_Rcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Green : gimp_apply_RGBcurve, gimp_apply_Gcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Blue : gimp_apply_RGBcurve, gimp_apply_Bcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
#@gimp _
gimp_apply_RGBcurve : -skip $1
  -gimp_apply_RGBcurve_configfile
  -repeat {@#-1} -l[$>,-1]
    -to_colormode[0] {max(3,s)}
    -sh[0] 0,0 -_gimp_apply_RGBcurve[-1] @{-2,0-12} -rm[-1]
    -sh[0] 1,1 -_gimp_apply_RGBcurve[-1] @{-2,13-25} -rm[-1]
    -sh[0] 2,2 -_gimp_apply_RGBcurve[-1] @{-2,26-38} -rm[-1]
  -endl -done
  -rm[-1]

_gimp_apply_RGBcurve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12
  -c 0,255

gimp_apply_Rcurve_preview :
  -gimp_apply_RGBcurve_configfile
  -sh[-1] 0,0,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_RGBcurve_preview[^-1] @-1,0,${-2,-1} -rm[-1]

gimp_apply_Gcurve_preview :
  -gimp_apply_RGBcurve_configfile
  -sh[-1] 1,1,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_RGBcurve_preview[^-1] @-1,1,${-2,-1} -rm[-1]

gimp_apply_Bcurve_preview :
  -gimp_apply_RGBcurve_configfile
  -sh[-1] 2,2,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_RGBcurve_preview[^-1] @-1,2,${-2,-1} -rm[-1]

gimp_apply_RGBcurve_configfile :
  filename=@{-path_tmp}/.gmic_RGBcurve.dlm
  -if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r[-1] 100%,3 -endif

gimp_apply_RGBcurve_preview :
  (${1--3}) -r[-1] 13,3,1,1,-1 -o[-1] @{-path_tmp}/.gmic_RGBcurve.dlm -rm[-1]
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -function1d $26,0,$14,\
                  @{"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
                  @{"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
                  @{"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
                  @{"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
                  @{"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
                  255,$25
  -function1d $39,0,$27,\
                  @{"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
                  @{"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
                  @{"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
                  @{"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
                  @{"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
                  255,$38
  -a[-3--1] y -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_RGBcurve 0",$-1
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -if $-2
        [-1],[-1],1,1,-{$-2*255/100} -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,0
        -rm[-3] -+[-1] {$-2*255/100} -+[-2,-1] -c[-1] 0,255
     -else -rm[-2] -endif
     -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -sh[0] 0,0,0,0
     -graph[-2] [-1],1,0,255,0,1,255,128,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,0,0 -rm[-1]
     -sh[0] 1,1,0,0
     -graph[-2] [-1],1,0,255,0,1,128,255,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,200,0 -rm[-1]
     -sh[0] 2,2,0,0
     -graph[-2] [-1],1,0,255,0,1,128,128,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,0,200 -rm[-1]
     -if {$40==0}
       -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
       -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
       -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
       -_gimp_apply_curve_preview 255,$12,6
     -elif {$40==1}
       -_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
       -_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
       -_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
       -_gimp_apply_curve_preview 255,$25,6
     -else
       -_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
       -_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
       -_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
       -_gimp_apply_curve_preview 255,$38,6
     -endif
  -mv[-1] 1 -done -rm[0]

#@gimp Curves [YCbCr]
#@gimp Luminance : gimp_apply_YCbCrcurve, gimp_apply_Ycurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Blue chrominance : gimp_apply_YCbCrcurve, gimp_apply_Cbcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Red chrominance : gimp_apply_YCbCrcurve, gimp_apply_Crcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
#@gimp _
gimp_apply_YCbCrcurve : -skip $1
  -gimp_apply_YCbCrcurve_configfile
  -repeat {@#-1} -l[$>,-1]
    -to_colormode[0] {max(3,s)} -sh[0] 0,2 -rgb2ycbcr[-1] -rm[-1]
    -sh[0] 0,0 -_gimp_apply_YCbCrcurve[-1] @{-2,0-12} -rm[-1]
    -sh[0] 1,1 -_gimp_apply_YCbCrcurve[-1] @{-2,13-25} -rm[-1]
    -sh[0] 2,2 -_gimp_apply_YCbCrcurve[-1] @{-2,26-38} -rm[-1]
    -sh[0] 0,2 -ycbcr2rgb[-1] -rm[-1]
  -endl -done
  -rm[-1]

_gimp_apply_YCbCrcurve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12
  -c 0,255

gimp_apply_Ycurve_preview :
  -gimp_apply_YCbCrcurve_configfile
  -sh[-1] 0,0,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_YCbCrcurve_preview[^-1] @-1,0,${-2,-1} -rm[-1]

gimp_apply_Cbcurve_preview :
  -gimp_apply_YCbCrcurve_configfile
  -sh[-1] 1,1,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_YCbCrcurve_preview[^-1] @-1,1,${-2,-1} -rm[-1]

gimp_apply_Crcurve_preview :
  -gimp_apply_YCbCrcurve_configfile
  -sh[-1] 2,2,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_YCbCrcurve_preview[^-1] @-1,2,${-2,-1} -rm[-1]

gimp_apply_YCbCrcurve_configfile :
  filename=@{-path_tmp}/.gmic_YCbCrcurve.dlm
  -if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r[-1] 100%,3 -endif

gimp_apply_YCbCrcurve_preview :
  (${1--3}) -r[-1] 13,3,1,1,-1 -o[-1] @{-path_tmp}/.gmic_YCbCrcurve.dlm -rm[-1]
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -function1d $26,0,$14,\
                  @{"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
                  @{"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
                  @{"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
                  @{"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
                  @{"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
                  255,$25
  -function1d $39,0,$27,\
                  @{"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
                  @{"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
                  @{"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
                  @{"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
                  @{"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
                  255,$38
  -a[-3--1] y -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_YCbCrcurve 0",$-1
    -axes[-1] 0,255,255,0,13,1,255
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -if $-2
        [-1],[-1],1,1,-{$-2*255/100} -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,0
        -rm[-3] -+[-1] {$-2*255/100} -+[-2,-1] -c[-1] 0,255
     -else -rm[-2] -endif
     -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -sh[0] 0,0,0,0
     -graph[-2] [-1],1,0,255,0,1,255,255,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,200,200 -rm[-1]
     -sh[0] 1,1,0,0
     -graph[-2] [-1],1,0,255,0,1,128,128,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,0,200 -rm[-1]
     -sh[0] 2,2,0,0
     -graph[-2] [-1],1,0,255,0,1,255,128,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,0,0 -rm[-1]
     -if {$40==0}
       -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
       -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
       -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
       -_gimp_apply_curve_preview 255,$12,6
     -elif {$40==1}
       -_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
       -_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
       -_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
       -_gimp_apply_curve_preview 255,$25,6
     -else
       -_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
       -_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
       -_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
       -_gimp_apply_curve_preview 255,$38,6
     -endif
  -mv[-1] 1 -done -rm[0]

#@gimp Curves [Lab]
#@gimp Lightness : gimp_apply_Labcurve, gimp_apply_Lcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp A-color : gimp_apply_Labcurve, gimp_apply_acurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp B-color : gimp_apply_Labcurve, gimp_apply_bcurve_preview
#@gimp : Starting Y = int(0,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(1) = int(-1,-1,255)
#@gimp : Y-coord(1) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(2) = int(-1,-1,255)
#@gimp : Y-coord(2) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(3) = int(-1,-1,255)
#@gimp : Y-coord(3) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(4) = int(-1,-1,255)
#@gimp : Y-coord(4) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : X-coord(5) = int(-1,-1,255)
#@gimp : Y-coord(5) = int(128,0,255)
#@gimp : sep = separator()
#@gimp : Ending Y = int(255,0,255)
#@gimp : sep = separator()
#@gimp : Curve smoothness = float(1,0,1)
#@gimp : Display histogram = float(0,0,100)
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
#@gimp _
gimp_apply_Labcurve : -skip $1
  -gimp_apply_Labcurve_configfile
  -repeat {@#-1} -l[$>,-1]
    -to_colormode[0] {max(3,s)} -sh[0] 0,2 -rgb2lab[-1] -rm[-1]
    -sh[0] 0,0 -*[-1] 2.55 -_gimp_apply_Labcurve[-1] @{-2,0-12} -/[-1] 2.55 -rm[-1]
    -sh[0] 1,1 -+[-1] 86 -*[-1] 1.38587 -_gimp_apply_Labcurve[-1] @{-2,13-25} -/[-1] 1.38587 --[-1] 86 -rm[-1]
    -sh[0] 2,2 -+[-1] 108 -*[-1] 1.25616 -_gimp_apply_Labcurve[-1] @{-2,26-38} -/[-1] 1.25616 --[-1] 108 -rm[-1]
    -sh[0] 0,2 -lab2rgb[-1] -rm[-1]
  -endl -done
  -rm[-1]

_gimp_apply_Labcurve :
  -apply_curve $13,0,$1,\
                   @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                   @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                   @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                   @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                   @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                   255,$12
  -c 0,255

gimp_apply_Lcurve_preview :
  -gimp_apply_Labcurve_configfile
  -sh[-1] 0,0,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_Labcurve_preview[^-1] @-1,0,${-2,-1} -rm[-1]

gimp_apply_acurve_preview :
  -gimp_apply_Labcurve_configfile
  -sh[-1] 1,1,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_Labcurve_preview[^-1] @-1,1,${-2,-1} -rm[-1]

gimp_apply_bcurve_preview :
  -gimp_apply_Labcurve_configfile
  -sh[-1] 2,2,0,0 -f[-1] ${1--3} -rm[-1]
  -gimp_apply_Labcurve_preview[^-1] @-1,2,${-2,-1} -rm[-1]

gimp_apply_Labcurve_configfile :
  filename=@{-path_tmp}/.gmic_Labcurve.dlm
  -if $filename $filename -else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) -r[-1] 100%,3 -endif

gimp_apply_Labcurve_preview :
  (${1--3}) -r[-1] 13,3,1,1,-1 -o[-1] @{-path_tmp}/.gmic_Labcurve.dlm -rm[-1]
  -function1d $13,0,$1,\
                  @{"-if {$2>=0} -u $2,$3, -else -u \"\" -endif"}\
                  @{"-if {$4>=0} -u $4,$5, -else -u \"\" -endif"}\
                  @{"-if {$6>=0} -u $6,$7, -else -u \"\" -endif"}\
                  @{"-if {$8>=0} -u $8,$9, -else -u \"\" -endif"}\
                  @{"-if {$10>=0} -u $10,$11, -else -u \"\" -endif"}\
                  255,$12
  -function1d $26,0,$14,\
                  @{"-if {$15>=0} -u $15,$16, -else -u \"\" -endif"}\
                  @{"-if {$17>=0} -u $17,$18, -else -u \"\" -endif"}\
                  @{"-if {$19>=0} -u $19,$20, -else -u \"\" -endif"}\
                  @{"-if {$21>=0} -u $21,$22, -else -u \"\" -endif"}\
                  @{"-if {$23>=0} -u $23,$24, -else -u \"\" -endif"}\
                  255,$25
  -function1d $39,0,$27,\
                  @{"-if {$28>=0} -u $28,$29, -else -u \"\" -endif"}\
                  @{"-if {$30>=0} -u $30,$31, -else -u \"\" -endif"}\
                  @{"-if {$32>=0} -u $32,$33, -else -u \"\" -endif"}\
                  @{"-if {$34>=0} -u $34,$35, -else -u \"\" -endif"}\
                  @{"-if {$36>=0} -u $36,$37, -else -u \"\" -endif"}\
                  255,$38
  -a[-3--1] y -mv[-1] 0
  -repeat {@#-1}
    --gimp_split_preview[-1] "-gimp_apply_Labcurve 0",$-1
    -axes[-1] 0,255,255,0,13,1,255
    100%,100% -axes[-1] 0,255,255,0,13,1,255 --dilate[-1] 3 -r[-2] [-3] -j[-3] [-2],0,0,0,0,1,[-1],255 -rm[-2,-1]
    -grid[-1] 10%,10%,0,0,0.3,0xCCCCCCCC,255
    -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -if $-2
        [-1],[-1],1,1,-{$-2*255/100} -to_gray[-3] -histogram[-3] 256,0,255 -graph[-1] [-3],3,0,0,0,1,0
        -rm[-3] -+[-1] {$-2*255/100} -+[-2,-1] -c[-1] 0,255
     -else -rm[-2] -endif
     -line[-1] 0,100%,100%,0,0.3,0xCCCCCCCC,255
     -sh[0] 0,0,0,0
     -graph[-2] [-1],1,0,255,0,1,255,255,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,200,200 -rm[-1]
     -sh[0] 1,1,0,0
     -graph[-2] [-1],1,0,255,0,1,255,128,128 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,200,0,0 -rm[-1]
     -sh[0] 2,2,0,0
     -graph[-2] [-1],1,0,255,0,1,128,128,255 --[-1] 1
     -graph[-2] [-1],1,0,255,0,0.5,0,0,200 -rm[-1]
     -if {$40==0}
       -_gimp_apply_curve_preview 0,$1,0 -_gimp_apply_curve_preview $2,$3,1
       -_gimp_apply_curve_preview $4,$5,2 -_gimp_apply_curve_preview $6,$7,3
       -_gimp_apply_curve_preview $8,$9,4 -_gimp_apply_curve_preview $10,$11,5
       -_gimp_apply_curve_preview 255,$12,6
     -elif {$40==1}
       -_gimp_apply_curve_preview 0,$14,0 -_gimp_apply_curve_preview $15,$16,1
       -_gimp_apply_curve_preview $17,$18,2 -_gimp_apply_curve_preview $19,$20,3
       -_gimp_apply_curve_preview $21,$22,4 -_gimp_apply_curve_preview $23,$24,5
       -_gimp_apply_curve_preview 255,$25,6
     -else
       -_gimp_apply_curve_preview 0,$27,0 -_gimp_apply_curve_preview $28,$29,1
       -_gimp_apply_curve_preview $30,$31,2 -_gimp_apply_curve_preview $32,$33,3
       -_gimp_apply_curve_preview $34,$35,4 -_gimp_apply_curve_preview $36,$37,5
       -_gimp_apply_curve_preview 255,$38,6
     -endif
  -mv[-1] 1 -done -rm[0]

#@gimp Decompose channels : gimp_decompose_channels, gimp_decompose_channels_preview
#@gimp : Color basis = choice(7,"RGB","HSV","HSL","HSI","YUV","YCbCr","XYZ","Lab","Lch","CMY","CMYK")
#@gimp : Action = choice("Decompose","Recompose")
#@gimp : Use multiple layers = bool(0)
#@gimp : Include opacity layer = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_decompose_channels :
  -if {!$2} # Decompose
    -if $4 -to_rgba -else -to_rgb -endif
    -repeat @# -l[-1]
      -split_opacity -_gimp_decompose_channels$1[0]
      -s[0] c -if {!$3} -a x -endif
      nb=@#
    -endl -mv[-$nb--1] 0 -done
  -else # Recompose
    -channels 0 nbc={3+($1==10)} nb={$nbc+$4}
    -if $3 -repeat {int(@#/$nb)} -l[0-{$nb-1}]
      -a[0-{$nbc-1}] c -_gimp_recompose_channels$1[0] -a c
    -endl -mv[-1] 0 -done
    -else -repeat @# -l[$>]
      -s x,$nb -a[0-{$nbc-1}] c -_gimp_recompose_channels$1[0] -a c
    -endl -mv[-1] 0 -done -endif
  -endif

gimp_decompose_channels_preview :
  -gimp_decompose_channels ${^0} -append_tiles ,

_gimp_decompose_channels0 :
_gimp_decompose_channels1 : -rgb2hsv8
_gimp_decompose_channels2 : -rgb2hsl8
_gimp_decompose_channels3 : -rgb2hsi8
_gimp_decompose_channels4 : -rgb2yuv8
_gimp_decompose_channels5 : -rgb2ycbcr
_gimp_decompose_channels6 : -rgb2xyz8
_gimp_decompose_channels7 : -rgb2lab8
_gimp_decompose_channels8 : -rgb2lch8
_gimp_decompose_channels9 : -rgb2cmy
_gimp_decompose_channels10 : -rgb2cmyk

_gimp_recompose_channels0 :
_gimp_recompose_channels1 : -hsv82rgb
_gimp_recompose_channels2 : -hsl82rgb
_gimp_recompose_channels3 : -hsi82rgb
_gimp_recompose_channels4 : -yuv82rgb
_gimp_recompose_channels5 : -ycbcr2rgb
_gimp_recompose_channels6 : -xyz82rgb
_gimp_recompose_channels7 : -lab82rgb
_gimp_recompose_channels8 : -lch82rgb
_gimp_recompose_channels9 : -cmy2rgb
_gimp_recompose_channels10 : -cmyk2rgb

#@gimp Detect skin : gimp_detect_skin, gimp_detect_skin_preview(1)
#@gimp : Skin estimation = choice(1,"Manual","Automatic")
#@gimp : sep = separator()
#@gimp : Tolerance = float(0.5,0,1)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Threshold = float(1,0,10)
#@gimp : Pre-normalize image = bool(1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Manual estimation:</b>\n
#@gimp : Use the sliders below to target as much skin pixels as you can.</small>")
#@gimp : X-coordinate = float(50,0,100)
#@gimp : Y-coordinate = float(50,0,100)
#@gimp : Radius = float(5,0,25)
#@gimp : sep = separator()
#@gimp : Output mode = choice(1,"Probability map","Opaque skin","Transparent skin")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2014/01/03</i>.</small>")
gimp_detect_skin :
  -to_rgb
  -m "_gimp_detect_skin :
        -if $5 -balance_gamma 128,128,128 -endif
        -if $1 -detect_skin $2 -else -detect_skin $2,$6%,$7%,$8% -endif
        M={iM} -b $3% -* {255*$M/iM} -* $4 -c 0,255"
  -repeat @# -l[$>]
    -if $9  # Opaque/transparent skin.
      --_gimp_detect_skin -a c
      -if {$9>1} -sh 100%,100% -*[-1] -1 -+[-1] 255 -rm[-1] -endif
    -else -_gimp_detect_skin # Probability mask.
    -endif
  -endl -done
  -uncommand _gimp_detect_skin

gimp_detect_skin_preview :
  -gimp_split_preview "-gimp_detect_skin $*",$-1
  -if {!$1}
    -circle $6%,$7%,$8%,0.3,0,255,0,255
    -circle $6%,$7%,$8%,1,0xFFFFFFFF,0,255,0,255
    -line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
    -line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,1,255,255,0,255
  -endif

#@gimp Equalize HSV : gimp_hsv_equalizer, gimp_hsv_equalizer_preview
#@gimp : Preview bands = bool(false)
#@gimp : sep = separator()
#@gimp : Hue band = float(180,0,360)
#@gimp : Band width = float(40,1,360)
#@gimp : Hue shift = float(0,-180,180)
#@gimp : Saturation correction = float(0,-0.99,0.99)
#@gimp : Value correction = float(0,-0.99,0.99)
#@gimp : sep = separator()
#@gimp : Hue band = float(180,0,360)
#@gimp : Band width = float(40,1,360)
#@gimp : Hue shift = float(0,-180,180)
#@gimp : Saturation correction = float(0,-0.99,0.99)
#@gimp : Value correction = float(0,-0.99,0.99)
#@gimp : sep = separator()
#@gimp : Hue band = float(180,0,360)
#@gimp : Band width = float(40,1,360)
#@gimp : Hue shift = float(0,-180,180)
#@gimp : Saturation correction = float(0,-0.99,0.99)
#@gimp : Value correction = float(0,-0.99,0.99)
#@gimp : sep = separator()
#@gimp : note = note("<small>Author: <i>J&#233;rome Ferrari</i>.      Latest update: <i>2011/01/14</i>.</small>")
#@gimp : note = link("Filter explained here","http://www.flickr.com/groups/gmic/discuss/72157625798533482")
gimp_hsv_equalizer :
  -repeat @# -local[@{>,-1}]
  -to_rgb -rgb2hsv -split c
# From now on 0,1,2 are H,S,V
#3 masks:
  --f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
  --f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
  --f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0)
# From now on 3,4,5 are Masks
  --threshold[1,2] 0.01 -*[-1,-2] [-1]x2 -*[-1,3] -*[-1,4] -*[-1,5]	#0 saturation and value not in mask
# Hue shift:
  --*[3] $4 --*[4] $9 --*[5] $14 -+[-1,-2,-3]
  -+[-1,0] -%[0] 360
# Saturation :
  -if {$5>=0} --*[3] -$5 -else --*[3] {1/(1+$5)-1} -endif -+[-1] 1
  -if {$10>=0} --*[4] -$10 -else --*[4] {1/(1+$10)-1} -endif -+[-1] 1
  -if {$15>=0} --*[5] -$15 -else --*[5] {1/(1+$15)-1} -endif -+[-1] 1
  -*[-1,-2,-3] -^[1,-1]
# Value :
  -if {$6>=0} --*[3] -$6 -else --*[3] {1/(1+$6)-1} -endif -+[-1] 1
  -if {$11>=0} --*[4] -$11 -else --*[4] {1/(1+$11)-1} -endif -+[-1] 1
  -if {$16>=0} --*[5] -$16 -else --*[5] {1/(1+$16)-1} -endif -+[-1] 1
  -*[-1,-2,-3] -^[2,-1]
#reconstruction
  -rm[3,4,5] -append[0,1,2] c -hsv2rgb
  -endlocal -done

gimp_hsv_equalizer_preview :
-local[-1]
  -if {$1==0} -gimp_hsv_equalizer $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16
  -else
    -to_rgb -rgb2hsv -split c
    (0,359) -resize[-1] [-2],{@{0,h}/10},1,1,3 [-1] -f[-1] 1	#create lower band
    -j[0] [3],0,91% -j[1] [4],0,91% -j[2] [4],0,91% -rm[-1,-2] #paste lower band
    --f[0] if(abs(i-$2)<$3/2|abs(i-$2-360)<$3/2|abs(i-$2+360)<$3/2,1,0)
    --f[0] if(abs(i-$7)<$8/2|abs(i-$7-360)<$8/2|abs(i-$7+360)<$8/2,1,0)
    --f[0] if(abs(i-$12)<$13/2|abs(i-$12-360)<$13/2|abs(i-$12+360)<$13/2,1,0) #masks
    -or[-3--1] -+[-1] 0.33 -/[-1] 1.33	#1 and 0.25
    -*[2,-1] -append c -hsv2rgb
  -endif
-endlocal

#@gimp Mixer [RGB] : gimp_mix_rgb, gimp_mix_rgb_preview(1)
#@gimp : Red contrast = float(1,0,4)
#@gimp : Red brightness = float(0,-255,255)
#@gimp : Red smoothness = float(0,0,10)
#@gimp : Green contrast = float(1,0,4)
#@gimp : Green brightness = float(0,-255,255)
#@gimp : Green smoothness = float(0,0,10)
#@gimp : Blue contrast = float(1,0,4)
#@gimp : Blue brightness = float(0,-255,255)
#@gimp : Blue smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_start_mix :
  -if {$1==1} --tones[-1] 3 -+[-2,-1] -b[-2,-1] $2% -r[-2,-1] [-3] -*[-1] [-3] -mv[-3] @#
  -elif {$1==2} --tones[-1] 3 -+[-3,-1] -b[-2,-1] $2% -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -elif {$1==3} --tones[-1] 3 -+[-3,-2] -b[-2,-1] $2% -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @#
  -endif
gimp_end_mix :
  -if {$1==1} -*[-3,-1] -+[-2,-1]
  -elif {$1==2} -*[-2,-1] -+[-2,-1]
  -elif {$1==3} -*[-2,-1] -+[-2,-1]
  -endif

gimp_mix_rgb :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $10,$11
    --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -b[-3] $3%
    -*[-2] $4 -+[-2] $5 -b[-2] $6%
    -*[-1] $7 -+[-1] $8 -b[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255
    -gimp_end_mix $10
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_rgb_preview :
  -gimp_split_preview "-gimp_mix_rgb $*",$-1

#@gimp Mixer [YCbCr] : gimp_mix_ycbcr, gimp_mix_ycbcr_preview(1)
#@gimp : Luminance contrast = float(1,0,4)
#@gimp : Luminance brightness = float(0,-255,255)
#@gimp : Luminance smoothness = float(0,0,10)
#@gimp : Blue chroma contrast = float(1,0,4)
#@gimp : Blue chroma brightness = float(0,-255,255)
#@gimp : Blue chroma smoothness = float(0,0,10)
#@gimp : Red chroma contrast = float(1,0,4)
#@gimp : Red chroma brightness = float(0,-255,255)
#@gimp : Red chroma smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_mix_ycbcr :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2ycbcr[-1] --[-1] 128 -s[-1] c
    -*[-3] $1 -+[-3] $2 -b[-3] $3%
    -*[-2] $4 -+[-2] $5 -b[-2] $6%
    -*[-1] $7 -+[-1] $8 -b[-1] $9%
    -a[-3--1] c -+[-1] 128 -c[-1] 0,255 -ycbcr2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_ycbcr_preview :
  -gimp_split_preview "-gimp_mix_ycbcr $*",$-1

#@gimp Mixer [HSV] : gimp_mix_hsv, gimp_mix_hsv_preview(1)
#@gimp : Hue contrast = float(1,0,4)
#@gimp : Hue brightness = float(0,-180,180)
#@gimp : Hue smoothness = float(0,0,10)
#@gimp : Saturation contrast = float(1,0,4)
#@gimp : Saturation brightness = float(0,-1,1)
#@gimp : Saturation smoothness = float(0,0,10)
#@gimp : Value contrast = float(1,0,4)
#@gimp : Value brightness = float(0,-1,1)
#@gimp : Value smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_mix_hsv :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $10,$11
    -rgb2hsv[-1] -s[-1] c --[-2,-1] 0.5
    -*[-3] $1 -+[-3] $2 -b[-3] $3%
    -*[-2] $4 -+[-2] $5 -b[-2] $6%
    -*[-1] $7 -+[-1] $8 -b[-1] $9%
    -%[-3] 360 -+[-2,-1] 0.5 -c[-2,-1] 0,1 -a[-3--1] c -hsv2rgb[-1]
    -gimp_end_mix $10
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_hsv_preview :
  -gimp_split_preview "-gimp_mix_hsv $*",$-1

#@gimp Mixer [Lab] : gimp_mix_lab, gimp_mix_lab_preview(1)
#@gimp : Lightness contrast = float(1,0.5,1.5)
#@gimp : Lightness brightness = float(0,-50,50)
#@gimp : Lightness smoothness = float(0,0,10)
#@gimp : A-color contrast = float(1,0,4)
#@gimp : A-color brightness = float(0,-20,20)
#@gimp : A-color smoothness = float(0,0,10)
#@gimp : B-color contrast = float(1,0,4)
#@gimp : B-color brightness = float(0,-20,20)
#@gimp : B-color smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_mix_lab :
  -repeat @# -l[$>] -split_opacity -to_rgb[0]
    -gimp_parallel_overlap[0] "-_gimp_mix_lab $*",0,{3*max($3,$6,$9)}
    -a c
  -endl -mv[$>] 0 -done

_gimp_mix_lab :
  -gimp_start_mix $10,$11
  -rgb2lab[-1] -s[-1] c
  -*[-3] $1 -+[-3] $2 -b[-3] $3%
  -*[-2] $4 -+[-2] $5 -b[-2] $6%
  -*[-1] $7 -+[-1] $8 -b[-1] $9%
  -a[-3--1] c -lab2rgb[-1]
  -gimp_end_mix $10

gimp_mix_lab_preview :
  -gimp_split_preview "-gimp_mix_lab $*",$-1

#@gimp Mixer [CMYK] : gimp_mix_cmyk, gimp_mix_cmyk_preview(1)
#@gimp : Cyan contrast = float(1,0,4)
#@gimp : Cyan brightness = float(0,-255,255)
#@gimp : Cyan smoothness = float(0,0,10)
#@gimp : Magenta contrast = float(1,0,4)
#@gimp : Magenta brightness = float(0,-255,255)
#@gimp : Magenta smoothness = float(0,0,10)
#@gimp : Yellow contrast = float(1,0,4)
#@gimp : Yellow brightness = float(0,-255,255)
#@gimp : Yellow smoothness = float(0,0,10)
#@gimp : Key contrast = float(1,0,4)
#@gimp : Key brightness = float(0,-255,255)
#@gimp : Key smoothness = float(0,0,10)
#@gimp : note = note()
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_mix_cmyk :
  -repeat @# -l[-1] -split_opacity -rv -to_rgb[-1]
    -gimp_start_mix $13,$14
    -rgb2cmyk[-1] -s[-1] c
    -*[-4] $1 -+[-4] $2 -b[-4] $3%
    -*[-3] $4 -+[-3] $5 -b[-3] $6%
    -*[-2] $7 -+[-2] $8 -b[-2] $9%
    -*[-1] $10 -+[-1] $11 -b[-1] $12%
    -a[-4--1] c -cmyk2rgb[-1]
    -gimp_end_mix $13
  -if {@#!=3} -rv -a c -endif -endl -mv[-1] 0 -done

gimp_mix_cmyk_preview :
  -gimp_split_preview "-gimp_mix_cmyk $*",$-1

#@gimp Replace color : gimp_replace_color, gimp_replace_color(0)
#@gimp : Tolerance = float(100,1,450)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Replaced color = color(0,0,0,0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_replace_color :
  -to_rgba -replace_color $1,$2%,${3--1} -c 0,255

#@gimp Select color : gimp_select_color, gimp_select_color(1)
#@gimp : Similarity space = choice(0,"RGB[A]","RGB","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue & Red chrominances","Hue","Saturation")
#@gimp : Tolerance = float(20,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Output as = choice(0,"Selected colors","Selected mask")
#@gimp : Invert selection = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_select_color :
  -if {$1==1} -to_rgb                            # RGB
  -elif {$1==2} -to_rgb -rgb2ycbcr               # YCbCr
  -elif {$1==3} -channels 0                      # R
  -elif {$1==4} -channels 1                      # G
  -elif {$1==5} -channels 2                      # B
  -elif {$1==6} -to_rgba -channels 3             # Opacity
  -elif {$1==7} -to_rgb -rgb2ycbcr -channels 0   # Luminance
  -elif {$1==8} -to_rgb -rgb2ycbcr -channels 1,2 # B&R chrominances
  -elif {$1==9} -to_rgb -rgb2hsv -channels 0     # Hue
  -elif {$1==10} -to_rgb -rgb2hsv -channels 1    # Saturation
  -endif

gimp_select_color :
  ($4^$5^$6^$7) -_gimp_select_color[-1] $1 color=@-1 -rm[-1]
  -repeat @#
    -if {$8==0}                                  # Output selected colors.
      --_gimp_select_color[-1] $1
      -select_color[-1] $2%,$color
      -b[-1] $3%
      -if $9 -*[-1] -1 -+[-1] 1 -endif
      -to_rgba[-2] -s[-2] c -*[-2,-1] -a[-4--1] c
    -else
      -_gimp_select_color[-1] $1
      -select_color[-1] $2%,$color
      -b[-1] $3
      -if $9 -*[-1] -1 -+[-1] 1 -endif
      -*[-1] 255 -r[-1] 100%,100%,1,4
    -endif
  -mv[-1] 0 -done

#@gimp Sepia : gimp_sepia, gimp_sepia_preview
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_sepia :
  -sepia
  -repeat @#
    -sh[-1] 0,2 -apply_gamma[-1] {10^$1} --[-1] 128 -*[-1] $2 -+[-1] {128+$3} -c[-1] 0,255
  -rm[-1] -mv[-1] 0 -done

gimp_sepia_preview :
  -gimp_split_preview "-gimp_sepia $*",$-1

#@gimp User-defined : gimp_custom_transform, gimp_custom_transform
#@gimp : Red - Green - Blue - Alpha = text{"i"}
#@gimp : Red - Green - Blue = text{"i + 90*(x/w)*cos(i/10)"}
#@gimp : Red = text{"i"}
#@gimp : Green = text{"i"}
#@gimp : Blue = text{"i"}
#@gimp : Alpha = text{"i"}
#@gimp : Value normalization = choice("None","RGB","RGBA")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_custom_transform :
  -to_rgba -repeat @#
    -f[-1] "$1"
    -s[-1] c -a[-4--2] c -f[-2] "$2"
    -s[-2] c -f[-4] "$3" -f[-3] "$4" -f[-2] "$5" -f[-1] "$6"
    -if {$7==0} -a[-4--1] c -c[-1] 0,255
    -elif {$7==1} -a[-4--2] c -n[-2] 0,255 -c[-1] 0,255 -a[-2,-1] c
    -else -a[-4--1] c -n[-1] 0,255
    -endif
  -mv[-1] 0 -done


#@gimp _<b>Contours</b>
#----------------------

#@gimp Convolve : gimp_convolve, gimp_convolve_preview(0)
#@gimp : Kernel = choice("Custom","Average 3x3","Average 5x5","Average 7x7","Average 9x9","Prewitt-X","Prewitt-Y","Sobel-X","Sobel-Y","Rotinv-X","Rotinv-Y","Laplacian","Robert Cross 1","Robert Cross 2","Impulses 5x5","Impulses 7x7","Impulses 9x9")
#@gimp : Boundary = choice(1,"Dirichlet","Neumann")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> If parameter <i>Kernel</i> is set to <i>Custom</i>, it uses the custom convolution kernel defined below. Use commas and semicolons as separators for res. matrix columns and rows.</small>")
#@gimp : Custom kernel = text("0,1,0;1,-4,1;0,1,0")
#@gimp : sep = separator(), note = note("<small><b>Note:</b> Kernel multiplier is useful only when parameter <i>Value range</i> is set to <i>Cut</i>.</small>")
#@gimp : Value range = choice(1,"Cut","Normalize")
#@gimp : Kernel multiplier = float(1,0,50)
#@gimp : sep = separator()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/06</i>.</small>")
gimp_convolve :
  -apply_channels "-_gimp_convolve $1,$2,\"$3\",${4--3}",$-2,0

_gimp_convolve :
  -if $1 -_gimp_convolve$1[] -else ($3) -endif
  -if {!$4} -*[-1] $5 -endif
  -convolve[0--2] [-1],$2
  -if $4 -n 0,255 -else -c 0,255 -endif
  -rm[-1]

_gimp_convolve1 : 3,3 -f 1 -normalize_sum  # Average 3x3
_gimp_convolve2 : 5,5 -f 1 -normalize_sum  # Average 5x5
_gimp_convolve3 : 7,7 -f 1 -normalize_sum  # Average 7x7
_gimp_convolve4 : 9,9 -f 1 -normalize_sum  # Average 9x9
_gimp_convolve5 : (1,0,-1;1,0,-1;1,0,-1)  # Prewitt-X
_gimp_convolve6 : (1,1,1;0,0,0;-1,-1,-1)  # Prewitt-Y
_gimp_convolve7 : (1,0,-1;2,0,-2;1,0,-1)  # Sobel-X
_gimp_convolve8 : (1,2,1;0,0,0;-1,-2,-1)  # Sobel-Y
_gimp_convolve9 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,0,-$a;$b,0,-$b;$a,0,-$a)  # Rotinv-X
_gimp_convolve10 : a={0.25*(2-sqrt(2))} b={0.5*(sqrt(2)-1)} ($a,$b,$a;0,0,0;-$a,-$b,-$a) # Rotinv-Y
_gimp_convolve11 : (0,1,0;1,-4,1;0,1,0)    # Laplacian
_gimp_convolve12 : (1,0;0,-1)             # Robert Cross1
_gimp_convolve13 : (0,1;-1,0)             # Robert Cross2
_gimp_convolve14 : 3,3 -f 1 -r 7,7,1,1,4,0,0.5,0.5 -autocrop -normalize_sum # Impulse 5x5
_gimp_convolve15 : 3,3 -f 1 -r 9,9,1,1,4,0,0.5,0.5 -autocrop -normalize_sum # Impulse 7x7
_gimp_convolve16 : 3,3 -f 1 -r 11,11,1,1,4,0,0.5,0.5 -autocrop -normalize_sum # Impulse 9x9

gimp_convolve_preview :
  -gimp_split_preview "-gimp_convolve $1,$2,\"$3\",${4--1}",$-1

#@gimp Curvature : gimp_curvature, gimp_curvature_preview(0)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_curvature :
  -repeat @# -l[$>] -split_opacity -l[0]
    -b $1 -iee
    -if $4 -abs -endif
    -c $2%,$3%
    -if $5 -negative -endif
    -n 0,255
  -endl -a c -endl -done

gimp_curvature_preview :
  -gimp_split_preview "-gimp_curvature ${^0}",$-1

#@gimp Difference of gaussians : gimp_dog, gimp_dog_preview(1)
#@gimp : 1st Variance = float(1.4,0,5)
#@gimp : 2nd Variance = float(1.5,0,5)
#@gimp : Threshold = float(0,0,49)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_dog :
  -dog $1%,$2%
  -c $3%,{100-$3}%
  -if $4 -negative -endif
  -n 0,255

gimp_dog_preview :
  -gimp_split_preview "-gimp_dog ${^0}",$-1

#@gimp Distance transform : gimp_distance, gimp_distance_preview(0)
#@gimp : Value = int(128,0,255)
#@gimp : Metric = choice(2,"Chebyshev","Manhattan","Euclidean","Squared-Euclidean")
#@gimp : Normalization = choice(2,"Cut","Normalize","Modulo")
#@gimp : Modulo value = int(32,1,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/04/07</i>.</small>")
gimp_distance :
  -repeat @# -l[$>] -split_opacity -l[0]
    -distance $1,$2
    -if {$3==0} -c 0,255
    -elif {$3==1} -n 0,255
    -else -% $4 -n 0,255
    -endif
  -endl -a c -endl -done

gimp_distance_preview :
  -gimp_split_preview "-gimp_distance ${^0}",$-1

#@gimp Edges : gimp_edges, gimp_edges_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(15,0,50)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_edges :
  -to_rgb -b $1% -edges $2%
  -if $3 -negative -endif
  -n 0,255

gimp_edges_preview :
  -gimp_split_preview "-gimp_edges ${^0}",$-1

#@gimp Edges offsets : gimp_edge_offsets, gimp_edge_offsets_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(15,0,50)
#@gimp : Scale = int(4,0,32)
#@gimp : Thickness = int(1,0,16)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_edge_offsets :
  -repeat @#
    os={s}
    -b[-1] $1% -gradient_norm[-1] -ge[-1] $2% -skeleton[-1] 0 -distance[-1] 1 -round[-1] 1 -%[-1] $3 -ge[-1] {max(1,$3-$4)}
    -if {!$5} -negative[-1] -endif
    -n[-1] 0,255 -to_colormode[-1] $os
  -mv[-1] 0 -done

gimp_edge_offsets_preview :
  -gimp_split_preview "-gimp_edge_offsets ${^0}",$-1

#@gimp Gradient norm : gimp_gradient_norm, gimp_gradient_norm_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Linearity = float(0.5,0,1.5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_gradient_norm :
  -b $1 -gradient_norm -^ $2
  -c $3%,$4%
  -if $5 -negative -endif
  -n 0,255

gimp_gradient_norm_preview :
  -gimp_split_preview "-gimp_gradient_norm ${^0}",$-1

#@gimp Gradient RGB : gimp_gradient2rgb, gimp_gradient2rgb_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Orientation only = bool(0)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_gradient2rgb :
  -b $1 -gradient2rgb $4
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

gimp_gradient2rgb_preview :
  -gimp_split_preview "-gimp_gradient2rgb ${^0}",$-1

#@gimp Isophotes : gimp_isophotes, gimp_isophotes_preview(0)
#@gimp : Levels = int(8,1,256)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Filling = choice(1,"Transparent","Colors")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_isophotes :
  -if $3
    -topographic_map $1,$2
  -else
    -b $2 -isophotes $1
  -endif

gimp_isophotes_preview :
  -gimp_split_preview "-gimp_isophotes ${^0}",$-1

#@gimp Laplacian : gimp_laplacian, gimp_laplacian_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_laplacian :
  -b $1 -laplacian
  -if $4 -abs -endif
  -c $2%,$3%
  -if $5 -negative -endif
  -n 0,255

gimp_laplacian_preview :
  -gimp_split_preview "-gimp_laplacian ${^0}",$-1

#@gimp Local orientation : gimp_local_orientation, gimp_local_orientation_preview(1)
#@gimp : Smoothness = float(0,0,5)
#@gimp : Min threshold = float(0,0,100)
#@gimp : Max threshold = float(100,0,100)
#@gimp : Negative colors = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_local_orientation :
  -b $1% -gradient_orientation 2 -complex2polar -rm[0--1:2]
  -c $2%,$3%
  -if $4 -negative -endif

gimp_local_orientation :
  -apply_channels "-_gimp_local_orientation $1,$2,$3,$4",$5,1

gimp_local_orientation_preview :
  -gimp_split_preview "-gimp_local_orientation ${^0}",$-1

#@gimp Morphological filter : gimp_morpho, gimp_morpho_preview(0)
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gimp : Size = int(5,2,60)
#@gimp : Invert colors = bool(false)
#@gimp : Shape = choice(0,"Square","Octagonal","Circular")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Scale = bool(true)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_morpho :
  -apply_channels "-__gimp_morpho ${^0}",$5,$6

gimp_morpho_preview :
  -gimp_split_preview "-gimp_morpho ${^0}",$-1

__gimp_morpho :
  -if {$4==1} suf="_oct" -elif {$4==0} suf="" -else suf="_circ" -endif
  -if {$1==0} -erode$suf $2
  -elif {$1==1} -dilate$suf $2
  -elif {$1==2} -erode$suf $2 -dilate$suf $2
  -elif {$1==3} -dilate$suf $2 -erode$suf $2
  -elif {$1==4} -repeat @# --erode$suf $2 --[-2,-1] -mv[-1] 0 -done
  -elif {$1==5} -repeat @# --dilate$suf $2 -rv[-2,-1] --[-2,-1] -mv[-1] 0 -done
  -elif {$1==6} -repeat @# --erode$suf $2 -dilate$suf[-1] $2 --[-2,-1] -mv[-1] 0 -done
  -else -repeat @# --dilate$suf $2 -erode$suf[-1] $2 -rv[-2,-1] --[-2,-1] -mv[-1] 0 -done
  -endif
  -if $3 -repeat @# -l[$>] -split_opacity -negative[0] -a c -endl -done -endif

#@gimp Segmentation : gimp_segment_watershed, gimp_segment_watershed_preview(0)
#@gimp : Edge threshold = float(2,0,15)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_segment_watershed :
  -apply_channels "-b $2 -segment_watershed $1",$3,0

gimp_segment_watershed_preview :
  -gimp_split_preview "-gimp_segment_watershed ${^0}",$-1

#@gimp Skeleton : gimp_skeleton, gimp_skeleton_preview(1)
#@gimp : Method = choice("Distance","Thinning")
#@gimp : Smoothness = float(0,0,10)
#@gimp : Curviness = float(0,0,10)
#@gimp : Multiple channels = bool(1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/04/07</i>.</small>")
gimp_skeleton :
  -if {!$4} -norm -endif
  -b $2%
  -if $1 -thinning -else -skeleton $3% -endif
  -* 255

gimp_skeleton_preview :
  -gimp_split_preview "-gimp_skeleton ${^0}",$-1

#@gimp Thin edges : gimp_thin_edges, gimp_thin_edges_preview(0)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(15,0,50)
#@gimp : Negative colors = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_thin_edges :
  -b $1% -gradient_norm -ge $2% -thinning
  -if {!$3} -negative -endif
  -n 0,255

gimp_thin_edges_preview :
  -gimp_split_preview "-gimp_thin_edges ${^0}",$-1


#@gimp _<b>Deformations</b>
#--------------------------

#@gimp Cartesian transform : gimp_custom_deformation, gimp_custom_deformation(1)
#@gimp : X-warping = text{"(w+h)/20 * cos(y*20/h)"}
#@gimp : Y-warping = text{"(w+h)/20 * sin(x*20/w)"}
#@gimp : Relative warping = bool(1)
#@gimp : Interpolation = choice(1,"Nearest neighbor","Linear")
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_custom_deformation :
   -repeat @#
    --norm[-1] [-1] -f[-2] "$1" -f[-1] "$2"
    -a[-2,-1] c -warp[-2] [-1],$3,$4,$5,1 -rm[-1]
  -mv[-1] 0 -done

#@gimp Circle transform : gimp_circle_transform, gimp_circle_transform_preview(1)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : X-scale = float(-2,-16,16)
#@gimp : Y-scale = float(-2,-16,16)
#@gimp : Radius = float(0.2,0,1)
#@gimp : Symmetry = choice("None","Inside","Outside")
#@gimp : Interpolation = choice(1,"Nearest neighbor","Linear")
#@gimp : Boundary = choice(1,"Transparent","Nearest","Repeat")
#@gimp : Preview reference circle = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/08</i>.</small>")
gimp_circle_transform :
  -repeat @# -l[$>] -to_rgba
    r={$5*sqrt(w^2+h^2)}
    -if {$6==0} cond="i(X,Y,z,c,$7,$8)"
    -elif {$6==1} cond="if(N<"$r",i(X,Y,z,c,$7,$8),i)"
    -else cond="if(N>"$r",i(X,Y,z,c,$7,$8),i)"
    -endif
    -f 'U=x-w*$1;V=y-h*$2;N=sqrt(U*U+V*V);Nr=N-$r;X=x+$3*Nr*U/N;Y=y+$4*Nr*V/N;$cond'
  -endl -done

gimp_circle_transform_preview :
  -gimp_circle_transform $*
  -repeat @# -l[$>]
    x0={$1*w}
    y0={$2*h}
    r={$5*sqrt(w^2+h^2)}
    -if $9
      -circle $x0,$y0,{$r-1},1,0xFFFFFFFF,0,0,0,255
      -circle $x0,$y0,{$r+1},1,0xFFFFFFFF,0,0,0,255
      -circle $x0,$y0,$r,1,0xFFFFFFFF,0,255,0,255
    -endif
  -endl -done

#@gimp Euclidean - polar : gimp_euclidean2polar, gimp_euclidean2polar(1)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Dilation = float(1,0.1,10)
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : Inverse transform = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_euclidean2polar :
  -if $5 -polar2euclidean $1,$2,$3,$4 -else -euclidean2polar $1,$2,$3,$4 -endif

#@gimp Fish-eye : fisheye, fisheye(1)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius = float(70,0,100)
#@gimp : Amplitude = float(1,0,2)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Flower : gimp_flower, gimp_flower(1)
#@gimp : Amplitude = float(30,-100,100)
#@gimp : Petals = int(6,0,20)
#@gimp : Offset = float(0,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_flower :
  -flower $1,$2,$3%,$4,$5,$6,$7

#@gimp Kaleidoscope [blended] : gimp_rotoidoscope, gimp_rotoidoscope(1)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Angular tiles = int(10,1,72)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Boundary = choice(2,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_rotoidoscope :
  -rotoidoscope {$1*100}%,{$2*100}%,$3,$4%,$5

#@gimp Kaleidoscope [polar] : gimp_kaleidoscope, gimp_kaleidoscope(1)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Radius cut = float(100,0,100)
#@gimp : Angle cut = float(10,0,100)
#@gimp : Boundary = choice(2,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_kaleidoscope :
  -shift $3%,$4%,0,0,2 -kaleidoscope $1,$2,$5,$6,$7

#@gimp Kaleidoscope [symmetry] : gimp_symmetrizoscope, gimp_symmetrizoscope(1)
#@gimp : Iterations = int(4,1,32)
#@gimp : Angle = float(0,0,360)
#@gimp : Boundary = choice(1,"Transparent","Nearest","Repeat")
#@gimp : Symmetry sides = choice("Backward","Forward","Swap")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/07</i>.</small>")
gimp_symmetrizoscope :
  -to_rgba -repeat $1
    ang={$2+180*$>/max(1,$1-1)}
    -symmetrize 50%,50%,$ang,$3,0,{if($4!=2,$4,$>%2)}
  -done

#@gimp Perspective : gimp_warp_perspective, gimp_warp_perspective(1)
#@gimp : X-angle = float(1.73,-4,4)
#@gimp : Y-angle = float(0,-4,4)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Boundary = choice(2,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_warp_perspective :
  -shift $6%,$7%,0,0,2 -warp_perspective $1,$2,$3,$4,$5,$8

#@gimp Polar transform : gimp_transform_polar, gimp_transform_polar(1)
#@gimp : Preset = choice("Custom transform","Inverse radius","Swap radius/angle")
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Radius = text{"r + R/10*cos(a*5)"}
#@gimp : Angle = text{"a"}
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_transform_polar :
  -if {$1==0}
    -transform_polar "$4","$5",$2,$3,$6
  -elif {$1==1}
    -transform_polar R-r,a,$2,$3,$6
  -else
    -transform_polar a*R/(2*pi),r*2*pi/R,$2,$3,$6
  -endif

#@gimp Raindrops : raindrops, raindrops(0)
#@gimp : Amplitude = float(80,0,300)
#@gimp : Density = float(0.1,0,1)
#@gimp : Wavelength = float(1,0,2)
#@gimp : Merging steps = int(0,0,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/28</i>.</small>")

#@gimp Random : deform, deform(0)
#@gimp : Amplitude = float(10,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Ripple : ripple, ripple(0)
#@gimp : Amplitude = float(10,0,100)
#@gimp : Size = float(20,1,300)
#@gimp : Shape = choice(2,"Bloc","Triangle","Sine","Sine+","Random")
#@gimp : Angle = float(0,0,360)
#@gimp : Offset = float(0,0,500)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/08/23</i>.</small>")

#@gimp Reflection : gimp_reflect, gimp_reflect(1)
#@gimp : Height = float(50,0,100)
#@gimp : Attenuation = float(1,0.1,4)
#@gimp : Color = color(110,160,190,64)
#@gimp : Waves amplitude = float(0,0,100)
#@gimp : Waves smoothness = float(1.5,0,4)
#@gimp : X-angle = float(0,-10,10)
#@gimp : Y-angle = float(-3.30,-10,10)
#@gimp : Focale = float(7,0,10)
#@gimp : Zoom = float(1.5,1,5)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_reflect :
  -repeat @#
    -to_rgba[-1] --rows[-1] {100-$1}%,100% -mirror[-1] y -water[-1] $7,$8
    -s[-1] c
    -f[-4] "(i*(255-$6) + $6*$3)/255"
    -f[-3] "(i*(255-$6) + $6*$4)/255"
    -f[-2] "(i*(255-$6) + $6*$5)/255" -a[-4--1] c
    -*[-1] '(h^$2-y^$2)/h^$2' -a[-2,-1] y
    100%,100%,100%,1,$11*$12*(x/w-0.5)
    100%,100%,100%,1,$11*$12*(y/h-0.5)
    100%,100%,100%,1,"$10*(x/w-0.5) + $9*(y/h-0.5) + $11"
    -/[-3] [-1] -+[-3] 0.5 -*[-3] @{-3,w}
    -/[-2,-1] -+[-1] 0.5 -*[-1] {h}
    -a[-2,-1] c -warp[-2] [-1],0,1,0 -rm[-1]
  -mv[-1] 0 -done
  -autocrop 0,0,0,0

#@gimp Sphere : gimp_map_sphere, gimp_map_sphere_preview(1)
#@gimp : Width = _int(512,1,4096)
#@gimp : Height = _int(512,1,4096)
#@gimp : Radius = float(90,0,400)
#@gimp : Dilation = float(0.5,0,1)
#@gimp : Angle = float(0,-50,50)
#@gimp : Border smoothness = float(0,0,200)
#@gimp : Border width = float(20,0,100)
#@gimp : Orientation = choice("0 deg.","90 deg.","180 deg.","270 deg.")
#@gimp : Background = choice("Transparent","Mean color")
#@gimp : Fading = float(0,0,100)
#@gimp : Fading shape = float(0.5,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/11/07</i>.</small>")
gimp_map_sphere :
  -rotate {$8*90}
  -if $6
    -repeat @#
      -shift[-1] 50%,0,0,0,2 --columns[-1] {(1-$7/100)*w/2},{(1+$7/100)*w/2}
      100% -gaussian[-1] {0.1*w},{h},0 100% 100% -a[-3--1] c -r[-1] [-2],[-2],1,3
      -smooth[-2] [-1],$6,5,0 -rm[-1]
      -j[-2] [-1],{(1-$7/100)*@{-2,w}/2} -rm[-1] -shift[-1] -50%,0,0,0,2
    -mv[-1] 0 -done
  -endif
  -shift $5%,0,0,0,2 -to_rgba
  -if $9
    -repeat @#
      --rows[$>] 0 -r[-1] 1,1,1,4,2 RGBA$>=@-1
      -r[-1] [$>],[$>],1,4 --[$>,-1]
    -done
  -endif
  -map_sphere $1,$2,$3,$4,$10,$11
  -if $9
    -repeat @#
      (${RGBA$>}) -y[-1] c -r[-1] [$>],[$>],1,4 -+[$>,-1]
    -done
  -endif

gimp_map_sphere_preview :
  -gimp_map_sphere {w},{h},${3--1}

#@gimp Symmetrize : gimp_symmetrize, gimp_symmetrize_preview(1)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : Angle = float(90,0,360)
#@gimp : Boundary = choice(1,"Transparent","Nearest","Repeat")
#@gimp : Type = choice("Symmetry","Antisymmetry")
#@gimp : Swap sides = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/07</i>.</small>")
gimp_symmetrize :
  -to_rgba -symmetrize $1%,$2%,$3,$4,$5,$6

gimp_symmetrize_preview :
  -gimp_symmetrize $*
  theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
  -repeat @# -l[$>]
    x0={w*$1%}
    y0={h*$2%}
    x1={$x0-max(w,h)*$u} y1={$y0-max(w,h)*$v}
    x2={$x0+max(w,h)*$u} y2={$y0+max(w,h)*$v}
    -line $x1,$y1,$x2,$y2,1,0x0F0F0F0F,0
    -line $x1,$y1,$x2,$y2,1,0xF0F0F0F0,255
    -circle $x0,$y0,3,1,0,255,0,255
    -circle $x0,$y0,3,1,0xFFFFFFFF,0,0,0,255
  -endl -done

#@gimp Textured glass : gimp_textured_glass, gimp_textured_glass_preview(0)
#@gimp : X-amplitude = float(40,0,400)
#@gimp : Y-amplitude = float(40,0,400)
#@gimp : X-smoothness = float(1,0,5)
#@gimp : Y-smoothness = float(1,0,5)
#@gimp : Edge attenuation = float(0,0,1)
#@gimp : Edge influence = float(2,0,10)
#@gimp : Noise scale = int(0,0,16)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/21</i>.</small>")
gimp_textured_glass :
  -repeat @# -l[$>]
    100%,100%,1,1
    -if $7 -plasma[-1] 1,1,$7 -else -rand[-1] 0,1 -endif
    -g[-1] xy
    -if $5
      --gradient_norm[-3] -+[-1] 1 -b[-1] $6 -pow[-1] -$5
      -*[-3] [-1] -*[-2,-1]
    -endif
    -blur_xy[-2,-1] $3,$4
    -*[-2] @{-2,$1/max(abs(im),abs(iM))}
    -*[-1] @{-1,$2/max(abs(im),abs(iM))}
    -a[-2,-1] c
    -warp[-2] [-1],1,1 -rm[-1]
  -endl -done

gimp_textured_glass_preview :
  -gimp_split_preview "-gimp_textured_glass $*",$-1

#@gimp Twirl : twirl, twirl(1)
#@gimp : Amplitude = float(1,-5,5)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Water : water, water(0)
#@gimp : Amplitude = float(30,0,300)
#@gimp : Smoothness = float(1.5,0,4)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Wave : wave, wave(1)
#@gimp : Amplitude = float(10,0,30)
#@gimp : Frequency = float(0.4,0,2)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Wind : gimp_wind, gimp_wind_preview(0)
#@gimp : Amplitude = int(20,0,500)
#@gimp : Angle = float(0,0,360)
#@gimp : Attenuation = float(0.7,0,1)
#@gimp : Threshold = float(20,0,100)
#@gimp : Mode = choice(1,"Darker","Brighter")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/07/13</i>.</small>")
gimp_wind :
  -if {!$5} -negative -endif
  -apply_channels "-wind ${1-4}",$-2
  -if {!$5} -negative -endif

gimp_wind_preview :
  -gimp_split_preview "-gimp_wind $*",$-1

#@gimp Zoom : gimp_zoom, gimp_zoom(1)
#@gimp : Factor = float(2,0.01,10)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Boundary = choice(0,"Black","Nearest","Repeat")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_zoom :
  -if {$1<1} -to_rgba -endif
  -zoom $1,$2,$3,0,$4


#@gimp _<b>Degradations</b>
#---------------------------

#@gimp Blur [angular] : gimp_blur_angular, gimp_blur_angular(1)
#@gimp : Amplitude = float(2,0,10)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Sharpness = float(0,0,500)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_blur_angular :
  -apply_channels "-blur_angular $1%,$2,$3 -sharpen $4",$5,$6

#@gimp Blur [gaussian] : gimp_gaussian_blur, gimp_gaussian_blur_preview(0)
#@gimp : XY-amplitude = float(3,0,20)
#@gimp : X-amplitude = float(0,0,20)
#@gimp : Y-amplitude = float(0,0,20)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_gaussian_blur :
  -b $1,$4
  -if {$2>0} -repeat @# -l[-1] -s y -b $2,$4 -a y -endl -mv[-1] 0 -done -endif
  -if {$3>0} -repeat @# -l[-1] -s x -b $3,$4 -a x -endl -mv[-1] 0 -done -endif

gimp_gaussian_blur :
  -apply_channels "-_gimp_gaussian_blur $1,$2,$3,$4",$5,$6

gimp_gaussian_blur_preview :
  -gimp_split_preview "-gimp_gaussian_blur $*",$-1

#@gimp Blur [glow] : gimp_glow, gimp_glow_preview(0)
#@gimp : Amplitude = float(6,0,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_glow :
  -apply_channels "-glow $1",$2,0

gimp_glow_preview :
  -gimp_split_preview "-gimp_glow $*",$-1

#@gimp Blur [linear] : gimp_blur_linear, gimp_blur_linear_preview(1)
#@gimp : Tangent radius = float(10,0,100)
#@gimp : Orthogonal radius = float(0.5,0,100)
#@gimp : Angle = float(0,0,180)
#@gimp : Sharpness = float(0,0,500)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_blur_linear :
  -apply_channels "-blur_linear $1,{$2*$1/100},$3,$5 -sharpen $4",$6,$7

gimp_blur_linear_preview :
  -gimp_split_preview "-gimp_blur_linear $*",$-1

#@gimp Blur [radial] : gimp_blur_radial, gimp_blur_radial(1)
#@gimp : Amplitude = float(3,0,20)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Sharpness = float(0,0,500)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_blur_radial :
  -apply_channels "-blur_radial $1%,$2,$3 -sharpen $4",$5,$6

#@gimp Lomo : gimp_lomo, gimp_lomo_preview(1)
#@gimp : Vignette size = float(20,0,100)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>J&#233;rome Boulanger, David Tschumperl&#233;</i>.      Latest update: <i>2012/06/06</i>.</small>")
gimp_lomo :
  -remove_opacity -repeat @# -l[$>]
    --gaussian {100-$1}%,{100-$1}% -normalize[-1] 0,1 -*
    -s c
    -f[0] '255*atan((i-128)/128)'
    -f[1] '255*tan((i-128)/128)'
    -f[2] '255*atan((i-128)/255)'
    -a c
    -sharpen 1
    -normalize 0,255
  -endl -done

gimp_lomo_preview :
  -gimp_split_preview "-gimp_lomo $*",$-1

#@gimp Noise [additive] : gimp_noise, gimp_noise_preview(0)
#@gimp : Amplitude = float(10,0,200)
#@gimp : Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_noise :
  -apply_channels "-noise $1,$2",$3,$4

gimp_noise_preview :
  -gimp_split_preview "-gimp_noise $*",$-1

#@gimp Noise [spread] : gimp_spread, gimp_spread_preview(0)
#@gimp : X-variations = float(4,0,20)
#@gimp : Y-variations = float(4,0,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_spread :
  -apply_channels "-spread $1,$2",$3,0

gimp_spread_preview :
  -gimp_split_preview "-gimp_spread $*",$-1

#@gimp Old-movie stripes : gimp_stripes_y, gimp_stripes_y_preview(1)
#@gimp : Frequency = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_stripes_y :
  -apply_channels "-stripes_y $1",$2,0

gimp_stripes_y_preview :
  -gimp_split_preview "-gimp_stripes_y $*",$-1

#@gimp Oldschool 8bits : gimp_8bits, gimp_8bits_preview(0)
#@gimp : Scale = float(25,1,100)
#@gimp : Dithering = float(800,0,10000)
#@gimp : Levels = int(16,2,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/11/02</i>.</small>")
gimp_8bits :
  -remove_opacity -repeat @# -l[$>]
    w={w} h={h}
    -r $1%,$1%,1,100%,2
    --luminance -sharpen[-1] $2 -otsu[-1] 256 -blend[-2,-1] shapeaverage0
    -l[-1] -s c -quantize $3,1,1 -a c -endl
    -resize[-1] $w,$h,1,100%,1
  -endl -done

gimp_8bits_preview :
  -gimp_split_preview "-gimp_8bits $*",$-1

#@gimp Random shade stripes : gimp_shade_stripes, gimp_shade_stripes_preview(1)
#@gimp : Frequency = float(30,1,100)
#@gimp : Orientation = choice(1,"Horizontal","Vertical")
#@gimp : Darkness = float(0.8,0,3)
#@gimp : Lightness = float(1.3,0,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_shade_stripes :
  -apply_channels "-shade_stripes $1,$2,$3,$4",$5,0

gimp_shade_stripes_preview :
  -gimp_split_preview "-gimp_shade_stripes $*",$-1

#@gimp Visible watermark : gimp_watermark_visible, gimp_watermark_visible(0)
#@gimp : Text = text{"(c) G'MIC"}
#@gimp : Opacity = float(0.4,0.1,0.9)
#@gimp : Size = int(57,13,128)
#@gimp : Angle = float(25,0,360)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Lightness = choice(1,"Darker","Brighter")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_watermark_visible :
  -watermark_visible "$1",$2,$3,$4,$6,$5

#@gimp _<b>Details</b>
#----------------------

#@gimp Details equalizer : gimp_equalize_details, gimp_equalize_details_preview(0)
#@gimp : note = note("<small><b>Coarse scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-2,2)
#@gimp : sep = separator(), note = note("<small><b>Medium scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-2,2)
#@gimp : sep = separator(), note = note("<small><b>Small scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-2,2)
#@gimp : sep = separator(), note = note("<small><b>Fine scale:</b></small>")
#@gimp : Threshold = float(0,0,10)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Smoothness type = choice(2,"Gaussian","Bilateral","Diffusion")
#@gimp : Gain = float(0,-2,2)
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(32,0,256)
#@gimp : sep = separator(), Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/12/15</i>.</small>")
_gimp_equalize_details :
  -repeat @# -l[$>]
    -split_details 5,5%,0.5%
    -__gimp_equalize_details[1] ${1-4},8
    -__gimp_equalize_details[2] ${5-8},4
    -__gimp_equalize_details[3] ${9-12},2
    -__gimp_equalize_details[4] ${13-16},1
    -+ -c 0,255
  -endl -done

__gimp_equalize_details :
  -threshold $1,1
  -if {$3==0} -b {$2*$5/2}
  -elif {$3==1}
    -if {$2>0}
      m={im} M={iM} -n[-1] 0,255
      -repeat {int($2/5)} -bilateral 15,{5*$5} -done
      -bilateral 15,{($2%5)*$5}
      -*[-1] {($M-$m)/255} -+[-1] $m
    -endif
  -else -smooth {$2*50},0.2,0.8,$5,$5 -endif
  -* {10^$4}

gimp_equalize_details :
  -apply_channels "-gimp_parallel_overlap \"-_gimp_equalize_details ${1-16}\",$17,$18",$19,0

gimp_equalize_details_preview :
  -gimp_split_preview "-gimp_equalize_details $*",$-1

#@gimp Freaky details : gimp_freaky_details, gimp_freaky_details_preview(0)
#@gimp : Amplitude = int(2,1,5)
#@gimp : Scale = float(10,0,100)
#@gimp : Iterations = int(1,1,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(32,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Patrick David</i>.      Latest update: <i>2013/02/27</i>.</small>")
#@gimp : sep = separator(), note = note("This effect has been done following:")
#@gimp : link = link("This tutorial from Patrick David","http://blog.patdavid.net/2013/02/calvin-hollywood-freaky-details-in-gimp.html")
_gimp_freaky_details :
  -repeat @# -l[$>]
    -repeat $3
      [-1] ---[-1] 255 -*[-1] -1
      -repeat $1 -bilateral[-1] $2,{1.5*$2} -done
      -blend[-2,-1] vividlight -blend overlay
    -done
  -endl -done

gimp_freaky_details :
  -apply_channels "-gimp_parallel_overlap \"-_gimp_freaky_details ${1-3}\",$5,$6",$4,0
  -n 0,255

gimp_freaky_details_preview :
  -gimp_split_preview "-gimp_freaky_details $*",$-1

#@gimp Local normalization : gimp_normalize_local, gimp_normalize_local_preview(0)
#@gimp : Amplitude = float(2,0,60)
#@gimp : Radius = int(6,1,64)
#@gimp : Neighborhood smoothness = float(5,0,40)
#@gimp : Average smoothness = float(20,0,40)
#@gimp : Constrain values = bool(1)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_normalize_local :
  -apply_channels "-normalize_local $1,$2,$3,$4,$5,0,255",$6,0

gimp_normalize_local_preview :
  -gimp_split_preview "-gimp_normalize_local $*",$-1

#@gimp Sharpen [deblur] : gimp_deblur, gimp_deblur_preview(0)
#@gimp : Radius = float(2,0,20)
#@gimp : Iterations = int(10,0,100)
#@gimp : Time step = float(20,0,50)
#@gimp : Smoothness = float(0.1,0,10)
#@gimp : Regularization = choice(1,"Tikhonov","Mean curvature","Total variation")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_deblur :
  -apply_channels "-gimp_parallel_overlap \"-deblur ${1-5} -c 0,255\",$7,$8",$6,0

gimp_deblur_preview :
  -gimp_split_preview "-gimp_deblur $*",$-1

#@gimp Sharpen [Gold-Meinel] : gimp_unsharp_goldmeinel, gimp_unsharp_goldmeinel_preview
#@gimp : Sigma = float(1,0.5,10)
#@gimp : Iterations = int(5,1,15)
#@gimp : Acceleration = float(1,1,3)
#@gimp : Blur = choice(1,"Exponential","Gaussian")
#@gimp : Cut = bool(true)
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
gimp_unsharp_goldmeinel:
  -gimp_parallel_overlap "-deblur_goldmeinel $* -if $5 -c 0,255 -else -n 0,255 -endif",$6,$7

gimp_unsharp_goldmeinel_preview:
  -gimp_split_preview "-gimp_unsharp_goldmeinel $*",$-1

#@gimp Sharpen [inverse diffusion] : gimp_sharpen_inversediff, gimp_sharpen_inversediff_preview(0)
#@gimp : Amplitude = float(50,1,300)
#@gimp : Iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_sharpen_inversediff :
  -apply_channels "-gimp_parallel_overlap \"-repeat $2 -sharpen $1 -c 0,255 -done\",$4,$5",$3,0

gimp_sharpen_inversediff_preview :
  -gimp_split_preview "-gimp_sharpen_inversediff $*",$-1

#@gimp Sharpen [octave sharpening] : gimp_unsharp_octave, gimp_unsharp_octave_preview(0)
#@gimp : Scales = int(4,1,10)
#@gimp : Maximal radius = float(5,0,20)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,255)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_unsharp_octave :
  -apply_channels "-gimp_parallel_overlap \"-unsharp_octave $1,$2,$3,$4\",$6,$7",$5,0

gimp_unsharp_octave_preview :
  -gimp_split_preview "-gimp_unsharp_octave $*",$-1

#@gimp Sharpen [Richardson-Lucy] : gimp_unsharp_richardsonlucy, gimp_unsharp_richardsonlucy_preview
#@gimp : Sigma = float(1,0.5,10)
#@gimp : Iterations = int(10,1,100)
#@gimp : Blur = choice(1,"Exponential","Gaussian")
#@gimp : Cut = bool(true)
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
gimp_unsharp_richardsonlucy :
  -gimp_parallel_overlap "-deblur_richardsonlucy $* -if $4 -c 0,255 -else -n 0,255 -endif",$5,$6

gimp_unsharp_richardsonlucy_preview :
  -gimp_split_preview "-gimp_unsharp_richardsonlucy $*",$-1

#@gimp Sharpen [shock filters] : gimp_sharpen_shock, gimp_sharpen_shock_preview(0)
#@gimp : Amplitude = float(150,1,400)
#@gimp : Edge threshold = float(0.1,0,0.7)
#@gimp : Gradient smoothness = float(0.8,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_sharpen_shock :
  -apply_channels "-gimp_parallel_overlap \"-repeat $5 -sharpen $1,$2,$3,$4 -c 0,255 -done\",$7,$8",$6,0

gimp_sharpen_shock_preview :
  -gimp_split_preview "-gimp_sharpen_shock $*",$-1

#@gimp Sharpen [unsharp mask] : gimp_unsharp, gimp_unsharp_preview(0)
#@gimp : Sharpening type = choice(0,"Gaussian","Bilateral")
#@gimp : Spatial radius = float(1.25,0,20)
#@gimp : Bilateral radius = float(30,0,60)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,20)
#@gimp : Darkness level = float(1,0,4)
#@gimp : Lightness level = float(1,0,4)
#@gimp : Iterations = int(1,1,10)
#@gimp : Negative effect = bool(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : note = note{"\n\n<small><b>Note: </b>
#@gimp : This filter is inspired by the original <i>Unsharp Mask</i> filter in GIMP, with additional parameters.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_unsharp :
  -repeat @# -repeat $8
    -if {$1==0} --b[-1] $2 -else --bilateral[-1] $2,$3 -endif
    --[-1] [-2] -*[-1] -$4
    --norm[-1] -ge[-1] $5% -r[-1] [-2] -*[-2,-1]
    -if $9 -*[-1] -1 -endif
    --c[-1] 0,100% -c[-2] -100%,0 -*[-2] $6 -*[-1] $7 -+[-2,-1]
    -+[-2,-1] -c[-1] 0,255
  -done -mv[-1] 0 -done

gimp_unsharp :
  -apply_channels "-_gimp_unsharp $1,$2,$3,$4,$5,$6,$7,$8,$9",$10,0

gimp_unsharp_preview :
  -gimp_split_preview "-gimp_unsharp $*",$-1

#@gimp Split details : gimp_split_details, gimp_split_details_preview(0)
#@gimp : Action = choice{"Decompose/update","Recompose"}
#@gimp : sep = separator(), note = note("<small><b>Decompose options:</b></small>")
#@gimp : Number of scales = int(3,2,16)
#@gimp : Base scale = float(5,0,20)
#@gimp : Details scale = float(1,0,20)
#@gimp : Output mode = choice(2,"Row","Column","Tiling")
#@gimp : sep = separator()
#@gimp : Preview type = choice(3,"Base scale","Details scales","Finest details scale","All scales")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Instructions of use:</b>\n
#@gimp : 1. Set parameter <i>Action</i> to <i>Decompose/update</i> and choose decompose parameters. Then click <i>OK</i>.\n
#@gimp : 2. Process your image. For instance, remove details in the appropriate scales using the neutral color <i>(128,128,128)</i>.\n
#@gimp : 3. Use <i>CTRL+F</i> to apply the filter again (update mode). The preview of the resulting recomposed image updated and shown at the top left of your canvas.\n
#@gimp : 4. Repeat steps 2. and 3. as many times as you want.\n
#@gimp : 5. When you are happy with the result, open the G'MIC plug-in once again, set parameter <i>Action</i> to <i>Recompose</i>, and click <i>OK</i>.\n
#@gimp : 6. Get your final modified image alone.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/12/14</i>.</small>")
gimp_split_details :
  -remove_opacity
  -if {$1==1} -repeat @# -l[$<]
    --rows 0 vlist=@{-1,t} -rm[-1]
    magick={arg(1,$vlist)} nb_imgs={1+arg(2,$vlist)} mode={arg(3,$vlist)}
    -if {$magick!=71777367||$nb_imgs<2||$mode<0||$mode>2} -error "" -endif

    # Recompose.
    -if {$mode==0} -s x,$nb_imgs -elif {$mode==1} -s y,$nb_imgs
    -else N={int(sqrt($nb_imgs))} M={round($nb_imgs/$N,1,1)} -split_tiles $M,$N -k[0-{$nb_imgs-1}]
    -endif
    -rm[0] -l[^0] -- 128 -repeat @# -*[$>] {arg($>+4,$vlist)/127} -done -endl -+ -c 0,255
  -onfail -error "Cannot recompose image, decompose it before trying to recompose it !"
  -endl -done

  -else -repeat @# -l[$<]
    --rows 0 vlist=@{-1,t} -rm[-1]
    magick={arg(1,$vlist)} nb_imgs={1+arg(2,$vlist)} mode={arg(3,$vlist)}
    -if {$magick!=71777367||$nb_imgs<2||$mode<0||$mode>2} -error "" -endif

    # Update.
    --l
      -if {$mode==0} -s x,$nb_imgs -elif {$mode==1} -s y,$nb_imgs
      -else N={int(sqrt($nb_imgs))} M={round($nb_imgs/$N,1,1)} -split_tiles $M,$N -k[0-{$nb_imgs-1}]
      -endif
      -rm[0] -l[^0] -- 128 -repeat @# -*[$>] {arg($>+4,$vlist)/127} -done -endl -+ -c 0,255
    -endl
    -j[0] [1] -rm[1] ({'$vlist'},0) -j[0] [1] -rm[1]
  -onfail

    # Decompose.
    --split_details $2,$3,$4
    vlist=71777367,$2,$5
    -l[2--1] -repeat @#
      fact={round(max(abs(im),abs(iM)),0.01)} vlist=$vlist,$fact -*[$>] {127/$fact}
    -done -+ 128 -endl -c 0,255
    -if {$5==0} -a x -elif {$5==1} -a y -else -append_tiles , -endif
    ({'$vlist'},0) -j[0] [1] -rm[1]

  -endl -done -endif

gimp_split_details_preview :
  -remove_opacity
  -if $1 -gimp_no_preview ,
  -else -repeat @# -l[$>]
    --split_details $2,$3,$4 -n[2--1] 0,255
    -if {$6==0} -k[1] -elif {$6==1} -k[2--1] -append_tiles , -elif {$6==2} -k[-1] -else -append_tiles , -endif
  -endl -done -endif

#@gimp Tone mapping : gimp_map_tones, gimp_map_tones_preview(0)
#@gimp : Threshold = float(0.5,0,1)
#@gimp : Gamma = float(0.7,0,1)
#@gimp : Smoothness = float(0.1,0,10)
#@gimp : Iterations = int(30,0,500)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_map_tones :
  -apply_channels "-map_tones ${1-4}",$5,0
  -n 0,255

gimp_map_tones_preview :
  -gimp_split_preview "-gimp_map_tones $*",$-1

#@gimp Tone mapping [fast] : gimp_map_tones_fast, gimp_map_tones_fast_preview(0)
#@gimp : Radius = float(3,0,20)
#@gimp : Power = float(0.5,0,1)
#@gimp : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Paul Nasca</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/06/10</i>.</small>")
gimp_map_tones_fast :
  -apply_channels "-map_tones_fast $1,$2",$3,0

gimp_map_tones_fast_preview :
  -gimp_split_preview "-gimp_map_tones_fast ${^0}",$-1

#@gimp _<b>Film emulation</b>
#----------------------------

#@gimp B&amp;W films : gimp_emulate_film_bw, gimp_emulate_film_bw_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Agfa APX 100","Agfa APX 25","Fuji Neopan 1600","Fuji Neopan Acros 100","Ilford Delta 100","Ilford Delta 3200","Ilford Delta 400","Ilford FP4 Plus 125",
#@gimp : "Ilford HP5 Plus 400","Ilford HPS 800","Ilford Pan F Plus 50","Ilford XP2","Kodak BW 400 CN","Kodak HIE (HS Infra)","Kodak T-Max 100","Kodak T-Max 3200",
#@gimp : "Kodak T-Max 400","Kodak Tri-X 400","Polaroid 664","Polaroid 667","Polaroid 672","Rollei IR 400","Rollei Ortho 25","Rollei Retro 100 Tonal","Rollei Retro 80s"}
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_bw :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_bw :
  -u agfa_apx_100,agfa_apx_25,fuji_neopan_1600,fuji_neopan_acros_100,ilford_delta_100,ilford_delta_3200,ilford_delta_400,ilford_fp4_plus_125,\
     ilford_hp5_plus_400,ilford_hps_800,ilford_pan_f_plus_50,ilford_xp2,kodak_bw_400_cn,kodak_hie_(hs_infra),kodak_t-max_100,kodak_t-max_3200,\
     kodak_t-max_400,kodak_tri-x_400,polaroid_664,polaroid_667,polaroid_672,rollei_ir_400,rollei_ortho_25,rollei_retro_100_tonal,rollei_retro_80s

gimp_emulate_film_bw_preview :
  -gimp_split_preview "-gimp_emulate_film_bw $*",$-1

#@gimp Grain : gimp_grain, gimp_grain_preview(0)
#@gimp : Amplitude = float(40,0,512)
#@gimp : Tone smoothness = float(5,0,15)
#@gimp : Grain type = choice("Gaussian","Uniform")
#@gimp : Channel(s) = choice(2,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Shadows:</b></small>")
#@gimp : Strength = float(0.8,0,1)
#@gimp : Scale = float(0.5,0,2)
#@gimp : Channel correlation = float(0.5,0,1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Mid-tones:</b></small>")
#@gimp : Strength = float(1,0,1)
#@gimp : Scale = float(0,0,2)
#@gimp : Channel correlation = float(0.5,0,1)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Highlights:</b></small>")
#@gimp : Strength = float(0.6,0,1)
#@gimp : Scale = float(0.2,0,2)
#@gimp : Channel correlation = float(0.5,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/21</i>.</small>")
gimp_grain :
  -repeat @# -l[$>] -apply_channels "-_gimp_grain ${1-13}",$4,0 -endl -done

_gimp_grain :
  -if {!$1} -return -endif
  s={s} --luminance

  # Shadows.
  -if $5
    100%,100%,1,$s -noise[-1] 1,$3 -b[-1] $6 -*[-1] {(1-$7)/max(abs(im),abs(iM))}
    100%,100%,1,1 -noise[-1] 1,$3 -b[-1] $6 -*[-1] {$7/max(abs(im),abs(iM))}
    -+[-2,-1] --t2[1] 0,85 -b[-1] $2 -n[-1] 0,1 -*[-2,-1] -*[-1] $5
  -endif

  # Midlights.
  -if $8
    100%,100%,1,$s -noise[-1] 1,$3 -b[-1] $9 -*[-1] {(1-$10)/max(abs(im),abs(iM))}
    100%,100%,1,1 -noise[-1] 1,$3 -b[-1] $9 -*[-1] {$10/max(abs(im),abs(iM))}
    -+[-2,-1] --t2[1] 86,169 -b[-1] $2 -n[-1] 0,1 -*[-2,-1] -*[-1] $8
  -endif

  # Highlights.
  -if $11
    100%,100%,1,$s -noise[-1] 1,$3 -b[-1] $12 -*[-1] {(1-$13)/max(abs(im),abs(iM))}
    100%,100%,1,1 -noise[-1] 1,$3 -b[-1] $12 -*[-1] {$13/max(abs(im),abs(iM))}
    -+[-2,-1] --t2[1] 170,256 -b[-1] $2 -n[-1] 0,1 -*[-2,-1] -*[-1] $11
  -endif

  -rm[1] -+[-3--1] -n[-1] -$1,$1 -+ -c 0,255

gimp_grain_preview :
  -gimp_split_preview "-gimp_grain $*",$-1

#@gimp Instant [consumer] : gimp_emulate_film_instant_consumer, gimp_emulate_film_instant_consumer_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Polaroid PX-100UV+ Cold --","Polaroid PX-100UV+ Cold -","Polaroid PX-100UV+ Cold","Polaroid PX-100UV+ Cold +","Polaroid PX-100UV+ Cold ++","Polaroid PX-100UV+ Cold +++",
#@gimp : "Polaroid PX-100UV+ Warm --","Polaroid PX-100UV+ Warm -","Polaroid PX-100UV+ Warm","Polaroid PX-100UV+ Warm +","Polaroid PX-100UV+ Warm ++","Polaroid PX-100UV+ Warm +++",
#@gimp : "Polaroid PX-680 --","Polaroid PX-680 -","Polaroid PX-680","Polaroid PX-680 +","Polaroid PX-680 ++",
#@gimp : "Polaroid PX-680 Cold --","Polaroid PX-680 Cold -","Polaroid PX-680 Cold","Polaroid PX-680 Cold +","Polaroid PX-680 Cold ++","Polaroid PX-680 Cold ++a",
#@gimp : "Polaroid PX-680 Warm --","Polaroid PX-680 Warm -","Polaroid PX-680 Warm","Polaroid PX-680 Warm +","Polaroid PX-680 Warm ++",
#@gimp : "Polaroid PX-70 --","Polaroid PX-70 -","Polaroid PX-70","Polaroid PX-70 +","Polaroid PX-70 ++","Polaroid PX-70 +++",
#@gimp : "Polaroid PX-70 Cold --","Polaroid PX-70 Cold -","Polaroid PX-70 Cold","Polaroid PX-70 Cold +","Polaroid PX-70 Cold ++",
#@gimp : "Polaroid PX-70 Warm --","Polaroid PX-70 Warm -","Polaroid PX-70 Warm","Polaroid PX-70 Warm +","Polaroid PX-70 Warm ++",
#@gimp : "Polaroid Time Zero (Expired) ---","Polaroid Time Zero (Expired) --","Polaroid Time Zero (Expired) -","Polaroid Time Zero (Expired)","Polaroid Time Zero (Expired) +","Polaroid Time Zero (Expired) ++",
#@gimp : "Polaroid Time Zero (Expired) Cold ---","Polaroid Time Zero (Expired) Cold --","Polaroid Time Zero (Expired) Cold -","Polaroid Time Zero (Expired) Cold"}
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_instant_consumer :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_instant_consumer :
  -u polaroid_px-100uv+_cold_--,polaroid_px-100uv+_cold_-,polaroid_px-100uv+_cold,polaroid_px-100uv+_cold_+,polaroid_px-100uv+_cold_++,polaroid_px-100uv+_cold_+++,\
     polaroid_px-100uv+_warm_--,polaroid_px-100uv+_warm_-,polaroid_px-100uv+_warm,polaroid_px-100uv+_warm_+,polaroid_px-100uv+_warm_++,polaroid_px-100uv+_warm_+++,\
     polaroid_px-680_--,polaroid_px-680_-,polaroid_px-680,polaroid_px-680_+,polaroid_px-680_++,\
     polaroid_px-680_cold_--,polaroid_px-680_cold_-,polaroid_px-680_cold,polaroid_px-680_cold_+,polaroid_px-680_cold_++,polaroid_px-680_cold_++_alt,\
     polaroid_px-680_warm_--,polaroid_px-680_warm_-,polaroid_px-680_warm,polaroid_px-680_warm_+,polaroid_px-680_warm_++,\
     polaroid_px-70_--,polaroid_px-70_-,polaroid_px-70,polaroid_px-70_+,polaroid_px-70_++,polaroid_px-70_+++,\
     polaroid_px-70_cold_--,polaroid_px-70_cold_-,polaroid_px-70_cold,polaroid_px-70_cold_+,polaroid_px-70_cold_++,\
     polaroid_px-70_warm_--,polaroid_px-70_warm_-,polaroid_px-70_warm,polaroid_px-70_warm_+,polaroid_px-70_warm_++,\
     polaroid_time_zero_(expired)_---,polaroid_time_zero_(expired)_--,polaroid_time_zero_(expired)_-,polaroid_time_zero_(expired),polaroid_time_zero_(expired)_+,polaroid_time_zero_(expired)_++,\
     polaroid_time_zero_(expired)_cold_---,polaroid_time_zero_(expired)_cold_--,polaroid_time_zero_(expired)_cold_-,polaroid_time_zero_(expired)_cold

gimp_emulate_film_instant_consumer_preview :
  -gimp_split_preview "-gimp_emulate_film_instant_consumer $*",$-1

#@gimp Instant [pro] : gimp_emulate_film_instant_pro, gimp_emulate_film_instant_pro_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Fuji FP-100c --","Fuji FP-100c -","Fuji FP-100c","Fuji FP-100c +","Fuji FP-100c ++","Fuji FP-100c ++a","Fuji FP-100c +++",
#@gimp : "Fuji FP-100c Cool --","Fuji FP-100c Cool -","Fuji FP-100c Cool","Fuji FP-100c Cool +","Fuji FP-100c Cool ++",
#@gimp : "Fuji FP-100c Negative --","Fuji FP-100c Negative -","Fuji FP-100c Negative","Fuji FP-100c Negative +","Fuji FP-100c Negative ++","Fuji FP-100c Negative ++a","Fuji FP-100c Negative +++",
#@gimp : "Fuji FP-3000b --","Fuji FP-3000b -","Fuji FP-3000b","Fuji FP-3000b +","Fuji FP-3000b ++","Fuji FP-3000b +++",
#@gimp : "Fuji FP-3000b HC",
#@gimp : "Fuji FP-3000b Negative --","Fuji FP-3000b Negative -","Fuji FP-3000b Negative","Fuji FP-3000b Negative +","Fuji FP-3000b Negative ++","Fuji FP-3000b Negative +++",
#@gimp : "Fuji FP-3000b Negative Early",
#@gimp : "Polaroid 665 --","Polaroid 665 -","Polaroid 665","Polaroid 665 +","Polaroid 665 ++",
#@gimp : "Polaroid 665 Negative -","Polaroid 665 Negative","Polaroid 665 Negative +",
#@gimp : "Polaroid 665 Negative HC",
#@gimp : "Polaroid 669 --","Polaroid 669 -","Polaroid 669","Polaroid 669 +","Polaroid 669 ++","Polaroid 669 +++",
#@gimp : "Polaroid 669 Cold --","Polaroid 669 Cold -","Polaroid 669 Cold","Polaroid 669 Cold +",
#@gimp : "Polaroid 690 --","Polaroid 690 -","Polaroid 690","Polaroid 690 +","Polaroid 690 ++",
#@gimp : "Polaroid 690 Cold --","Polaroid 690 Cold -","Polaroid 690 Cold","Polaroid 690 Cold +","Polaroid 690 Cold ++",
#@gimp : "Polaroid 690 Warm --","Polaroid 690 Warm -","Polaroid 690 Warm","Polaroid 690 Warm +","Polaroid 690 Warm ++"}
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_instant_pro :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_instant_pro :
  -u fuji_fp-100c_--,fuji_fp-100c_-,fuji_fp-100c,fuji_fp-100c_+,fuji_fp-100c_++,fuji_fp-100c_++_alt,fuji_fp-100c_+++,\
     fuji_fp-100c_cool_--,fuji_fp-100c_cool_-,fuji_fp-100c_cool,fuji_fp-100c_cool_+,fuji_fp-100c_cool_++,\
     fuji_fp-100c_negative_--,fuji_fp-100c_negative_-,fuji_fp-100c_negative,fuji_fp-100c_negative_+,fuji_fp-100c_negative_++,fuji_fp-100c_negative_++_alt,fuji_fp-100c_negative_+++,\
     fuji_fp-3000b_--,fuji_fp-3000b_-,fuji_fp-3000b,fuji_fp-3000b_+,fuji_fp-3000b_++,fuji_fp-3000b_+++,fuji_fp-3000b_hc,\
     fuji_fp-3000b_negative_--,fuji_fp-3000b_negative_-,fuji_fp-3000b_negative,fuji_fp-3000b_negative_+,fuji_fp-3000b_negative_++,fuji_fp-3000b_negative_+++,fuji_fp-3000b_negative_early,\
     polaroid_665_--,polaroid_665_-,polaroid_665,polaroid_665_+,polaroid_665_++,\
     polaroid_665_negative_-,polaroid_665_negative,polaroid_665_negative_+,polaroid_665_negative_hc,\
     polaroid_669_--,polaroid_669_-,polaroid_669,polaroid_669_+,polaroid_669_++,polaroid_669_+++,\
     polaroid_669_cold_--,polaroid_669_cold_-,polaroid_669_cold,polaroid_669_cold_+,\
     polaroid_690_--,polaroid_690_-,polaroid_690,polaroid_690_+,polaroid_690_++,\
     polaroid_690_cold_--,polaroid_690_cold_-,polaroid_690_cold,polaroid_690_cold_+,polaroid_690_cold_++,\
     polaroid_690_warm_--,polaroid_690_warm_-,polaroid_690_warm,polaroid_690_warm_+,polaroid_690_warm_++

gimp_emulate_film_instant_pro_preview :
  -gimp_split_preview "-gimp_emulate_film_instant_pro $*",$-1

#@gimp Negative [color] : gimp_emulate_film_negative_color, gimp_emulate_film_negative_color_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Agfa Ultra Color 100","Agfa Vista 200","Fuji Superia 200","Fuji Superia HG 1600","Fuji Superia Reala 100","Fuji Superia X-Tra 800",
#@gimp : "Kodak Elite 100 XPRO","Kodak Elite Color 200","Kodak Elite Color 400","Kodak Portra 160 NC","Kodak Portra 160 VC","Lomography Redscale 100"}
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_negative_color :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_negative_color :
  -u agfa_ultra_color_100,agfa_vista_200,fuji_superia_200,fuji_superia_hg_1600,fuji_superia_reala_100,fuji_superia_x-tra_800,\
     kodak_elite_100_xpro,kodak_elite_color_200,kodak_elite_color_400,kodak_portra_160_nc,kodak_portra_160_vc,lomography_redscale_100

gimp_emulate_film_negative_color_preview :
  -gimp_split_preview "-gimp_emulate_film_negative_color $*",$-1

#@gimp Negative [new] : gimp_emulate_film_negative_new, gimp_emulate_film_negative_new_preview(1)
#@gimp : Preset = choice{"None","Fuji 160C","Fuji 400H","Fuji 800Z","Fuji Ilford HP5","Kodak Portra 160","Kodak Portra 400","Kodak Portra 800","Kodak TMAX 3200","Kodak TRI-X 400"}
#@gimp : Effect = choice(1,"Low","Standard","High","Higher")
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_negative_new :
  -_gimp_emulate_film $1,@{-arg\ {max(1,4*$1+$2-3)},@{-_$0}},${3--1}

_gimp_emulate_film_negative_new :
  -u fuji_160c_-,fuji_160c,fuji_160c_+,fuji_160c_++,\
     fuji_400h_-,fuji_400h,fuji_400h_+,fuji_400h_++,\
     fuji_800z_-,fuji_800z,fuji_800z_+,fuji_800z_++,\
     fuji_ilford_hp5_-,fuji_ilford_hp5,fuji_ilford_hp5_+,fuji_ilford_hp5_++,\
     kodak_portra_160_-,kodak_portra_160,kodak_portra_160_+,kodak_portra_160_++,\
     kodak_portra_400_-,kodak_portra_400,kodak_portra_400_+,kodak_portra_400_++,\
     kodak_portra_800_-,kodak_portra_800,kodak_portra_800_+,kodak_portra_800_++,\
     kodak_tmax_3200_-,kodak_tmax_3200,kodak_tmax_3200_+,kodak_tmax_3200_++,\
     kodak_tri-x_400_-,kodak_tri-x_400,kodak_tri-x_400_+,kodak_tri-x_400_++

gimp_emulate_film_negative_new_preview :
  -gimp_split_preview "-gimp_emulate_film_negative_new $*",$-1

#@gimp Negative [old] : gimp_emulate_film_negative_old, gimp_emulate_film_negative_old_preview(1)
#@gimp : Preset = choice{0,"None","Fuji Ilford Delta 3200","Fuji Neopan 1600","Fuji Superia 100","Fuji Superia 400","Fuji Superia 800","Fuji Superia 1600",
#@gimp : "Kodak Portra 160 NC","Kodak Portra 160 VC","Kodak Portra 400 NC","Kodak Portra 400 UC","Kodak Portra 400 VC"}
#@gimp : Effect = choice(1,"Low","Standard","High","Higher")
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_negative_old :
  -_gimp_emulate_film $1,@{-arg\ {max(1,4*$1+$2-3)},@{-_$0}},${3--1}

_gimp_emulate_film_negative_old :
  -u fuji_ilford_delta_3200_-,fuji_ilford_delta_3200,fuji_ilford_delta_3200_+,fuji_ilford_delta_3200_++,\
     fuji_neopan_1600_-,fuji_neopan_1600,fuji_neopan_1600_+,fuji_neopan_1600_++,\
     fuji_superia_100_-,fuji_superia_100,fuji_superia_100_+,fuji_superia_100_++,\
     fuji_superia_400_-,fuji_superia_400,fuji_superia_400_+,fuji_superia_400_++,\
     fuji_superia_800_-,fuji_superia_800,fuji_superia_800_+,fuji_superia_800_++,\
     fuji_superia_1600_-,fuji_superia_1600,fuji_superia_1600_+,fuji_superia_1600_++,\
     kodak_portra_160_nc_-,kodak_portra_160_nc,kodak_portra_160_nc_+,kodak_portra_160_nc_++,\
     kodak_portra_160_vc_-,kodak_portra_160_vc,kodak_portra_160_vc_+,kodak_portra_160_vc_++,\
     kodak_portra_400_nc_-,kodak_portra_400_nc,kodak_portra_400_nc_+,kodak_portra_400_nc_++,\
     kodak_portra_400_uc_-,kodak_portra_400_uc,kodak_portra_400_uc_+,kodak_portra_400_uc_++,\
     kodak_portra_400_vc_-,kodak_portra_400_vc,kodak_portra_400_vc_+,kodak_portra_400_vc_++

gimp_emulate_film_negative_old_preview :
  -gimp_split_preview "-gimp_emulate_film_negative_old $*",$-1

#@gimp Other effects : gimp_emulate_film_others, gimp_emulate_film_others_preview(1)
#@gimp : Preset = choice{"None","60's (1)","60's (2)","60's (3)","Hong Kong",
#@gimp : "Lomo","Nostalgic","Retro","Sutro FX","Vintage","Vintage 2","Warm","Warm spring","Warm yellow"}
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_others :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_others :
  -u 60s,60s_2,60s_3,hkfilm,lomo,nostalgic,retro,sutrofx,vintage,vintage_2,warm,warm_spring,warm_yellow

gimp_emulate_film_others_preview :
  -gimp_split_preview "-gimp_emulate_film_others $*",$-1

#@gimp Slide [color] : gimp_emulate_film_colorslide, gimp_emulate_film_colorslide_preview(1)
#@gimp : Preset = choice{"None",
#@gimp : "Agfa Precisa 100","Fuji Astia 100F","Fuji FP 100C","Fuji Provia 100F","Fuji Provia 400F","Fuji Provia 400X","Fuji Sensia 100",
#@gimp : "Fuji Superia 200 XPRO","Fuji Velvia 50","Generic Fuji Astia 100","Generic Fuji Provia 100","Generic Fuji Velvia 100",
#@gimp : "Generic Kodachrome 64","Generic Kodak Ektachrome 100 VS","Kodak E-100 GX Ektachrome 100","Kodak Ektachrome 100 VS","Kodak Elite Chrome 200",
#@gimp : "Kodak Elite Chrome 400","Kodak Elite ExtraColor 100","Kodak Kodachrome 200","Kodak Kodachrome 25","Kodak Kodachrome 64","Lomography X-Pro Slide 200",
#@gimp : "Polaroid 669","Polaroid 690","Polaroid Polachrome"}
#@gimp : sep = separator()
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Hue = float(0,-180,180)
#@gimp : Saturation = float(1,0,2)
#@gimp : Post-normalize = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Patrick David</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/29</i>.</small>")
gimp_emulate_film_colorslide :
  -_gimp_emulate_film $1,@{-arg\ $1,@{-_$0}},${2--1}

_gimp_emulate_film_colorslide :
  -u agfa_precisa_100,fuji_astia_100f,fuji_fp_100c,fuji_provia_100f,fuji_provia_400f,fuji_provia_400x,fuji_sensia_100,\
     fuji_superia_200_xpro,fuji_velvia_50,generic_fuji_astia_100,generic_fuji_provia_100,generic_fuji_velvia_100,\
     generic_kodachrome_64,generic_kodak_ektachrome_100_vs,kodak_e-100_gx_ektachrome_100,kodak_ektachrome_100_vs,kodak_elite_chrome_200,\
     kodak_elite_chrome_400,kodak_elite_extracolor_100,kodak_kodachrome_200,kodak_kodachrome_25,kodak_kodachrome_64,lomography_x-pro_slide_200,\
     polaroid_669,polaroid_690,polaroid_polachrome

gimp_emulate_film_colorslide_preview :
  -gimp_split_preview "-gimp_emulate_film_colorslide $*",$-1

_gimp_emulate_film :
  -if $1
    dir=@{-path_user}
    -if {!@{-is_windows}}
      dir=$dir/.gmic_film_presets
      -if $dir -else -exec "mkdir "$dir -endif
    -endif
    -if {narg($_force_redownload)}
      -i http://gmic.sourceforge.net/data_film_presets/$2.cimgz -o[-1] $dir/gmic_$2.cimgz
    -else
      -if $dir/gmic_$2.cimgz -i $dir/gmic_$2.cimgz
      -else -i http://gmic.sourceforge.net/data_film_presets/$2.cimgz -o[-1] $dir/gmic_$2.cimgz
      -endif
    -endif
    -map_clut
  -endif
  -repeat @# -l[$>] -split_opacity
    -apply_gamma[0] {10^$3}                            # Gamma correction
    --[0] 128 -*[0] $4 -+[0] 128 -+[0] $5 -c[0] 0,255  # B&W contrast and brightness.
    -if {$6||$7!=1||$8}
      -rgb2hsv[0]
      -sh[0] 0,0 -+[-1] $6 -%[-1] 360 -rm[-1]
      -sh[0] 1,1 -*[-1] $7 -rm[-1]
      -hsv2rgb[0]
      -if $8 -n[0] 0,255 -endif
    -endif
  -a c -endl -done

#@gimp <i>[Collages]</i>
#-----------------------

#@gimp B&amp;W films - collage : gimp_emulate_film_collage_bw, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>B&amp;W</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_bw :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_bw}

#@gimp Instant - collage [consumer] : gimp_emulate_film_collage_instant_consumer, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Instant [consumer]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_instant_consumer :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_instant_consumer}

#@gimp Instant - collage [pro] : gimp_emulate_film_collage_instant_pro, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Instant [pro]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_instant_pro :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_instant_pro}

#@gimp Negative - collage [color] : gimp_emulate_film_collage_negative_color, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [color]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_negative_color :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_negative_color}

#@gimp Negative - collage [new] : gimp_emulate_film_collage_negative_new, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [new]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_negative_new :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_negative_new}

#@gimp Negative - collage [old] : gimp_emulate_film_collage_negative_old, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Negative [old]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_negative_old :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_negative_old}

#@gimp Other effects - collage : gimp_emulate_film_collage_others, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Others</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_others :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_others}

#@gimp Slide - collage [color] : gimp_emulate_film_collage_colorslide, gimp_no_preview
#@gimp : Image size = float(256,16,1024)
#@gimp : Columns for collage = int(4,1,8)
#@gimp : note = note{"<small><b>Note:</b> This filter will create a collage of all available <i>Slide [color]</i> film emulation presets
#@gimp : to show you how those presets modify the look of your image. It will also download all corresponding color profiles
#@gimp : (this may take some time at the first run).
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_collage_colorslide :
  -k[0] -if {max(w,h)>$1} -if {w>h} -r2dx $1 -else -r2dy $1 -endif -endif
  _nbc=$2 -_gimp_emulate_film_collage @{-_gimp_emulate_film_colorslide}

_gimp_emulate_film_collage :
  $=arg -progress 0
  -repeat $#
    preset=${arg{$>+1}}
    --l[0]
      -_gimp_emulate_film[0] 1,$preset,0,1,0,0,1,0
      ({'$preset'}) -replace[-1] {'_'},32 -f[-1] if(x==0&&i>={'a'}&&i<={'z'},i+{'A'}-{'a'},i) title=@{-1,t} -rm[-1]
      -text_outline[-1] $title,2,2,13,2,1,255
    -endl
    -progress {(1+$>)*100/$#}
  -done
  -text_outline[0] "Original image",2,2,13,2,1,255
  -frame 1,1,0 -frame 5,5,255 -- 255 -append_tiles {min($_nbc,@#)} -+ 255

#@gimp _

#@gimp [Download all presets] : gimp_emulate_film_download, gimp_no_preview(1)
#@gimp : note = note{"This filter will download the color profiles for all film emulation presets available in <i>G'MIC</i>,
#@gimp : and will store them as persistent data files on your hard drive. After this operation, you won't need a permanent
#@gimp : internet connection anymore, in order to use the film emulation filters."}
#@gimp : note = note()
#@gimp : note = note{"<b><span color="red">Warning:</span></b> About <b>80 Mb</b> of data will be downloaded by this filter. This can take a long time !"}
#@gimp : sep = separator()
#@gimp : Force re-download = _bool(0)
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/28</i>.</small>")
gimp_emulate_film_download :
  -_gimp_emulate_film_download @{-_gimp_emulate_film_bw},\
                               @{-_gimp_emulate_film_instant_consumer},\
                               @{-_gimp_emulate_film_instant_pro},\
                               @{-_gimp_emulate_film_negative_color},\
                               @{-_gimp_emulate_film_negative_new},\
                               @{-_gimp_emulate_film_negative_old},\
                               @{-_gimp_emulate_film_others},\
                               @{-_gimp_emulate_film_colorslide}
  -l[] 1 -progress 0
  -if $1 _force_redownload=1 -endif
  -repeat $_nb_presets -_gimp_emulate_film 1,${_preset{1+$>}},1,1,0,0,1,0 -progress {($>+1)*100/$_nb_presets} -done
  -rm -endl

_gimp_emulate_film_download :
  _nb_presets=$#
  $=_preset


#@gimp _<b>Frames</b>
#--------------------

#@gimp Droste : gimp_droste, gimp_droste_preview(1)
#@gimp : note = note("<span color=\"red\">Upper-left coordinates :</span>")
#@gimp : X0 = float(20,0,100)
#@gimp : Y0 = float(20,0,100)
#@gimp : sep = separator(), note = note("<span color=\"magenta\">Upper-right coordinates :</span>")
#@gimp : X1 = float(80,0,100)
#@gimp : Y1 = float(20,0,100)
#@gimp : sep = separator(), note = note("<span color=\"blue\">Lower-right coordinates :</span>")
#@gimp : X2 = float(80,0,100)
#@gimp : Y2 = float(80,0,100)
#@gimp : sep = separator(), note = note("<span color=\"cyan\">Lower-left coordinates :</span>")
#@gimp : X3 = float(20,0,100)
#@gimp : Y3 = float(80,0,100)
#@gimp : sep = separator()
#@gimp : Iterations = int(1,1,10)
#@gimp : X-shift = float(0,-100,100)
#@gimp : Y-shift = float(0,-100,100)
#@gimp : Angle = float(0,0,360)
#@gimp : Zoom = float(1,0.1,5)
#@gimp : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gimp : Boundary = choice(1,"Black","Nearest","Repeat")
#@gimp : Drawing mode = choice{"Replace","Replace (sharpest)","Behind","Below"}
#@gimp : View outlines only = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/06/11</i>.</small>")
gimp_droste :
  -repeat @#
    -if {$16==1} 100%,100%,1,1,'x' 100%,100%,1,1,'y' -a[-2,-1] c -endif
    -repeat $9
      x0={round($1*w/100)} y0={round($2*h/100)} x1={round($3*w/100)} y1={round($4*h/100)}
      x2={round($5*w/100)} y2={round($6*h/100)} x3={round($7*w/100)} y3={round($8*h/100)}
      100%,100%,1,2,-32767 -polygon[-1] 4,$x0,$y0,$x1,$y1,$x2,$y2,$x3,$y3,1,-65535
      -sh[-1] 0,0 -f[-1] 'if(i==-65535,x03=$x0+(y-$y0)/($y3-$y0)*($x3-$x0);x12=$x1+(y-$y1)/($y2-$y1)*($x2-$x1);(x-x03)/(x12-x03)*(w-1),i)' -rm[-1]
      -sh[-1] 1,1 -f[-1] 'if(i==-65535,y01=$y0+(x-$x0)/($x1-$x0)*($y1-$y0);y32=$y3+(x-$x3)/($x2-$x3)*($y2-$y3);(y-y01)/(y32-y01)*(h-1),i)' -rm[-1]
      xshift={w*$10/100} yshift={h*$11/100} alpha={-$12*pi/180} ca={cos($alpha)/$13} sa={sin($alpha)/$13} w2={w/2} h2={h/2}
      -f[-1] 'if(i==-32767,i,X=i(x,y,0,0)-$w2;Y=i(x,y,0,1)-$h2;if(c==0,$w2-$xshift+X*$ca-Y*$sa,$h2-$yshift+X*$sa+Y*$ca))'
      -if {$14==0} -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,i)' -rm[-1]
      -elif {$14==1} -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,w-1-i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,i)' -rm[-1]
      -elif {$14==2} -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,h-1-i)' -rm[-1]
      -else -sh[-1] 0,0 -f[-1] 'if(i==-32767,x,w-1-i)' -rm[-1] -sh[-1] 1,1 -f[-1] 'if(i==-32767,y,h-1-i)' -rm[-1]
      -endif
      -if {$16<2} -warp[-2] [-1],0,{$16==0},$15 -rm[-1]
      -else
        --warp[-2] [-1],0,1,$15 -rm[-2]
        -if {$16==3} -rv[-2,-1] -endif
        -blend[-2,-1] alpha
      -endif
    -done
    -if {$16==1} -warp[-2] [-1],0,1,1 -rm[-1] -endif
    -mv[-1] 0 -done

gimp_droste_preview :
  -if {!$17} -gimp_droste $* -else -polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,0.3,0,0,0,255 -endif
  -polygon 4,$1%,$2%,$3%,$4%,$5%,$6%,$7%,$8%,1,0xFFFFFFFF,0,0,0,255
  -ellipse $1%,$2%,3,3,0,1,255,0,0,255 -ellipse $1%,$2%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  -ellipse $3%,$4%,3,3,0,1,255,0,255,255 -ellipse $3%,$4%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  -ellipse $5%,$6%,3,3,0,1,0,0,255,255 -ellipse $5%,$6%,3,3,0,1,0xFFFFFFFF,0,0,0,255
  -ellipse $7%,$8%,3,3,0,1,0,255,255,255 -ellipse $7%,$8%,3,3,0,1,0xFFFFFFFF,0,0,0,255

#@gimp Frame [cube] : frame_cube, frame_cube(1)
#@gimp : Depth = float(3,0,30)
#@gimp : X-center = float(0,-2,2)
#@gimp : Y-center = float(0,-2,2)
#@gimp : Left side orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : Right side orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : Upper side orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : Lower sider orientation = choice("Normal","Mirror-X","Mirror-Y","Mirror-XY")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;, Angelo Lama</i>.      Latest update: <i>2012/01/29</i>.</small>")

#@gimp Frame [fuzzy] : gimp_frame_fuzzy, gimp_frame_fuzzy(0)
#@gimp : Width = int(10,0,99)
#@gimp : Height = int(10,0,99)
#@gimp : Fuzzyness = float(10,0,40)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_frame_fuzzy :
  -repeat @#
    ({w*$1/200},{h*$2/200}) -round[-1] 1
    -frame_fuzzy[-2] @-1,$3,$4,$5,$6,$7,$8 -rm[-1]
  -mv[-1] 0 -done

#@gimp Frame [painting] : gimp_frame_painting, gimp_frame_painting_preview(1)
#@gimp : Size = float(10,0,100)
#@gimp : Contrast = float(0.4,0,1)
#@gimp : Smoothness = float(6,0,30)
#@gimp : Color = color(225,200,120)
#@gimp : sep = separator()
#@gimp : Vignette size = float(2,0,50)
#@gimp : Vignette contrast = float(400,0,1000)
#@gimp : sep = separator()
#@gimp : Defects contrast = float(50,0,512)
#@gimp : Defects density = float(10,0,100)
#@gimp : Defects size = float(1,0,10)
#@gimp : Defects smoothness = float(0.5,0,20)
#@gimp : sep = separator()
#@gimp : Serial number = int(123456,0,1000000)
#@gimp : Frame as a new layer = _bool(false)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/06/07</i>.</small>")
gimp_frame_painting :
  -if $14
    -repeat @# 100%,100%,1,4 -frame_painting[-1] $1%,$2,$3%,${4-6},$7%,${8-13}
    -rv[-2,-1] -to_a[-1] -r[-1] [-2],[-2],1,4,0,0,0.5,0.5 -mv[-2,-1] 0 -done
  -else -frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}
  -endif

gimp_frame_painting_preview :
  -frame_painting $1%,$2,$3%,${4-6},$7%,${8-13}

#@gimp Frame [pattern] : gimp_frame_pattern, gimp_frame_pattern_preview(1)
#@gimp : Tiles = int(10,3,30)
#@gimp : Pattern = choice(1,"Top layer","Self image")
#@gimp : Iterations = int(1,1,10)
#@gimp : Constrain image size = _bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_frame_pattern :
  -repeat $3 -frame_pattern $1,$2,$4 -done

gimp_frame_pattern_preview :
  -gimp_frame_pattern $1,$2,$3,1

#@gimp Frame [regular] : gimp_frame, gimp_frame(1)
#@gimp : note = note("<b>Crop parameters :</b>")
#@gimp : X-start = int(0,0,100)
#@gimp : X-end = int(100,0,100)
#@gimp : Y-start = int(0,0,100)
#@gimp : Y-end = int(100,0,100)
#@gimp : sep = separator(), note = note("<b>Frame parameters :</b>")
#@gimp : Width = int(10,0,100)
#@gimp : Height = int(10,0,100)
#@gimp : Color = color(0,0,0,255)
#@gimp : Outline size = int(1,0,100)
#@gimp : Outline color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_frame :
 -to_rgba -repeat @#
   -z[-1] $1%,$3%,$2%,$4%
   -frame[-1] $11,$11,${12-15}
   -frame[-1] $5%,$6%,${7-10}
 -mv[-1] 0 -done

#@gimp Frame [round] : gimp_frame_round, gimp_frame_round(1)
#@gimp : Sharpness = float(6,0.1,40)
#@gimp : Size = float(20,0,100)
#@gimp : Smoothness = float(0.1,0,15)
#@gimp : Shade = float(0,0,1)
#@gimp : Color = color(255,255,255,255)
#@gimp : Blur frame = float(0,0,100)
#@gimp : Blur shade = float(0.1,0,1)
#@gimp : Blur amplitude = float(3,0,10)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_frame_round :
  -frame_round ${1-8}
  -if $9 -frame_blur $1,{min(99,$1+$9)},$3,$10,$11% -endif

#@gimp Old photograph : gimp_old_photo, gimp_old_photo(1)
#@gimp : Vignette strength = float(200,0,255)
#@gimp : Vignette min radius = float(50,0,100)
#@gimp : Vignette max radius = float(85,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_old_photo :
  -vignette ${1-3} -old_photo

#@gimp Polaroid : gimp_polaroid, gimp_polaroid(1)
#@gimp : Frame size = int(10,0,400)
#@gimp : Bottom size = int(20,0,400)
#@gimp : X-shadow = float(0,-20,20)
#@gimp : Y-shadow = float(0,-20,20)
#@gimp : Smoothness = float(3,0,5)
#@gimp : Angle = float(20,-180,180)
#@gimp : Vignette strength = float(50,0,255)
#@gimp : Vignette min radius = float(70,0,100)
#@gimp : Vignette max radius = float(95,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_polaroid :
  -vignette ${7-9} -polaroid $1,$2 -drop_shadow $3%,$4%,$5% -rotate $6,1,0

#@gimp Tunnel : gimp_tunnel, gimp_tunnel(1)
#@gimp : Depth = int(4,1,100)
#@gimp : Factor = float(80,1,99)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Opacity = float(0.2,0,1)
#@gimp : Angle = float(0,-90,90)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/22</i>.</small>")
gimp_tunnel :
  -tunnel $1,$2%,${3-6}

#@gimp Vignette : gimp_vignette, gimp_vignette
#@gimp : Strength = float(70,0,255)
#@gimp : Min radius = float(70,0,100)
#@gimp : Max radius = float(95,0,100)
#@gimp : Color = color(0,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/24</i>.</small>")
gimp_vignette :
  -repeat @# -to_rgb -l[$>]
    -to_rgba -split_opacity -=[-1] 0 -vignette[-1] ${1-3} -a c --fc ${4-7} -blend alpha,1,1
  -endl -done

#@gimp _<b>Layers</b>
#---------------------

#@gimp Blend [average all] : gimp_blend_average_all, gimp_blend_average_all
#@gimp : note = note{"<small><b>Note:</b>
#@gimp : This filter takes multiple layers as input and average them. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/11</i>.</small>")
gimp_blend_average_all :
  -if @#
    N=@# -+ -/ $N
  -endif

#@gimp Blend [standard] : gimp_blend, gimp_blend
#@gimp : Mode = choice("Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gimp : "Divide","Dodge","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gimp : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gimp : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gimp : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gimp : "Vivid light","Xor")
#@gimp : Opacity = float(1,0,1)
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : link = link("Reference page for G'MIC blending modes","https://sourceforge.net/p/gmic/wiki/Blending%20modes/")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/21</i>.</small>")
gimp_blend :
  mode=@{-arg\ 1+$1,add,alpha,and,average,blue,burn,darken,difference,\
       divide,dodge,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
       hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
       multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
       shapeaverage,shapeaverage0,softburn,softdodge,softlight,screen,stamp,subtract,value,\
       vividlight,xor}
  -blend $mode,$2,{1-$3}

#@gimp Blend [edges] : gimp_blend_edges, gimp_blend_edges(0)
#@gimp : Opacity = float(1,0,1)
#@gimp : Smoothness = float(0.8,0,5)
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/21</i>.</small>")
gimp_blend_edges :
  -repeat {int(@#/2)} -l[$>,{$>+1}] -if $3 -rv -endif --blend_edges[-2,-1] $2 -rm[-3] -blend[-2,-1] alpha,$1 -endl -done

#@gimp Blend [fade] : gimp_blend_fade, gimp_blend_fade(1)
#@gimp : Preset = choice{1,"Custom","Linear","Circular","Wave","Keftales"}
#@gimp : Offset = float(0,-1,1)
#@gimp : Thinness = float(0,0,10)
#@gimp : Sharpness = float(5,1,20)
#@gimp : Sharpest = bool(0)
#@gimp : Revert layers = bool(0)
#@gimp : Color space = choice("RGB","HSV","Lab")
#@gimp : Note = note{\n<small>
#@gimp : The parameters below are used in most presets.
#@gimp : </small>}
#@gimp : 1st parameter = float(0,-1,1)
#@gimp : 2nd parameter = float(0,-1,1)
#@gimp : 3rd parameter = float(0,-1,1)
#@gimp : Note = note{\n<small>
#@gimp : The formula below is used for the <i>Custom</i> preset.
#@gimp : </small>}
#@gimp : Formula = text{"cos(4*pi*x/w) * sin(4*pi*y/h)"}
#@gimp : Note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/21</i>.</small>")
gimp_blend_fade :
  -if {@#==1} -return -endif
  -to_colormode 4
  -if {$7==1} -repeat @# -sh[$>] 0,2 -rgb2hsv[-1] -rm[-1] -done
  -elif {$7==2} -repeat @# -sh[$>] 0,2 -srgb2rgb[-1] -rgb2lab[-1] -rm[-1] -done
  -endif
  -if {$1==0} [0],[0],1,1,"$11"
  -else -_gimp_blend_fade$1 $8,$9,$10 -r[-1] [0],[0],1,1,3
  -endif
  -n[-1] {-(@#-2)*$3},{(@#-2)*(1+$3)}
  --[-1] {$2*(1+$3)*(@#-2)}
  -c[-1] 0,{@#-2}
  -if $6 -rv[^-1] -endif
  -if $5 -round[-1] 1
  -else -roundify[-1] $4
  -endif
  -blend_fade
  -if {$7==1} -repeat @# -sh[$>] 0,2 -hsv2rgb[-1] -rm[-1] -done
  -elif {$7==2} -repeat @# -sh[$>] 0,2 -lab2rgb[-1] -rgb2srgb[-1] -rm[-1] -done
  -endif
  -c 0,255

_gimp_blend_fade1 : [0],[0],1,1,"a=$1*pi/2; x*cos(a) + y*sin(a)"
_gimp_blend_fade2 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1
_gimp_blend_fade3 : [0],[0],1,1,0 -=[-1] 1,{($1+1)*50}%,{($2+1)*50}% -distance[-1] 1 -*[-1] {0.01+$3/2} -cos[-1]
_gimp_blend_fade4 : [0],[0],1,1,"((x-w*($1+0.5))*(y-h*($2+0.5)))%(0.2*w*h*(1.001+$3))"

#@gimp Blend [median] : blend_median, blend_median(0)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/05/07</i>.</small>")

#@gimp Align layers : gimp_align_layers, gimp_align_layers_preview
#@gimp : Alignment type = choice(0,"Rigid","Non-rigid")
#@gimp : Smoothness = float(0.7,0,1)
#@gimp : Scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_align_layers :
  -if ${4=0} -_gimp_revert_layers -endif
  -remove_opacity
  -if $1 -register_nonrigid $2,0.1,$3
  -else ($2) -*[-1] 3 -register_rigid[^-1] @-1 -rm[-1]
  -endif

gimp_align_layers_preview :
  -gimp_align_layers $1,$2,0 -blend_edges 0.1

_gimp_revert_layers :
  -repeat {int(@#/2)} -rv[{2*$>},{2*$>+1}] -done

#@gimp Fade layers : gimp_fade_layers, gimp_fade_layers_preview
#@gimp : Inter-frames = _int(10,2,100)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/08/04</i>.</small>")
gimp_fade_layers :
  -if {@#<2} -return -endif
  -a z -r 100%,100%,{(d-1)*$1+1},100%,3 -s z

gimp_fade_layers_preview :
  -if {@#<2} -return -endif
  -k[0,1] -+ -/ 2

#@gimp Morph layers : gimp_morph, gimp_no_preview
#@gimp : Inter-frames = _int(10,2,100)
#@gimp : Smoothness = _float(0.2,0,2)
#@gimp : Precision = _float(0.1,0,2)
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_morph :
  -if ${4=0} -_gimp_revert_layers -endif
  -to_rgb -morph $1,$2,$3

#@gimp Layers to tiles : append_tiles, gimp_append_tiles_preview(1)
#@gimp : X-tiles = int(0,0,256)
#@gimp : Y-tiles = int(0,0,256)
#@gimp : note = note("<small>For both parameters, <i>0</i> means <i>automatic</i>.</small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_append_tiles_preview :
  -frame 1,1,0,0,0,255 -append_tiles $1,$2

#@gimp Tiles to layers : split_tiles, gimp_split_tiles(1)
#@gimp : X-tiles = int(3,1,100)
#@gimp : Y-tiles = int(3,1,100)
#@gimp : Homogeneous tiles = _bool(false)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_split_tiles :
  -split_tiles $1,$2,$3 -k[50%]

#@gimp Transfer colors : gimp_transfer_colors, gimp_transfer_colors
#@gimp : Transfer brighness = bool(0)
#@gimp : Revert layers = bool(0)
#@gimp : Note = note{"<small><b>Note: </b>
#@gimp : The top layer contains the target colors.\n
#@gimp : This filter needs at least two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_transfer_colors :
  -if ${2=0} -_gimp_revert_layers -endif
  -transfer_colors $1

#@gimp Transparent difference : gimp_transparent_diff, gimp_transparent_diff(1)
#@gimp : Threshold = float(1,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Opaque pixels = choice(0,"From 1st layer","From 2nd layer")
#@gimp : Transparent pixels = choice(1,"From same values","From different values")
#@gimp : Revert layers = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_transparent_diff :
  -if ${5=0} -_gimp_revert_layers -endif
  -repeat {int(@#/2)}
    -if $3
      --[-2] [-1] -norm[-2] -b[-2] $2% -ge[-2] $1% -rv[-2,-1]
    -else
      --[-1] [-2] -norm[-1] -b[-1] $2% -ge[-1] $1%
    -endif
    -if {!$4} -negative[-1] -endif
    -to_rgba[-2] -*[-2,-1]
  -mv[-1] 0 -done

#@gimp Split tones : gimp_split_tones, gimp_split_tones_preview(0)
#@gimp : Number of tones = int(3,2,10)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_split_tones :
  -remove_opacity -repeat @# -l[$<]
    --tones $1 -r[^0] [0] -*[^0] [0] -rm[0]
  -endl -done

gimp_split_tones_preview :
  -gimp_split_tones $1 -append_tiles ,


#@gimp _<b>Lights &amp; Shadows</b>
#----------------------------------

#@gimp Burn : gimp_burn, gimp_burn_preview(1)
#@gimp : Amplitude = float(0.5,0,1)
#@gimp : Scale = float(30,1,100)
#@gimp : Smoothness = float(1,0,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/24</i>.</small>")
_gimp_burn :
  -repeat @# -l[$>]
    w={w} h={h}
    --norm
    -gimp_fourier[-1] 0
    --rows[-1] 0,{$h-1} -r[-1] $2%,$2%,1,100%,0,0,0.5,0.5 -b[-1] $3%
    -j[-2] [-1],{($w-w)/2},{($h-h)/2} -rm[-1]
    -gimp_fourier[-1] 1
    -blend overlay,$1
  -endl -done

gimp_burn :
  -apply_channels "-_gimp_burn ${1-3}",$4,1

gimp_burn_preview :
 -gimp_split_preview "-gimp_burn ${^0}",$-1

#@gimp Contrast swiss mask : gimp_contrast_swm , gimp_contrast_swm(0)
#@gimp : sep = separator()
#@gimp : Blur the mask = float(2,0.5,10)
#@gimp : sep = separator()
#@gimp : note = note ("Contrast Mask need the negative of the mask")
#@gimp : SKIP to use the mask to boost = bool(false)
#@gimp : note = note ("Uncheck for Contrast Mask,Check for Contrast Boost")
#@gimp : sep = separator()
#@gimp : note = note("Merge the Mask")
#@gimp : Intensity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update: <i>2011/1/1 </i>.</small>")
#@gimp : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=864")
gimp_contrast_swm :
  -repeat @# -l[$>] -split_opacity -l[0]
   --luminance -to_rgb
    -blur_xy[1] $1,$1
    -if {$2==0} -negative[1] -elif {$2==1} -gimp_do_nothing -endif
    -rv -blend hardlight,$3
  -endl -a c -endl -done

#@gimp Drop shadow : gimp_drop_shadow, gimp_drop_shadow(1)
#@gimp : X-shadow = float(3,-20,20)
#@gimp : Y-shadow = float(3,-20,20)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : Curvature = float(0,0,1)
#@gimp : Corner brightness = float(0,0,1)
#@gimp : Angle = float(0,0,360)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/14</i>.</small>")
gimp_drop_shadow :
  -* -1 -+ 255 -vignette {255*$5},80,95 -* -1 -+ 255
  -drop_shadow $1%,$2%,$3%,$4 -rotate $6,1,0

#@gimp Drop shadow 3d : gimp_drop_shadow3d, gimp_drop_shadow3d_preview(1)
#@gimp : X-angle = float(0,-90,90)
#@gimp : Y-angle = float(0,-90,90)
#@gimp : Z-angle = float(0,-90,90)
#@gimp : Zoom = float(0,-100,100)
#@gimp : X-offset = float(1,-50,50)
#@gimp : Y-offset = float(1,-50,50)
#@gimp : Perspective = float(2,0,10)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Color = color(0,0,0,200)
#@gimp : Preview only shadow = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/07/02</i>.</small>")
gimp_drop_shadow3d :
  -repeat @# -l[$<]
    --_gimp_drop_shadow3d $*
  -endl -done

gimp_drop_shadow3d_preview :
  -repeat @# -l[$<]
    -if $13 -_gimp_drop_shadow3d $*
    -else --_gimp_drop_shadow3d $* -rv -blend alpha,1
    -endif
  -endl -done

_gimp_drop_shadow3d :
  -point3d 0,0,1 -r3d[-1] 1,0,0,$1 -r3d[-1] 0,1,0,$2 -r3d[-1] 0,0,1,$3
  u={i(0,8)} v={i(0,9)} w={i(0,10)} -rm[-1]
  -to_a -channels 100% -if {im==iM} -return -endif
  --f 'X=x/w-0.5;Y=y/h-0.5;A=($7-$4*$7/100)*$w/(X*$u+Y*$v+$7*$w);if(A<0,1e8,A)'
  --*[-1] 'y/h-0.5' -*[-2] 'x/w-0.5' -+[-2] {0.5-$5/100} -+[-1] {0.5-$6/100} -*[-2] {w} -*[-1] {h}
  -a[-2,-1] c -warp[0] [-1],0,1,0 -rm[-1]
  -b $8% -n 0,$12 -i[-2] ($9^$10^$11) -r[-2] [-1],[-1],1,3 -a[-2,-1] c

#@gimp Equalize shadow : gimp_equalize_shadow, gimp_equalize_shadow_preview(1)
#@gimp : Amplitude = float(1,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Authors: <i>Francois Grassard</i> and <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/24</i>.</small>")
gimp_equalize_shadow :
  -repeat @# -l[$>] --negative -blend softlight,$1 -endl -done

gimp_equalize_shadow_preview :
  -gimp_split_preview "-gimp_equalize_shadow $1",$-1

#@gimp Light glow : gimp_lightglow, gimp_lightglow_preview(0)
#@gimp : Density = float(30,0,100)
#@gimp : Amplitude = float(0.5,0,2)
#@gimp : Mode = choice(8,"Burn","Dodge","Freeze","Grain merge","Hard light","Interpolation",
#@gimp :               "Lighten","Multiply","Overlay","Reflect","Soft light","Stamp","Value")
#@gimp : Opacity = float(0.8,0,1)
#@gimp : note = note()
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/02/21</i>.</small>")
_gimp_lightglow :
  mode=@{-arg\ 1+$3,burn,dodge,freeze,grainmerge,hardlight,interpolation,lighten,multiply,overlay,reflect,softlight,stamp,value}
  -repeat @#
    --gradient_norm[-1] -ge[-1] {100-$1}% -distance[-1] 1 -^[-1] $2 -*[-1] -1 -n[-1] 0,255 -blend $mode,$1
  -mv[-1] 0 -done

gimp_lightglow :
  -apply_channels "-_gimp_lightglow ${1-4}",$5,0

gimp_lightglow_preview :
  -gimp_split_preview "-gimp_lightglow $*",$-1

#@gimp Light patch : gimp_light_patch, gimp_light_patch(0)
#@gimp : Density = int(5,2,30)
#@gimp : Darkness = float(0.7,0,1)
#@gimp : Lightness = float(2.5,1,4)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_light_patch :
  -repeat @# -l[$>] -split_opacity -l[0]
    -apply_channels "-light_patch $1,$2,$3",$4,0
  -endl -a c -endl -done

#@gimp Light rays : gimp_lightrays, gimp_lightrays(1)
#@gimp : Density = float(80,0,100)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Length = float(1,0,1)
#@gimp : Attenuation = float(0.5,0,1)
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/01/03</i>.</small>")
gimp_lightrays :
  -lightrays ${1-5}
  -if $6 -repeat @# -r[$>] 100%,100%,1,{@{$>,s}+(@{$>,s}%2)} -done -endif

#@gimp Relief light : gimp_light_relief, gimp_light_relief(1)
#@gimp : Ambient lightness = float(0.3,0,5)
#@gimp : Specular lightness = float(0.2,0,2)
#@gimp : Specular size = float(0.2,0,1)
#@gimp : Darkness = float(0,0,1)
#@gimp : Light smoothness = float(1,0,5)
#@gimp : X-light = float(0.5,0,1)
#@gimp : Y-light = float(0.5,0,1)
#@gimp : Z-light = float(5,0,20)
#@gimp : Z-scale = float(0.5,0,3)
#@gimp : Opacity as bumpmap = bool(0)
#@gimp : Image smoothness = float(0,0,10)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_light_relief :
  -b $11% -light_relief ${1-10}

#@gimp Shadow patch : gimp_shadow_patch, gimp_shadow_patch(1)
#@gimp : Opacity = float(0.7,0,1)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_shadow_patch :
  -repeat @# -l[$>] -split_opacity -l[0]
    -apply_channels "-shadow_patch $1",$2,0
  -endl -a c -endl -done

#@gimp _<b>Patterns</b>
#----------------------

#@gimp Bayer filter : rgb2bayer, rgb2bayer(0)
#@gimp : Starting pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gimp : Keep colors = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Box fitting : gimp_boxfitting, gimp_boxfitting_preview(0)
#@gimp : Minimal size = int(3,1,32)
#@gimp : Maximal size = int(0,0,32)
#@gimp : note = note("<small><b>Note:</b> Set <i>Maximal size</i> to <i>0</i> to allow any size for the squares.</small>")
#@gimp : Initial density = float(0.1,0,1)
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), note = note("<small><b>Note:</b> This filter has been highly inspired by the work of Jared Tarbell, described on the page:</small>")
#@gimp : link = link("http://www.complexification.net/gallery/machines/boxFittingImg/")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/06</i>.</small>")
gimp_boxfitting :
  -boxfitting ${1-3},3
  -if $4 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif

gimp_boxfitting_preview :
  -boxfitting ${1-3},1
  -if $4 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif

#@gimp Canvas : gimp_canvas, gimp_canvas_preview(0)
#@gimp : note = note{"<b>First direction :</b>"}
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(45,0,180)
#@gimp : Sharpness = float(400,0,2000)
#@gimp : note = note{"\n<b>Second direction : </b>"}
#@gimp : Activate second direction = bool(true)
#@gimp : Amplitude = float(70,0,300)
#@gimp : Angle = float(135,0,180)
#@gimp : Sharpness = float(400,0,2000)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_canvas :
  -repeat @# -l[-1]
    -if $4
      ({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] --smooth[-2] [-1],$1 -rm[-2] -sharpen[-1] $3 -c[-1] 0,255
      ({cos($6*pi/180)}^{sin($6*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] -smooth[-3] [-1],$5 -rm[-1] -sharpen[-2] $7 -c[-2] 0,255 -+[-2,-1] -/[-1] 2
    -else
      ({cos($2*pi/180)}^{sin($2*pi/180)}) -vector2tensor[-1] -r[-1] [-2],[-2] -smooth[-2] [-1],$1 -rm[-1] -sharpen[-1] $3 -c[-1] 0,255
    -endif
  -endl -mv[-1] 0 -done

gimp_canvas_preview :
  -gimp_split_preview "-gimp_canvas $*",$-1

#@gimp Canvas texture : texturize_canvas, texturize_canvas(0)
#@gimp : Amplitude = float(20,0,256)
#@gimp : Fibrousness = float(3,0,20)
#@gimp : Emboss = float(0.6,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Cracks : gimp_cracks, gimp_cracks_preview(0)
#@gimp : Density = float(1,0.1,10)
#@gimp : Amplitude = float(-80,-255,255)
#@gimp : Relief = bool(true)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_cracks :
  -apply_channels "-cracks $1,$2,$3",$4,0

gimp_cracks_preview :
  -gimp_split_preview "-gimp_cracks $*",$-1

#@gimp Halftone : gimp_halftone, gimp_halftone_preview(0)
#@gimp : note = note("<b><small>Image parameters :</small></b>")
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Smoothness = float(0,0,10)
#@gimp : sep = separator(), note = note("<b><small>Halftone parameters :</small></b>")
#@gimp : Number of tones = int(5,2,32)
#@gimp : Size for dark tones = int(8,2,256)
#@gimp : Size for bright tones = int(8,2,256)
#@gimp : Shape = choice{5,"Square","Diamond","Circle","Square (inv.)","Diamond (inv.)","Circle (inv.)"}
#@gimp : Smoothness = float(0.1,0,32)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/07/23</i>.</small>")
gimp_halftone :
  -apply_gamma {10^$1} -- 128 -* $2 -+ 128 -+ $3 -b $4 -c 0,255
  -repeat @# -l[$>] -split_opacity
    -halftone[0] ${5-9}
  -a c -endl -done

gimp_halftone_preview :
  -gimp_split_preview "-gimp_halftone $*",$-1

#@gimp Hearts : gimp_hearts, gimp_hearts_preview(0)
#@gimp : Density = float(10,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_hearts :
  -apply_channels "-hearts $1",$2,0

gimp_hearts_preview :
  -gimp_split_preview "-gimp_hearts $*",$-1

#@gimp Lava : gimp_lava, gimp_lava_preview(0)
#@gimp : Perturbation = int(8,0,15)
#@gimp : Smoothness = float(5,0,100)
#@gimp : Scale = float(3,0,20)
#@gimp : Sharpness = float(0,0,1000)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/26</i>.</small>")
gimp_lava :
  -norm -repeat @# -l[$>]
    100%,100% -plasma[-1] 1,1,{16-$1} -smooth[-1] $2,0,1,$3,$3,0.8,90 -*
    -gradient_norm -n 0,255
    -equalize -map 3
    -sharpen $4
  -endl -done

gimp_lava_preview :
  -gimp_split_preview "-gimp_lava $*",$-1

#@gimp Marble : gimp_marble, gimp_marble
#@gimp : Image weight = float(.5,0,30)
#@gimp : Pattern weight = float(1,0,30)
#@gimp : Pattern angle = float(0,0,360)
#@gimp : Amplitude = float(0,0,1000)
#@gimp : Sharpness = float(.4,0,5)
#@gimp : Anisotropy = float(.6,0,1)
#@gimp : Alpha = float(.6,0,20)
#@gimp : Sigma = float(1.1,0,20)
#@gimp : Cut low = float(0,0,100)
#@gimp : Cut high = float(100,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_marble :
  -repeat @# -l[$>] -split_opacity -l[0]
    -marble $1/10,$2/10,$3,$4,$5,$6,$7,$8,$9%,$10%
  -endl -a c -endl -done

#@gimp Maze : gimp_maze, gimp_maze
#@gimp : Cell size = int(24,1,256)
#@gimp : Thickness = int(1,1,10)
#@gimp : Masking = choice("None","Render on dark areas","Render on white areas")
#@gimp : Preserve image dimension = bool(1)
#@gimp : Maze type = choice("Dark walls","White walls")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/09/02</i>.</small>")
gimp_maze :
  -repeat @#
    w={w} h={h}
    -r[-1] {100/$1}%,{100/$1}%,1,100%,2
    -if {$3==0} -f[-1] 1
    -elif {$3==1} -negative[-1]
    -endif
    -maze_mask[-1] $1 -dilate[-1] $2 -*[-1] 255
    -if {!$5} -negative[-1] -endif
    -if $4 -r[-1] $w,$h,100%,100% -endif
  -mv[-1] 0 -done

#@gimp Mineral mosaic : dt_mineral_mosaic,dt_mineral_mosaic(0)
#@gimp : Density = float(1,0,3)
#@gimp : Area = float(2,0,32)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Shade strength = float(100,0,255)
#@gimp : Shade angle = float(0,0,360)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/02/01</i>.</small>")
dt_mineral_mosaic :
  -repeat @# -l[$>] -to_rgb
    --b $3 -segment_watershed[-1] $1 --norm[-1]
    -area[-1] 0 --le[-1] {$2^2} -inpaint[-2] [-1] -rm[-1] -label[-1]
    --f[0] 'if(c==0,x,y)' --blend[-2,-1] shapeaverage,1,1
    --[-2,-1] -rm[0,2] -channels[-1] 0,1
    alpha={$5*pi/180} -sh[-1] 0,0 -*[-1] {cos($alpha)} -rm[-1] -sh[-1] 1,1 -*[-1] {sin($alpha)} -rm[-1] -compose_channels[-1] +
    -normalize_local[-1] 1000 -n[-1] -$4,$4
    -+ -c 0,255
  -endl -done

#@gimp Mosaic : gimp_mosaic, gimp_mosaic_preview(0)
#@gimp : Density = float(1,0.1,10)
#@gimp : Keep edges = bool(true)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_mosaic :
  -apply_channels "-mosaic $1,$2",$3,0

gimp_mosaic_preview :
  -gimp_split_preview "-gimp_mosaic $*",$-1

#@gimp Op art : gimp_shapes,gimp_shapes_preview(0)
#@gimp : Shape = choice{1,"Custom layers","Circles","Squares","Diamonds","Triangles","Horizontal stripes","Vertical stripes","Balls","Hearts","Stars","Arrows","Truchet",
#@gimp : "Circles (outline)","Squares (outline)","Diamonds (outline)","Triangles (outline)","Hearts (outline)","Stars (outline)","Arrows (outline)"}
#@gimp : Number of scales = int(16,2,24)
#@gimp : Resolution = float(10,1,50)
#@gimp : Zoom factor = _int(2,1,8)
#@gimp : Minimal size = float(5,0,150)
#@gimp : Maximal size = float(90,0,150)
#@gimp : Stencil type = choice(0,"Black & white","RGB","Color")
#@gimp : Allow angle = choice("0 deg.","90 deg.","180 deg.")
#@gimp : Negative = bool(1)
#@gimp : Antialiasing = bool(1)
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b>
#@gimp : If you set the parameter <i>Shape</i> to <i>Custom layers</i>, the different shapes used to map the pixel intensities will be defined as
#@gimp : the <i>Number of scales</i> top layers of your image. Don't forget to set also <i>Input layers</i> to <i>All</i> to be sure
#@gimp : these layers are passed to the filter.
#@gimp : </small>"}
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/12/16</i>.</small>")
gimp_shapes :
  -if $1 # Pre-defined shapes.
    -remove_opacity -repeat @# -l[$>]
      -if {!$7} -_gimp_shapes $* -* 255
      -elif {$7==1} -split_opacity -to_rgb[0] -s[0] c -repeat 3 -_gimp_shapes[$>] $* -done -*[0-2] 255 -a[0-2] c -a c
      -else --_gimp_shapes $* -r[0] $3%,$3% -r[0] [1],[1] -*
      -endif
    -endl -done
  -else # Custom shapes.
    -if {@#<=$2} -error[] "Some layers are missing in 'Custom layers' mode ("{$2+1}" expected at least, "@#" provided)." -endif
    -to_colormode[0-{$2-1}] @{-max_s[0-{$2-1}]} -remove_opacity[$2--1]
    -repeat {@#-$2} -l[0-{$2-1},{$2+$>}]
      -norm[-1] w={w} h={h} -r[-1] $3%,$3%,1,1,2
      s={$4*max(round($w/w),round($h/h))}
      r0={$s*$5%} r1={$s*$6%}
      -repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} -if $r --r[$>] $r,$r,1,100%,3 -else 1,1 -endif -done
      -r[-$2--1] $s,$s,1,100%,0,0,0.5,0.5
      -map_sprites[$2--1] $2,$8
    -endl -done -rm[0-{$2-1}]
  -endif

gimp_shapes_preview :
  -if $1 -repeat @# -l[$>]
    w={w} h={h}
    -gimp_split_preview "-gimp_shapes ${1-3},1,${5--2}",$-1
    -r $w,$h,1,100%,0,0,0.5,0.5
    -endl -done
  -else
    -if {@#>$2} -repeat {@#-$2} -l[0-{$2-1},{$2+$>}]
      w={w} h={h}
      --gimp_shapes ${1-3},1,${5--2} -rm[-2]
      -r[-1] $w,$h,1,100%,0,0,0.5,0.5
    -endl -done -rm[0-{$2-1}]
    -else -_gimp_no_preview "Missing\nlayers !"
    -endif
  -endif

_gimp_shapes :
  -norm w={w} h={h} -r $3%,$3%,1,1,2
  s={(1+$10)*$4*max(round($w/w),round($h/h))}
  r0={$s*$5%} r1={$s*$6%}
  -repeat $2 r={round($r0+$>*($r1-$r0)/($2-1))} -if $r -_gimp_shapes{$1-1}[] $r,$s -else 1,1 -endif -done
  -r[-$2--1] $s,$s,1,1,0,0,0.5,0.5
  -if $9 -rv[-$2--1] -*[-$2--1] -1 -+[-$2--1] 1 -endif
  -map_sprites $2,$8
  -if $10 -r 50%,50%,1,1,2 -endif

_gimp_shapes0 :
  -_dt_circle[] $1

_gimp_shapes1 :
  $1,$1,1,1,1

_gimp_shapes2 :
  $1,$1,1,1 -= 1,50%,50% -distance 1,1 -lt {$1/2}

_gimp_shapes3 :
  $2,$2,1,1,'x+y<=2*$1-1'

_gimp_shapes4 :
  $2,$1,1,1,1

_gimp_shapes5 :
  $1,$2,1,1,1

_gimp_shapes6 :
  -ball $1,200 -n 0,1

_gimp_shapes7 :
  -heart 65 -r $1,$1,1,1,2 -ge 50%

_gimp_shapes8 :
  -star $1,$1

_gimp_shapes9 :
  -arrow3d 0,0,0,1,0,0,15%,40%,30% -col3d 1 -*3d $1 -c3d
  $2,$2 -object3d[-1] [-2],50%,50%,0,1,2,0,0
  -rm[-2] --mirror y -max

_gimp_shapes10 :
  S={$2+1-($2%2)}
  $S,$S,1,1,"X=x/(w-1);Y=y/(h-1);r=abs(0.5-sqrt(X^2+Y^2));a=atan2(y,x);r<0.1-0.17*(0.5-$1/$2)*sin(2*a)"
  --mirror xy -max

_gimp_shapes11 :
  -_gimp_shapes0 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes12 :
  -_gimp_shapes1 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes13 :
  -_gimp_shapes2 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes14 :
  -_gimp_shapes3 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes15 :
  -_gimp_shapes7 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes16 :
  -_gimp_shapes8 $* -expand_xy 1,0 --erode 3 --

_gimp_shapes17 :
  -_gimp_shapes9 $* -expand_xy 1,0 --erode 3 --

#@gimp Pack sprites : gimp_pack_sprites, gimp_no_preview
#@gimp : Number of scales = int(5,1,16)
#@gimp : Minimal scale [%] = float(25,1,100)
#@gimp : Allow angle = choice(3,"0 deg.","180 deg.","90 deg.","Any")
#@gimp : Spacing = int(1,-16,16)
#@gimp : Precision = int(7,1,32)
#@gimp : sep = separator()
#@gimp : Masking = choice("No masking","Mask as bottom layer")
#@gimp : Width = int(512,32,2048)
#@gimp : Height = int(512,32,2048)
#@gimp : note = note("<small><b>Notes:</b>\n - Parameters <i>Width</i> and <i>Height</i> are considered only when <i>No masking</i> mode is selected.\n
#@gimp : - Set different sprites on different layers to pack multiple sprites at the same time.</small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/06/24</i>.</small>")
gimp_pack_sprites :
  -if $6 # With mask.
    -if {@#<2} -error[] "Masking requires at least two input layers ! (please check that 'Input Layers' is correctly set)." -endif
    -repeat {@#-1} -l[$>] -to_rgba -split_opacity --neq[1] 0 -*[0] [-1] -a c -autocrop 0 -endl -done
    -remove_empty[0--2] --channels[-1] 100% -channels[-1] -4,0 -mv[-1] 0
    -pack_sprites[0--2] ${1-5}
  -else # No masking
    -repeat @# -l[$>] -to_rgba -split_opacity --neq[1] 0 -*[0] [-1] -a c -autocrop 0 -endl -done
    -remove_empty -i[0] $7,$8,1,5 -pack_sprites ${1-5}
  -endif
  -channels[0] 0,@{0,s-2}

#@gimp Paper texture : gimp_paper, gimp_paper_preview(0)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_paper :
  -apply_channels "-texturize_paper",$1,0

gimp_paper_preview :
  -gimp_split_preview "-gimp_paper $*",$-1

#@gimp Plaid : gimp_plaid_texture,gimp_plaid_texture(1)
#@gimp : Line = float(50,0,100)
#@gimp : Number of angles = int(2,1,8)
#@gimp : Starting angle = float(0,0,360)
#@gimp : Angle range = float(90,0,360)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Sharpen = float(300,0,1000)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/05/16</i>.</small>")
gimp_plaid_texture :
  -repeat @# -l[$>]
    w={w} h={h} s={s}
    -rows $1%
    -b $5% -sharpen $6
    -resize $w,$h,1,$s,2
    --rotate[0] $3,1,2,50%,50%
    -repeat {$2-1} --rotate[0] {$3+$4*($>+1)/($2-1)},1,2,50%,50% -+[-2,-1] -done -rm[0]
    -/ $2
  -endl -done

#@gimp Plasma : gimp_plasma, gimp_plasma(0)
#@gimp : Alpha = float(0.5,0,5)
#@gimp : Beta = float(0,0,100)
#@gimp : Scale = int(8,2,10)
#@gimp : Randomize = bool(0)
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/03/20</i>.</small>")
gimp_plasma : -skip ${4=0},${5=0}
  -if $5 -to_rgba -else -to_rgb -endif
  -if $4 -rand 0,255 -endif
  -plasma $1,$2,$3 -n 0,255

#@gimp Polka dots : gimp_polka_dots, gimp_polka_dots(1)
#@gimp : Size = float(80,0,100)
#@gimp : Density = float(20,0.1,100)
#@gimp : First offset = float(50,0,100)
#@gimp : Second offset = float(50,0,100)
#@gimp : Angle = float(0,0,180)
#@gimp : Aliasing = float(0.5,0.1,1)
#@gimp : Shading = float(0.1,0.1,1)
#@gimp : Opacity = float(1,0,1)
#@gimp : Color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_polka_dots :
  -to_rgba -polka_dots {$1*$2/100},${2--1}

#@gimp Random color ellipses : gimp_color_ellipses, gimp_color_ellipses(1)
#@gimp : Density = int(400,0,3000)
#@gimp : Radius = float(8,0,30)
#@gimp : Opacity = float(0.1,0.01,0.5)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_color_ellipses :
  -color_ellipses $1,$2,$3

#@gimp Rorschach : gimp_rorschach, gimp_rorschach
#@gimp : Scale = float(3,0,10)
#@gimp : Mirror = choice(1,"None","x-axis","y-axis","xy-axes")
#@gimp : Stencil type = choice(2,"Black & White","RGB","Color")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/03/12</i>.</small>")
gimp_rorschach :
  -repeat @# -remove_opacity -l[$>]
    -if {$3==0} -norm -rorschach $1%,$2 -* 255
    -elif {$3==1} -to_rgb -rorschach $1%,$2 -* 255
    -else --norm -rorschach[-1] $1%,$2 -blend shapeaverage0
    -endif
  -endl -done

#@gimp Seamless turbulence : gimp_seamless_turbulence, gimp_seamless_turbulence(0)
#@gimp : Amplitude = float(15,0,30)
#@gimp : Smoothness = float(20,0,40)
#@gimp : Orientation = float(0,0,180)
#@gimp : Deviation = float(1,0,1)
#@gimp : Contrast = float(3,0,4)
#@gimp : Color rendering = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/04/02</i>.</small>")
gimp_seamless_turbulence :
  -repeat @# -l[$>]
    wh={w},{h} -rm
    $wh,1,{if($6,3,1)} -rand[-1] 0,255
    $wh -rand[-1] {$3*pi/180-$4*10*pi},{$3*pi/180+$4*10*pi} --sin[-1] -cos[-2] -a[-2,-1] c
    -r[-2,-1] 130%,130%,1,100%,0,2,0.5,0.5 -b[-1] $2 -orientation[-1]
    -vector2tensor[-1]
    -smooth[-2] [-1],$1,0.5,20 -rm[-1]
    -r[-1] $wh,1,100%,0,0,0.5,0.5
    -if {$5!=1} ia={ia} -- $ia -* $5 -+ $ia -endif
  -endl -done
  -c 0,255 -n 0,255

#@gimp Sponge : gimp_sponge, gimp_sponge_preview(0)
#@gimp : Size = int(13,3,21)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_sponge :
  -apply_channels "-sponge $1",$2,0

gimp_sponge_preview :
  -gimp_split_preview "-gimp_sponge $*",$-1

#@gimp Stained glass : gimp_stained_glass, gimp_stained_glass_preview(0)
#@gimp : Edges = float(20,0,100)
#@gimp : Shading = float(0.1,0,0.5)
#@gimp : Thin separators = bool(1)
#@gimp : sep = separator()
#@gimp : Equalize = bool(1)
#@gimp : Colors = float(1,0,3)
#@gimp : Gamma = float(0,-1.2,1.2)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/03/18</i>.</small>")
gimp_stained_glass :
  -repeat @# -l[$>] -split_opacity -l[0]
    -stained_glass $1,$2,$3
    -n 0,255
    -if $4 -equalize[-1] -endif
    -rgb2lab[-1] -sh[-1] 1,2 -*[-1] $5 -rm[-1] -lab2rgb[-1]
    -apply_gamma[-1] {10^$6} --[-1] 128 -*[-1] $7 -+[-1] {128+$8}
    -c[-1] 0,255
  -endl -append c -endl -done

gimp_stained_glass_preview :
  -gimp_split_preview "-gimp_stained_glass $*",$-1

#@gimp Stars : gimp_stars, gimp_stars(0)
#@gimp : Density = float(10,0,200)
#@gimp : Depth = float(0,0,5)
#@gimp : Size = int(32,8,128)
#@gimp : Branches = int(5,2,16)
#@gimp : Thickness = float(0.38,0.1,1)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Color = color(200,200,200,200)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/01</i>.</small>")
gimp_stars :
  -repeat @# -l[$>] -split_opacity -rv
    -stars $1%,$2,$3,$4,$5,$6%,${7-9},{$10/255}
  -rv -a c -endl -done

#@gimp Stencil : gimp_stencil, gimp_stencil_preview(0)
#@gimp : Radius = float(3,0,10)
#@gimp : Smoothness = float(0,0,30)
#@gimp : Iterations = int(8,1,100)
#@gimp : Aliasing = float(0,0,5)
#@gimp : Stencil type = choice(2,"Black & White","RGB","Color")
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_stencil :
  -v -
  -if {$5==0} -norm -stencil $1,$2,$3
  -elif {$5==1} -stencil $1,$2,$3
  -else -repeat @#
    --norm[-1] -stencil[-1] $1,$2,$3 -ge[-1] 50% -blend[-2,-1] shapeaverage0
  -mv[-1] 0 -done -endif
  -if $6 -to_rgba -replace_color 0,0,0,0,0,255,0,0,0,0 -endif
  -if $4 -smooth {30*$4},0,1,1 -endif

gimp_stencil_preview :
  -gimp_split_preview "-gimp_stencil $*",$-1

#@gimp Tetris : gimp_tetris, gimp_tetris(0)
#@gimp : Scale = int(10,1,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_tetris :
  -tetris $1

#@gimp Truchet : gimp_truchet, gimp_truchet(0)
#@gimp : Scale = int(32,1,256)
#@gimp : Radius = int(5,1,64)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Type = choice(1,"Straight","Curved")
#@gimp : Colorize randomly = bool(0)
#@gimp : Transparency = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/10/26</i>.</small>")
gimp_truchet :
  -if $6 -to_a -else -remove_opacity -endif
  -truchet $1,$2,$4
  -if $5 -repeat @# -channels[-1] 0 -label[-1] 0,1 {iM+1},1,1,3 -rand[-1] 0,255 -map[-2] [-1] -rm[-1] -mv[-1] 0 -done -endif
  -b $3 -n 0,255

#@gimp Turbulence : gimp_turbulence, gimp_turbulence
#@gimp : Radius = float(128,1,1024)
#@gimp : Octaves = int(6,1,12)
#@gimp : Damping per octave = float(4,1,10)
#@gimp : Difference mixing = float(0,-10,10)
#@gimp : Mode = choice("Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gimp : sep = separator(), note = note("<small>Author: <i>Preben Soeberg</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_turbulence :
  -repeat @# -l[$>] -split_opacity -l[0]
    -turbulence ${^0}
  -endl -a c -endl -done

#@gimp Weave : weave, weave(1)
#@gimp : Density = int(6,1,32)
#@gimp : Thickness = float(65,0,100)
#@gimp : Shadow = float(0,0,100)
#@gimp : Shading = float(0.5,0,3)
#@gimp : Fibers amplitude = float(0,0,255)
#@gimp : Fibers smoothness = float(0,0,10)
#@gimp : Angle = choice("0 deg.","22.5 deg.","45 deg.","67.5 deg.")
#@gimp : X-curvature = float(0,-1,1)
#@gimp : Y-curvature = float(0,-1,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/01/18</i>.</small>")

#@gimp Whirls : gimp_whirls, gimp_whirls_preview(0)
#@gimp : Density = int(7,3,20)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Darkness = float(0.2,0,1)
#@gimp : Lightness = float(1.8,1,3)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_whirls :
  -apply_channels "-whirls $1,$2,$3,$4",$5,0

gimp_whirls_preview :
  -gimp_split_preview "-gimp_whirls $*",$-1


#@gimp _<b>Repair</b>
#---------------------

#@gimp Bayer reconstruction : bayer2rgb, gimp_no_preview
#@gimp : G/M smoothness = _float(6,0,20)
#@gimp : R/B smoothness (principal) = _float(6,0,20)
#@gimp : R/B smoothness (secondary) = _float(4,0,20)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Deinterlace : deinterlace, gimp_deinterlace_preview(0)
#@gimp : Algorithm = choice("Standard","Motion-compensated")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_deinterlace :
  -deinterlace 0 -skip ${^0}

gimp_deinterlace_preview :
  -gimp_split_preview "-gimp_deinterlace $*",$-1

#@gimp Inpaint [diffusion] : gimp_inpaint_diffusion, gimp_inpaint_diffusion_preview(0)
#@gimp : Smooth inpaint = bool(true)
#@gimp : Global iterations = int(10,1,30)
#@gimp : Local iterations = int(10,1,30)
#@gimp : Time step = float(20,5,50)
#@gimp : Gradient smoothness = float(0.7,0,5)
#@gimp : Tensor smoothness = float(1.2,0,5)
#@gimp : sep = separator()
#@gimp : Mask type = choice(1,"Opaque regions in top layer","Mask by color")
#@gimp : note = note("<small>If <i>Mask by color</i> has been selected :</small>")
#@gimp : Mask color = color(255,0,0,255)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note:</b>
#@gimp : When <i>'Mask by color'</i> mode is selected, preview is likely to be inaccurate.
#@gimp : </small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_inpaint_diffusion :
  -if $7 # Mask by color.
    -repeat @# -l[$>]
      --select_color 0,${8-11} -rv
      -if $1 -inpaint_flow $2,$3,$4,$5%,$6% -c 0,255 -else -inpaint[1] [0] -endif
      -rm[0]
    -endl -done
  -else # Mask by top layer.
    -if {@#==1} -return -endif
    -to_a[0] -channels[0] 100% -ge[0] 50%
    -if $1 -inpaint_flow $2,$3,$4,$5%,$6% -c 0,255 -else -inpaint[^0] [0] -endif
    -to_a[0] -f[0] 0
  -endif

gimp_inpaint_diffusion_preview :
  -gimp_inpaint_diffusion ${^0}
  -if {!$7" && "@#>1} -rm[0] -endif

#@gimp Inpaint [patch-based] : gimp_inpaint_patch, gimp_no_preview
#@gimp : Patch size = int(11,1,64)
#@gimp : Lookup factor = float(3,1,16)
#@gimp : Lookup increment = int(2,1,10)
#@gimp : Blend size = int(16,0,200)
#@gimp : Blend threshold = float(0,0,1)
#@gimp : Blend decay = float(0.05,0,0.5)
#@gimp : Blend scales = int(10,1,20)
#@gimp : Allow outer blending = bool(1)
#@gimp : sep = separator()
#@gimp : Mask type = choice(1,"Opaque regions in top layer","Mask by color")
#@gimp : note = note("<small>If <i>Mask by color</i> has been selected :</small>")
#@gimp : Mask color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Authors: <i>David Tschumperl&#233;</i> and <i>Maxime Daisy</i>.      Latest update: <i>2013/03/25</i>.</small>")
gimp_inpaint_patch :
  -if {@.>=1581} inpaint=inpaint -else inpaint=repair -endif
  -if $9 # Mask by color.
    -repeat @# -l[$>]
      --select_color 0,${10-13}
      -$inpaint[0] [1],$1,{$1*$2},${3-8}
      -rm[1]
    -endl -done
  -else # Mask by top layer.
    -if {@#==1} -return -endif
    -to_a[0] -channels[0] 100% -ge[0] 50%
    -$inpaint[^0] [0],$1,{$1*$2},${3-8}
    -to_a[0] -f[0] 0
  -endif

#@gimp Inpaint [solidify] : gimp_solidify, gimp_solidify_preview(0)
#@gimp : Interpolation type = choice("Linear","Morphological")
#@gimp : sep = separator(), note = note("<small><b>For linear method only :</b></small>")
#@gimp : Smoothness = float(1.5,1,5)
#@gimp : Smoothness factor = float(1,1,1.2)
#@gimp : Precision = float(0.5,0,1)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small><b>Note:</b>
#@gimp : This filter replaces transparent regions by interpolated colors. It may take long to render!
#@gimp : </small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/12/01</i>.</small>")
gimp_solidify :
  -if $1 -solidify
  -else -solidify_linear $2,$3,$4
  -endif

gimp_solidify_preview :
  -gimp_split_preview "-gimp_solidify $*",$-1

#@gimp Red-eye attenuation : red_eye, red_eye
#@gimp : Threshold = float(75,0,100)
#@gimp : Smoothness = float(3.5,0,20)
#@gimp : Factor = float(0.1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")

#@gimp Remove hot pixels : gimp_remove_hotpixels, gimp_remove_hotpixels_preview(0)
#@gimp : Mask size = int(3,3,20)
#@gimp : Threshold = float(10,0,200)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_remove_hotpixels :
  -remove_hotpixels $1,$2

gimp_remove_hotpixels_preview :
  -gimp_split_preview "-gimp_remove_hotpixels $*",$-1

#@gimp Smooth [anisotropic] : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing_preview(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_anisotropic_smoothing : -skip ${13=1},${14=0}
  -repeat @# -l[$>]
    -apply_channels "-gimp_parallel_overlap \"-repeat $11 -smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done\",$13,$14",$12,0
  -endl -done -c 0,255

gimp_anisotropic_smoothing_preview :
  -gimp_split_preview "-gimp_anisotropic_smoothing $*",$-1

#@gimp Smooth [bilateral] : gimp_bilateral, gimp_bilateral_preview(0)
#@gimp : Spatial variance = float(10,0,100)
#@gimp : Value variance = float(7,0,100)
#@gimp : Iterations = int(2,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_bilateral : -skip ${5=0},${6=0}
  -apply_channels "-gimp_parallel_overlap \"-repeat $3 -bilateral $1,$2 -done\",$5,$6",$4,0

gimp_bilateral_preview :
  -gimp_split_preview "-gimp_bilateral $*",$-1

#@gimp Smooth [diffusion] : gimp_diffusion_smoothing, gimp_diffusion_smoothing_preview(0)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Time step = float(15,5,50)
#@gimp : Iterations = int(8,1,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_diffusion_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-smooth $6,$1,$2,$3,$4,$5,0 -c 0,255\",$8,$9",$7,0

gimp_diffusion_smoothing_preview :
  -gimp_split_preview "-gimp_diffusion_smoothing $*",$-1

#@gimp Smooth [mean-curvature] : gimp_meancurvature_smoothing, gimp_meancurvature_smoothing_preview(0)
#@gimp : Time step = float(30,5,50)
#@gimp : Iterations = int(4,1,30)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_meancurvature_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-meancurvature_flow $2,$1,$3 -c 0,255\",$5,$6",$4,0

gimp_meancurvature_smoothing_preview :
  -gimp_split_preview "-gimp_meancurvature_smoothing $*",$-1

#@gimp Smooth [median] : gimp_median, gimp_median_preview(0)
#@gimp : Radius = int(3,1,20)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_median :
  -apply_channels "-median $1",$2,0

gimp_median_preview :
  -gimp_split_preview "-gimp_median $*",$-1

#@gimp Smooth [patch-based] : gimp_patch_smoothing, gimp_patch_smoothing_preview(0)
#@gimp : Spatial variance = float(10,0.1,200)
#@gimp : Patch variance = float(10,0.1,200)
#@gimp : Patch size = int(3,2,21)
#@gimp : Lookup size = int(5,2,21)
#@gimp : Patch smoothness = float(0,0,4)
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_patch_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done -c 0,255\",$9,$10",$8,0

gimp_patch_smoothing_preview :
  -gimp_split_preview "-gimp_patch_smoothing $*",$-1

#@gimp Smooth [selective gaussian] : gimp_selective_smoothing, gimp_selective_smoothing_preview(0)
#@gimp : Amplitude = float(5,0,20)
#@gimp : Edges = float(0.5,0,2)
#@gimp : Scales = int(5,1,10)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_selective_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-repeat $4 -blur_selective $1,$2,$3 -done -c 0,255\",$6,$7",$5,0

gimp_selective_smoothing_preview :
  -gimp_split_preview "-gimp_selective_smoothing $*",$-1

#@gimp Smooth [skin] : gimp_smooth_skin, gimp_smooth_skin_preview(1)
#@gimp : note = note("<small><b>Step 1:</b> Skin detection</small>")
#@gimp : Skin estimation = choice(2,"None","Manual","Automatic")
#@gimp : Tolerance = float(0.5,0,1)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Threshold = float(1,0,10)
#@gimp : Pre-normalize image = bool(1)
#@gimp : X-coordinate [manual] = float(50,0,100)
#@gimp : Y-coordinate [manual] = float(50,0,100)
#@gimp : Radius [manual] = float(5,0,25)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Step 2:</b> Medium scale smoothing</small>")
#@gimp : Base scale = float(2,0,10)
#@gimp : Fine scale = float(0.2,0,0.8)
#@gimp : Smoothness = float(3,0,10)
#@gimp : Smoothness type = choice(1,"Gaussian","Bilateral")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Step 3:</b> Details enhancement</small>")
#@gimp : Gain = float(0.05,0,0.5)
#@gimp : sep = separator()
#@gimp : Preview data = choice{5,"Skin mask","Base scale","Medium scale (original)","Medium scale (smoothed)","Fine scale","Result image"}
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/12/20</i>.</small>")
gimp_smooth_skin :
  -repeat @# -l[$>] -split_opacity -l[0] -to_rgb

    # Skin detection step.
    -if $5 --balance_gamma 128,128,128 -else [0] -endif
    -if {$1==0} -channels[-1] 0 -f[-1] 1 -elif {$1==2} -detect_skin[-1] $2 -else -detect_skin[-1] $2,$6%,$7%,$8% -endif
    M={iM} -b[-1] $3% -*[-1] {$M/iM} -*[-1] $4 -c[-1] 0,1

    # Details smoothing step.
    -split_details[0] 4,$9%,$10%
    --_gimp_smooth_skin[2] $12,$11
    -j[2] [-1],0,0,0,0,1,[-2] -rm[-2,-1]
    -*[-1] {10^$13} -+ -c 0,255

  -endl -a c -endl -done

_gimp_smooth_skin :
  -if {$1==0} -b {$2/8}%
  -else
    -if {$2>0}
      m={im} M={iM} -n 0,255
      -repeat {int($2/5)} -bilateral 3%,{5*3} -done
      -bilateral 3%,{($2%5)*3}
      -* {($M-$m)/255} -+ $m
    -endif
  -endif

gimp_smooth_skin_preview :
  -if {$-2==0}
    -gimp_split_preview "-if $5 -balance_gamma 128,128,128 -endif -if {$1==0} -f 1 -elif {$1==2} -detect_skin $2 -else -detect_skin $2,$6%,$7%,$8% -endif M={iM} -b $3% -* {255*$M/iM} -* $4 -c 0,255",$-1
  -elif {$-2==1}
    -gimp_split_preview "-b $9%",$-1
  -elif {$-2==2}
    -gimp_split_preview "-split_details 4,$9%,$10% -k[-2] -n 0,255",$-1
  -elif {$-2==3}
    -gimp_split_preview "-split_details 4,$9%,$10% -k[-2] -_gimp_smooth_skin $12,$11 -n 0,255",$-1
  -elif {$-2==4}
    -gimp_split_preview "-split_details 4,$9%,$10% -k[-1] -n 0,255",$-1
  -else
    -gimp_split_preview "-gimp_smooth_skin $*",$-1
  -endif

  -if {$1==1}
    -to_rgb
    -circle $6%,$7%,$8%,0.2,0,255,0
    -circle $6%,$7%,$8%,0.4,0xFFFFFFFF,0,255,0
    -line {$6-0.25*$8}%,{$7-0.25*$8}%,{$6+0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
    -line {$6+0.25*$8}%,{$7-0.25*$8}%,{$6-0.25*$8}%,{$7+0.25*$8}%,0.8,255,255,0
  -endif

#@gimp Smooth [thin brush] : gimp_anisotropic_smoothing, gimp_anisotropic_smoothing(0)
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.9,0,2)
#@gimp : Anisotropy = float(0.64,0,1)
#@gimp : Gradient smoothness = float(3.1,0,10)
#@gimp : Tensor smoothness = float(1.10,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Iterations = int(1,1,10)
#@gimp : Channel(s) = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : note = note{"\n<small><b>Note: </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>PhotoComiX</i>.      Latest update: <i>2010/12/26</i>.</small>")

#@gimp Smooth [total variation] : gimp_tv_smoothing, gimp_tv_smoothing_preview(0)
#@gimp : Time step = float(30,5,100)
#@gimp : Iterations = int(10,1,40)
#@gimp : Keep iterations as different layers = bool(false)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_tv_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-tv_flow $2,$1,$3 -c 0,255\",$5,$6",$4,0

gimp_tv_smoothing_preview :
  -gimp_split_preview "-gimp_tv_smoothing $*",$-1

#@gimp Smooth [wavelets] : gimp_haar_smoothing, gimp_haar_smoothing_preview(0)
#@gimp : Threshold = float(1,0,10)
#@gimp : Iterations = int(10,1,32)
#@gimp : Scales = int(10,2,10)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : sep = separator()
#@gimp : Parallel processing = choice("Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gimp : Spatial overlap = int(24,0,256)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>J&#233;rome Boulanger and David Tschumperl&#233;</i>.      Latest update: <i>2013/08/27</i>.</small>")
gimp_haar_smoothing :
  -apply_channels "-gimp_parallel_overlap \"-denoise_haar $1,$3,$2 -c 0,255\",$5,$6",$4,0

gimp_haar_smoothing_preview :
  -gimp_split_preview "-gimp_haar_smoothing $*",$-1

#@gimp Upscale [diffusion] : gimp_upscale_smart, gimp_upscale_smart_preview(0)
#@gimp : Width = text("200%")
#@gimp : Height = text("200%")
#@gimp : Smoothness = float(2,0,20)
#@gimp : Anisotropy = float(0.4,0,1)
#@gimp : Sharpness = float(50,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_upscale_smart :
  -to_rgb -upscale_smart $1,$2,1,$3,$4,$5 -c 0,255

gimp_upscale_smart_preview :
  -repeat @#
    --r[-1] $1,$2,1,1,0
    -if {w<@{-2,w}||h<@{-2,h}}  # Test for downscaling
      -rm[-1] -/[-1] 4
      0 -t[-1] "Downscaling is\nnot allowed!",5,5,20,1,255 -r[-1] [-2],[-2],1,1,0,0,0.5,0.5
      -or[-2,-1]
    -else
      -z[-2] {50-50*@{-2,w}/w}%,{50-50*@{-2,h}/h}%,{50+50*@{-2,w}/w}%,{50+50*@{-2,h}/h}%
      -rm[-1] -gimp_upscale_smart[-1] $1,$2,$3,$4,$5 -c[-1] 0,255
    -endif
  -mv[-1] 0 -done

#@gimp Upscale [scale2x] : gimp_scalenx, gimp_scalenx_preview(0)
#@gimp : Scaling factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gimp : Colorbase = choice(1,"RGB","YCbCr","Lab")
#@gimp : note = note{"\n<small><b>Note: </b>
#@gimp : This filter re-implements the scaling algorithm described at :
#@gimp : </small>"}
#@gimp : note = link("http://scale2x.sourceforge.net")
#@gimp : note = note{"<small>
#@gimp : This filter is useful for resizing images that have very few colors
#@gimp : (e.g. indexed images). It is generally useless for true colors images.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_scalenx :
  -repeat @# -l[$>] -split_opacity
    -if {$2==1} -rgb2ycbcr[0] -round[0]
    -elif {$2==2} -rgb2lab8[0] -round[0]
    -endif

    -if {$1==0} -scale2x
    -elif {$1==1} -scale3x
    -elif {$1==2} -scale2x -scale2x
    -elif {$1==3} -scale3x -scale2x
    -elif {$1==4} -scale2x -scale2x -scale2x
    -elif {$1==5} -scale3x -scale3x
    -elif {$1==6} -scale3x -scale2x -scale2x
    -elif {$1==7} -scale2x -scale2x -scale2x -scale2x
    -elif {$1==8} -scale3x -scale3x -scale2x
    -elif {$1==9} -scale3x -scale3x -scale3x
    -endif

    -if {$2==1} -ycbcr2rgb[0]
    -elif {$2==2} -lab82rgb[0]
    -endif

  -a c -endl -done

gimp_scalenx_preview :
  -z 40%,40%,60%,60%
  -gimp_scalenx $1,$2


#@gimp _<b>Rendering</b>
#-----------------------

# Generic function to render a 3d image, with usual rendering parameters :
# $1 = Width
# $2 = Height
# $3 = Object size
# $4 = X-angle
# $5 = Y-angle
# $6 = Z-angle
# $7 = FOV
# $8 = X-light
# $9 = Y-light
# $10 = Z-light
# $11 = Specular lightness
# $12 = Specular shininess
# $13 = Rendering mode.
gimp_render3d :
  -n3d -c3d -m3d $13 f3d={0.5*max($1,$2)/tan($7*pi/360)}
  -f3d $f3d -l3d {$8*$f3d},{$9*$f3d},{$10*$f3d} -sl3d $11 -ss3d $12
  -repeat @# -l[$>]
    -*3d {$3*max($1,$2)} -r3d 0,0,1,$6 -r3d 0,1,0,$5 -r3d 1,0,0,$4
    $1,$2,1,3,-1 -object3d[-1] [-2],50%,50% -rm[-2]
    -to_rgba -replace_color 0,0,-1,-1,-1,255,0,0,0,0
  -endl -done

#@gimp 3d colored object : gimp_coloredobject3d, gimp_coloredobject3d_preview(1)
#@gimp : Type = choice{1,"Plane","Box","Pyramid","Ellipsoid","Torus","Gyroid","Weird","Cup"}
#@gimp : Color = color(128,128,128,255)
#@gimp : sep = separator()
#@gimp : Size-1 = float(0.5,0,3)
#@gimp : Size-2 = float(0.5,0,3)
#@gimp : Size-3 = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/05/16</i>.</small>")
_gimp_coloredobject3d :
  -to_rgb -_gimp_coloredobject3d$1$2 ${6-8} -col3d[-1] ${3-5}
  -db3d 0

gimp_coloredobject3d :
  -_gimp_coloredobject3d "_",${1-4,6-8}
  -repeat {@#-1}
    --gimp_render3d[-1] @{$>,w},@{$>,h},$6,${9--1}
    -sh[-1] 3,3 -*[-1] {$5/255} -rm[-1]
    -blend[$>,-1] alpha
  -done
  -rm[-1]

gimp_coloredobject3d_preview :
  -_gimp_coloredobject3d "_preview_",${1-4,6-8}
  -repeat {@#-1}
    --gimp_render3d[-1] @{$>,w},@{$>,h},$6,${9--1}
    -sh[-1] 3,3 -*[-1] {$5/255} -rm[-1]
    -blend[$>,-1] alpha
  -done -rm[-1]

_gimp_coloredobject3d_0 : -plane3d 1 -*3d[-1] $1,$2,1
_gimp_coloredobject3d_1 : -box3d 1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_2 : -pyramid3d 1,1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_3 : -sphere3d 1 -*3d[-1] 1,{2*$2},{2*$3}
_gimp_coloredobject3d_4 : -torus3d $1,{$2/2} -*3d[-1] $3,0.5,0.5
_gimp_coloredobject3d_5 : -gyroid3d 24 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_6 : -weird3d 32 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_7 : -cup3d 128 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_0 : -plane3d 1 -*3d[-1] $1,$2,1
_gimp_coloredobject3d_preview_1 : -box3d 1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_2 : -pyramid3d 1,1 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_3 : -sphere3d 1 -*3d[-1] 1,{2*$2},{2*$3}
_gimp_coloredobject3d_preview_4 : -torus3d $1,{$2/2} -*3d[-1] $3,0.5,0.5
_gimp_coloredobject3d_preview_5 : -gyroid3d 8 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_6 : -weird3d 12 -*3d[-1] $1,$2,$3
_gimp_coloredobject3d_preview_7 : -cup3d 64 -*3d[-1] $1,$2,$3

#@gimp 3d elevation : gimp_elevation3d, gimp_elevation3d_preview(1)
#@gimp : Factor = float(100,-1000,1000)
#@gimp : Smoothness = float(1,0,10)
#@gimp : sep = separator()
#@gimp : Width = _int(1024,8,4096)
#@gimp : Height = _int(1024,8,4096)
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(25,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_elevation3d :
  -repeat {@#/2} -l[$>,{min($>+1,@#-1)}]
    -if {@#==1} --norm -else -r[1] [0],3 -endif
    -n[1] 0,$1 -b[1] $2
    -elevation3d[0] [1] -rm[1]
  -endl -done
  -db3d

gimp_elevation3d :
  -_gimp_elevation3d ${1-2} -gimp_render3d ${3--1}

gimp_elevation3d_preview :
  -gimp_elevation3d ${1-2},{w},{h},${5--1}

#@gimp 3d extrusion : gimp_extrude3d, gimp_extrude3d_preview(1)
#@gimp : Depth = float(10,1,1024)
#@gimp : Resolution = int(512,1,1024)
#@gimp : Smoothness = float(0.6,0,3)
#@gimp : sep = separator()
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_extrude3d :
  -repeat {@#/2} -l[$>,{min($>+1,@#-1)}]
    -extrude3d[-1] $1,$2,$3%
    -if {@#==2} -t3d[-1] [-2] -rm[-2] -endif
  -endl -done
  -db3d 0

gimp_extrude3d :
  -_gimp_extrude3d ${1-3} -gimp_render3d ${4--1}

gimp_extrude3d_preview :
  -gimp_extrude3d ${1-3},{w},{h},${6--1}

#@gimp 3d image object : gimp_imageobject3d, gimp_imageobject3d_preview(1)
#@gimp : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gimp : sep = separator()
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_imageobject3d :
  -to_rgb -repeat @# -l[$>] -_gimp_imageobject3d$1$2 -endl -done
  -db3d 0

gimp_imageobject3d :
  -_gimp_imageobject3d "_",$1 -gimp_render3d ${2--1}

gimp_imageobject3d_preview :
  w={w} h={h} -_gimp_imageobject3d "_preview_",$1 -gimp_render3d $w,$h,${4--1}

_gimp_imageobject3d_0 : -imageplane3d
_gimp_imageobject3d_1 : -imagecube3d
_gimp_imageobject3d_2 : -imagepyramid3d
_gimp_imageobject3d_3 : -imagesphere3d 64,32
_gimp_imageobject3d_4 : -torus3d 100,30 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_5 : -gyroid3d 24 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_6 : -weird3d 32 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_7 : -cup3d 128 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_8 : -imagerubik3d 5,5
_gimp_imageobject3d_preview_0 : -imageplane3d
_gimp_imageobject3d_preview_1 : -imagecube3d
_gimp_imageobject3d_preview_2 : -imagepyramid3d
_gimp_imageobject3d_preview_3 : -imagesphere3d 16,8
_gimp_imageobject3d_preview_4 : -torus3d 100,30 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_5 : -gyroid3d 8 -c3d[-1] -n3d[-1] -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_6 : -weird3d 12 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_7 : -cup3d 64 -t3d[-1] [-2] -rm[-2]
_gimp_imageobject3d_preview_8 : -imagerubik3d 3,3,5,5

#@gimp 3d lathing : gimp_lathing3d, gimp_lathing3d_preview(1)
#@gimp : Resolution = int(76,1,1024)
#@gimp : Smoothness = float(0.6,0,3)
#@gimp : Max angle = float(361,0,361)
#@gimp : sep = separator()
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : sep = separator(), note = note{"<small><b>Note:</b> Add a top layer to define object texture.</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
_gimp_lathing3d :
  -repeat {@#/2} -l[$>,{min($>+1,@#-1)}]
    -lathe3d[-1] $1,$2%,$3
    -if {@#==2} -t3d[-1] [-2] -rm[-2] -endif
  -endl -done
  -db3d 0

gimp_lathing3d :
  -_gimp_lathing3d ${1-3} -gimp_render3d ${4--1}

gimp_lathing3d_preview :
  -gimp_lathing3d ${1-3},{w},{h},${6--1}

#@gimp 3d random objects : gimp_random3d, gimp_random3d(1)
#@gimp : Type = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gimp : Density = int(50,1,300)
#@gimp : Size = float(3,1,20)
#@gimp : Z-range = float(100,0,300)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : Rendering = choice(3,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_random3d :
  -repeat @# -l[$>]
    f3d={0.5*max(w,h)/tan($5*pi/360)} -f3d $f3d -l3d {$6*$f3d},{$7*$f3d},{$8*$f3d} -sl3d $9 -ss3d $10
    -to_rgb ({w},{h},{d},{s}) -/[-1] 2 -repeat $2
    (@{1,0}) -+[-1] @{1,1} -*[-1] $3 -/[-1] 100 -_gimp_random3d$1 @-1 -rm[-2]
    -r3d[-1] 1,1,0,{?(0,360)}
    ({?(-1,1)}) -*[-1] @{1,0} ({?(-1,1)}) -*[-1] @{1,1}
    -+3d[-3] @-2,@-1,{?(-$4,$4)} -rm[-2,-1]
    -col3d[-1] {?(255)},{?(255)},{?(255)} -done -+3d[2--1] -object3d[0] [-1],50%,50%,0,$12,$11,0,1
    -k[0]
  -endl -done

_gimp_random3d0 : -box3d $1
_gimp_random3d1 : ($1) -/[-1] 2 -cone3d @-1,$1 -rm[-2]
_gimp_random3d2 : ($1) -/[-1] 2 -cylinder3d @-1,$1 -rm[-2]
_gimp_random3d3 : -sphere3d $1,2
_gimp_random3d4 : ($1) -/[-1] 3 -torus3d $1,@-1 -rm[-2]

#@gimp Ball : gimp_ball, gimp_ball_preview(0)
#@gimp : Radius = int(128,1,1024)
#@gimp : Specular light = float(0.8,0,8)
#@gimp : Specular size = float(1,0,8)
#@gimp : Shadow = float(1.5,0,4)
#@gimp : Color = color(255,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/27</i>.</small>")
gimp_ball :
  -ball $1,${5-7},${2-4} -mv[-1] 0

gimp_ball_preview :
  -gimp_ball $*
  -if {@#>1} -blend[-2,-1] alpha,1,1 -endif

#@gimp Cupid : gimp_cupid, gimp_cupid
#@gimp : Smoothness = float(0,0,10)
#@gimp : Color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/13</i>.</small>")
gimp_cupid :
  -if {@#>0} siz={min(@{-min_w},@{-min_h})} -else siz=512 -endif
  -cupid $siz -to_rgba[-1]
  -replace_color[-1] 0,0,0,0,0,255,$2,$3,$4,0
  -replace_color[-1] 0,0,1,1,1,255,$2,$3,$4,$5
  -frame[-1] {2.5*$1}%,{2.5*$1}%,$2,$3,$4,0 -b[-1] $1%
  -blend[-2,-1] alpha

#@gimp Equation plot [parametric] : gimp_equation_parametric, gimp_equation_parametric
#@gimp : X(t) = text{"sin(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gimp : Y(t) = text{"cos(t)*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"}
#@gimp : Min-t = float(0,-1000,1000)
#@gimp : Max-t = float(100,-1000,1000)
#@gimp : Resolution = int(4096,2,32768)
#@gimp : Outline opacity = float(1,0,1)
#@gimp : Dot size = int(0,0,16)
#@gimp : Start color = color(64,0,0)
#@gimp : End color = color(128,0,0)
#@gimp : Colored outline = bool(1)
#@gimp : Antialiasing = bool(1)
#@gimp : Decoration = bool(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/13</i>.</small>")
gimp_equation_parametric :
  -repeat @# -l[$>]
    w={w} h={h} -rm
    $5,1,1,2,'"t=$3+x*($4-$3)/($5-1);if(c==0,$1,$2)"'
    -channels[-1] 0,2
    ($8,$11^$9,$12^$10,$13) -r[-1] @{-2,w},1,1,3,3 -a c
    -display_parametric $w,$h,{$6+$14*1.001},$7,$15,$16
  -endl -done

#@gimp Equation plot [y=f(x)] : gimp_equation_plot, gimp_equation_plot
#@gimp : F(x) = text{"X*c+10*cos(X+c+?)"}
#@gimp : X-min = float(-10,-100,100)
#@gimp : X-max = float(10,-100,100)
#@gimp : Resolution = int(100,2,1024)
#@gimp : Channels = int(3,1,32)
#@gimp : Plot type = choice(2,"None","Lines","Splines","Bars")
#@gimp : Vertex type = choice(0,"None","Points","Crosses 1","Crosses 2","Circles 1","Circles 2","Square 1","Square 2")
#@gimp : sep = separator()
#@gimp : note = note("<b>Note</b> :
#@gimp : Use variable <b>X</b> instead of <b>x</b> in the above equation to take care of the X-min/max settings.
#@gimp : Variable <b>c</b> refers to the current channel number.
#@gimp : Variable <b>?</b> refers to a uniformly distributed random value in [0,1].
#@gimp : Reduce resolution to be able to view
#@gimp : separate graph vertices.")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_equation_plot :
  -repeat @# -l[$>]
    w={w} h={h} -rm
    $4,1,1,$5,"X=$2+($3-$2)*x/($4-1);$1"
    -dg $w,$h,$6,$7,$2,$3
  -endl -done

#@gimp Gradient [corners] : gimp_corner_gradient, gimp_corner_gradient
#@gimp : Color 1 (up/left corner) = color(255,255,255,128)
#@gimp : Color 2 (up/right corner) = color(255,0,0,255)
#@gimp : Color 3 (bottom/left corner) = color(0,255,0,255)
#@gimp : Color 4 (bottom/right corner) = color(0,0,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_corner_gradient :
  -repeat @#
    ({w},{h}) -rm[-2]
    ($1,$5;$9,$13^$2,$6;$10,$14^$3,$7;$11,$15^$4,$8;$12,$16) -r[-1] @-2,1,4,3 -rm[-2]
  -mv[-1] 0 -done

#@gimp Gradient [custom shape] : gimp_custom_gradient, gimp_custom_gradient_preview(1)
#@gimp : note = note("<small><b>Shape selection:</b></small>")
#@gimp : Select by = choice("Auto","Dark pixels","Bright pixels","Opaque pixels")
#@gimp : Smoothness = float(0,0,10)
#@gimp : Threshold = float(0,0,100)
#@gimp : Preview shape = bool(1)
#@gimp : note = note("<small><b>Note:</b> Shapes with small strokes may lead to incorrect previews.</small>")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Gradient parameters:</b></small>")
#@gimp : Number of colors = int(4,2,10)
#@gimp : Cycles = float(1,1,16)
#@gimp : Offset = float(0,0,100)
#@gimp : Shading = float(128,1,256)
#@gimp : Inner length = float(100,0,100)
#@gimp : Outer length = float(100,0,100)
#@gimp : Spatial metric = choice(2,"Chebyshev","Manhattan","Euclidean")
#@gimp : Color metric = choice("RGB","HSV","Lab")
#@gimp : Shade back to first color = bool(1)
#@gimp : Preview gradient = bool(0)
#@gimp : Save gradient as = _text("")
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Color definitions:</b></small>")
#@gimp : Colormap type = choice(1,"Pre-defined","User-defined")
#@gimp : Pre-defined colormap = int(0,0,65535)
#@gimp : 1st color = color(0,0,0,255)
#@gimp : 2nd color = color(255,0,0,255)
#@gimp : 3rd color = color(255,255,0,255)
#@gimp : 4th color = color(255,255,255,255)
#@gimp : 5th color = color(0,255,255,255)
#@gimp : 6th color = color(0,255,0,255)
#@gimp : 7th color = color(0,0,255,255)
#@gimp : 8th color = color(128,128,128,255)
#@gimp : 9th color = color(255,0,255,255)
#@gimp : 10th color = color(0,0,0,0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/03</i>.</small>")
gimp_custom_gradient_preview : -skip "${15=}"
  -repeat @# -l[$>]
    -if $4
      --_gimp_custom_gradient1 ${1-14},"$15",${16--1} --erode[-1] 3 --[-2,-1] --dilate[-1] 5 -a[-2,-1] c -n[-1] 0,255
      -gimp_custom_gradient[0] ${1-14},"$15",${16--1},-1 -blend alpha
    -else -gimp_custom_gradient ${1-14},"$15",${16--1},-1
    -endif
    -if $14
      --_gimp_custom_gradient0[] ${1-14},"$15",${16--1} -r[-1] {@{0,w}-16},16,1,4 -frame[-1] 1,1,0 -j[0] [-1],8,@{0,h-25} -rm[-1]
    -endif
  -endl -done

gimp_custom_gradient : -skip "${15=}"
  -_gimp_custom_gradient0 ${1-14},"$15",${16--1}
  -if {$-1>=0&&narg("$15")}
    dir_ggr=@{-path_gimp}/gradients
    0 -nm[-1] @{"-normalize_filename \"$15\""} name_ggr=@{-1,b} -rm[-1] -output_ggr[-1] $dir_ggr/$name_ggr.ggr,"$15"
  -endif
  -i[-2] (0^0^0^0) -a[-2,-1] x
  -repeat {@#-1} -l[$>,-1]
    -_gimp_custom_gradient1[0] ${1-14},"$15",${16--1}
    --distance[0] 1,$11 --distance[0] 0,$11 -*[-1] -1 -+[0] 1 -+[0,-2,-1]  # Signed distance function.
    m={$9%*@{0,im}} M={$10%*@{0,iM}}
    --[0] $m -*[0] {@{1,w-2}/($M-$m)} -+[0] 1
    -round[0] -map[0] [-1]
  -endl -done
  -rm[-1]

# Create colormap.
_gimp_custom_gradient0 :
  -if $16 4,8,1,1,${18-56} -permute[-1] yzcx
  -else 8,1,1,3 -srand $17 -rand[-1] 0,255 -to_rgba[-1]
  -endif
  -z[-1] 0,{$5-1}
  -if $13
    -r[-1] {200*$6}%,1,1,4,0,2
    -__gimp_custom_gradient0[-1] $12,$8
    -shift[-1] {-$7/2}%,0,0,0,2 -z[-1] 0,{w/2-1}
  -else
    -__gimp_custom_gradient0[-1] $12,$8
    -r[-1] {100*$6}%,1,1,4,0,2 -shift[-1] -$7%,0,0,0,2
    -endif

__gimp_custom_gradient0 :
  -if {$1==1} -sh[-1] 0,2 -rgb2hsv[-1] -rm[-1]
  -elif {$1==2} -sh[-1] 0,2 -srgb2rgb[-1] -rgb2lab[-1] -rm[-1]
  -endif
  -r[-1] {$2*w},1,1,4,3
  -if {$1==1} -sh[-1] 0,2 -hsv2rgb[-1] -rm[-1]
  -elif {$1==2} -sh[-1] 0,2 -lab2rgb[-1] -rgb2srgb[-1] -rm[-1]
  -endif

# Extract shape from image.
_gimp_custom_gradient1 :
  -b $2%
  -if {$1==0} # Auto-mode.
    -to_a -split_opacity
    -if {iM>im+32}
      -rm[-2] -ge[0] {100-$3}%
    -else
      -rm[-1] -norm -n 0,1
      -if {ia>0.5} -le[0] $3% -else -ge[0] {100-$3}% -endif
    -endif
  -elif {$1==1} # Dark pixels.
    -remove_opacity -norm -le $3%
  -elif {$1==2} # Bright pixels.
    -remove_opacity -norm -ge {100-$3}%
  -else # Opaque pixels.
    -to_a -channels 100% -ge {100-$3}%
  -endif

#@gimp Gradient [from line] : gimp_line_gradient, gimp_line_gradient_preview(1)
#@gimp : note = note("<small><b><span foreground="red">Starting point:</span></b></small>")
#@gimp : X0 = float(0,0,100)
#@gimp : Y0 = float(0,0,100)
#@gimp : note = note("<small><b><span foreground="blue">Ending point:</span></b></small>")
#@gimp : X1 = float(100,0,100)
#@gimp : Y1 = float(100,0,100)
#@gimp : sep = separator()
#@gimp : Sampling = float(100,0,100)
#@gimp : Length = int(0,0,4096)
#@gimp : note = note("<small><b>Note:</b> Set length to <i>0</i> to release gradient length constraints.</small>")
#@gimp : Sort colors = choice("Don't sort","By red component","By green component","By blue component","By luminance","By blue chrominance","By red chrominance","By lightness")
#@gimp : Reverse gradient = bool(0)
#@gimp : sep = separator()
#@gimp : Preview gradient = bool(1)
#@gimp : Save gradient as = _text("")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/10/09</i>.</small>")
gimp_line_gradient : -skip "${10=}"
  -_gimp_line_gradient $*
  -if {narg("$10")}
    dir_ggr=@{-path_gimp}/gradients
    0 -nm[-1] @{"-normalize_filename \"$10\""} name_ggr=@{-1,b} -rm[-1] -output_ggr[-1] $dir_ggr/$name_ggr.ggr,"$10"
  -endif
  -repeat @# -r[$>] 100%,64,1,100% -done

gimp_line_gradient_preview :
  -repeat @# -l[$>]
    -to_rgba
    -if $9 --_gimp_line_gradient $* -endif
    -l[0]
      -line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
      -line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
      -circle $1%,$2%,4,1,255,0,0,255
      -circle $3%,$4%,4,1,0,0,255,255
      -circle $1%,$2%,4,1,0xFFFFFFFF,0,0,0,255
      -circle $3%,$4%,4,1,0xFFFFFFFF,0,0,0,255
    -endl
    -if {@#>1} -r[-1] {@{0,w}-32},32,1,4,1 -frame[-1] 1,1,0,0,0,255 -j[0] [1],16,{@{0,h}-48} -rm[-1] -endif
  -endl -done

_gimp_line_gradient :
  -at_line $1%,$2%,0,$3%,$4%,0 -r {max(0.1,$5)}%,1,1,100%,1
  -m "feature1 : -channels 0"
  -m "feature2 : -channels 1"
  -m "feature3 : -channels 2"
  -m "feature4 : -to_rgb -luminance"
  -m "feature5 : -to_rgb -rgb2ycbcr -channels 1"
  -m "feature6 : -to_rgb -rgb2ycbcr -channels 2"
  -m "feature7 : -to_rgb -srgb2rgb -rgb2lab -channels 0"
  -if $7 -repeat @# -l[$>] --feature$7 -rv -a y -sort +,x -rows 1 -endl -done -endif
  -if $6 -r $6,1,1,100%,3 -endif
  -if $8 -mirror x -endif

#@gimp Gradient [linear] : gimp_linear_gradient, gimp_linear_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Swap colors = bool(0)
#@gimp : Angle = float(45,0,360)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_linear_gradient :
  -repeat @#
    ({w},{h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    -if $9 -rv[-2,-1] -endif
    -r[-2,-1] @-3 -rm[-3]
    -fade_linear $10,$11,$12
  -mv[-1] 0 -done

#@gimp Gradient [radial] : gimp_radial_gradient, gimp_radial_gradient
#@gimp : Starting color = color(0,0,0,255)
#@gimp : Ending color = color(255,255,255,255)
#@gimp : Swap colors = bool(0)
#@gimp : Fade start = float(0,0,100)
#@gimp : Fade end = float(100,0,100)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_radial_gradient :
  -repeat @#
    ({w},{h}) -rm[-2]
    ($1^$2^$3^$4) ($5^$6^$7^$8)
    -if $9 -rv[-2,-1] -endif
    -r[-2,-1] @-3 -rm[-3]
    100%,100% -=[-1] 1,$12%,$13% -distance[-1] 1 -_fade $10,$11
  -mv[-1] 0 -done

#@gimp Heart : gimp_heart, gimp_heart_preview
#@gimp : Size = float(75,0,100)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Color = color(255,0,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2013/11/13</i>.</small>")
gimp_heart :
  -if {@#>0} wh=@{-max_wh} w={$1%*min(512,arg(1,$wh))} h={$1%*min(512,arg(2,$wh))} -else w={$1%*512} h={$1%*512} -endif
  -heart {max(1,$w)},{max(1,$h)} -to_rgba[-1]
  -replace_color[-1] 0,0,1,1,1,255,$3,$4,$5,$6
  -replace_color[-1] 0,0,0,0,0,255,$3,$4,$5,0
  -b[-1] $2% -mv[-1] 0

gimp_heart_preview :
  -gimp_heart $* -blend[0,-1] alpha,1,1

#@gimp Lissajous : gimp_lissajous, gimp_lissajous(1)
#@gimp : Resolution = int(4096,2,8192)
#@gimp : sep = separator()
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : Z-size = float(3,1,10)
#@gimp : sep = separator()
#@gimp : X-multiplier = float(8,0,32)
#@gimp : Y-multiplier = float(7,0,32)
#@gimp : Z-multiplier = float(0,0,32)
#@gimp : sep = separator()
#@gimp : X-offset = float(0,0,1)
#@gimp : Y-offset = float(0,0,1)
#@gimp : Z-offset = float(0,0,1)
#@gimp : sep = separator()
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : sep = separator()
#@gimp : Thickness = float(0,0,50)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/04/18</i>.</small>")
gimp_lissajous :
  -repeat @# -l[$>] -to_rgba
    {w},{h}
    -f3d {0.5*max(w,h)/tan($4*pi/360)}
    -lissajous3d $1,$5,$8,$6,$9,$7,$10
    -r3d[-1] 0,0,1,$13 -r3d[-1] 0,1,0,$12 -r3d[-1] 1,0,0,$11
    -*3d[-1] {0.5*$2*@{-2,w}},{0.5*$3*@{-2,h}},{0.5*$4*max(@{-2,w},@{-2,h})}
    -col3d[-1] 1 -object3d[-2] [-1],50%,50%,0,1,1,0,0 -rm[-1]
    -distance[-1] 1 -gt[-1] $14% -*[-2] [-1] -eq[-1] 0
    -r[-1] 100%,100%,1,4
    -sh[-1] 0,0 -*[-1] $15 -rm[-1]
    -sh[-1] 1,1 -*[-1] $16 -rm[-1]
    -sh[-1] 2,2 -*[-1] $17 -rm[-1]
    -sh[-1] 3,3 -*[-1] $18 -rm[-1]
    -+[-2,-1]
  -endl -done

#@gimp Mandelbrot-julia sets : gimp_mandelbrot, gimp_mandelbrot_preview
#@gimp : X-center = float(0,-2,2)
#@gimp : Y-center = float(0,-2,2)
#@gimp : Zoom = float(0,0,100)
#@gimp : Iterations = int(128,1,512)
#@gimp : Fractal set = choice(Mandelbrot, Julia)
#@gimp : X-seed (Julia) = text("0.317")
#@gimp : Y-seed (Julia) = text("0.03")
#@gimp : Color 1 = color(0,0,255)
#@gimp : Color 2 = color(0,255,0)
#@gimp : Color 3 = color(255,0,0)
#@gimp : Color 4 = color(255,0,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_mandelbrot :
  (0^0^0) ($8^$9^$10) ($11^$12^$13) ($14^$15^$16) ($17^$18^$19)
  -a[-4--1] x -r[-1] $4,1,1,3,3 -a[-2,-1] x -mv[-1] 0
  -repeat {@#-1}
    wh={w},{h} -rm[-1] $wh
    -mandelbrot[-1] {$1-2/(1+$3)},{$2-2/(1+$3)},{$1+2/(1+$3)},{$2+2/(1+$3)},$4,$5,{if($5,$6,0)},{if($5,$7,0)}
    -map[-1] [0]
  -mv[-1] 1 -done -rm[0]

gimp_mandelbrot_preview :
  -gimp_mandelbrot ${^0}
  -line 0,50%,100%,50%,0.5,255
  -line 50%,0,50%,100%,0.5,255

#@gimp Quick copyright : gimp_quick_copyright, gimp_quick_copyright(0)
#@gimp : Text = text{"(c) G'MIC"}
#@gimp : Size = int(24,13,128)
#@gimp : Color = color(255,255,255,128)
#@gimp : Outline = int(1,0,4)
#@gimp : Position = choice(3,"Up-left","Up-right","Bottom-left","Bottom-right")
#@gimp : Offset = int(5,0,40)
#@gimp : Orientation = choice(1,"-90 deg.","0 deg.","+90 deg.","+180 deg.")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_quick_copyright :
  -i[0] 0 -t[0] "$1",0,0,$2,1,$3,$4,$5 -autocrop[0] 0 -r[0] {@{0,w}+2*$7},{@{0,h}+2*$7},1,3,0,0,0.5,0.5
  -i[1] 0 -t[1] "$1",0,0,$2,1,1 -autocrop[1] 0 -r[1] {@{1,w}+2*$7},{@{1,h}+2*$7},1,1,0,0,0.5,0.5 -dilate[1] {1+2*$7}
  -rotate[0,1] {90*($10-1)}
  -repeat {@#-2}
  -if {$8==0} -j[-1] [0],$9,$9,0,0,{$6/255},[1]
  -elif {$8==1} -j[-1] [0],{w-1-@{0,w}-$9},$9,0,0,{$6/255},[1]
  -elif {$8==2} -j[-1] [0],$9,{h-1-@{0,h}-$9},0,0,{$6/255},[1]
  -else -j[-1] [0],{w-1-@{0,w}-$9},{h-1-@{0,h}-$9},0,0,{$6/255},[1]
  -endif
  -mv[-1] 2 -done
  -rm[0,1]

#@gimp Rainbow : gimp_rainbow, gimp_rainbow
#@gimp : Left position = float(80,0,100)
#@gimp : Right position = float(80,0,100)
#@gimp : Left slope = float(175,0,400)
#@gimp : Right slope = float(175,0,400)
#@gimp : Thinness = float(3,0.1,8)
#@gimp : Opacity = float(80,0,199)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_rainbow :
  -repeat @# -l[$>]
    100%,100% -spline[-1] 0,$1%,100,{-$3}%,100%,$2%,100,$4%,256,1,1
    -flood[-1] 0,0,0,0,0,1,1 -flood[-1] {w-1},0,0,0,0,1,1
    -distance[-1] 0 -c[-1] 0,255 -n[-1] 0,{$5*255}
    -rainbow_lut --luminance[-1] -c[-1] 0,{min(100,200-$6)}% -n[-1] 0,255 -a[-2,-1] c
    -map[-2] [-1] -rm[-1]
    -if {$6<100} -sh[-1] 3,3 -*[-1] {$6/100} -rm[-1] -endif
    -blend alpha
  -endl -done

#@gimp Shade bobs : gimp_shadebobs, gimp_shadebobs
#@gimp : note = note("<small>Bobs parameters :</small>")
#@gimp : Density = int(50,1,200)
#@gimp : Radius = int(5,1,100)
#@gimp : Duration = int(200,1,500)
#@gimp : Velocity = float(1,0,10)
#@gimp : sep = separator()
#@gimp : note = note("<small>Curve parameters :</small>")
#@gimp : Rx = float(-1,-3,3)
#@gimp : Ry = float(2,-3,3)
#@gimp : Rz = float(1,-3,3)
#@gimp : Rt = float(0.8,-3,3)
#@gimp : Rcx = float(0,-3,3)
#@gimp : Colormap = choice(8,"Grayscale","Standard","HSV","Lines","Hot","Cool","Jet","Flag","Cube")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/04/18</i>.</small>")
gimp_shadebobs :
  -channels 0 -f 0
  -repeat @# -l[$>]
    t=0
    -repeat $3
      -repeat $1
        r={$6+$5*cos(6*$7*$t)+(1-$5)*sin(6*$8*$t)}
        a={(360*sin($7*$t)+30*$6*$>)*pi/180}
        ax={2*$>*pi/$1+$t}
        cx={(1+$9*cos($ax)+$r*cos($a))*w/2}
        cy={(1+$9*sin($ax)+$r*sin($a))*h/2}
        -ellipse[-1] $cx,$cy,$2%,$2%,0,-1,1
      -done
      t={$t+$4/100}
    -done
  -endl -done
  -and 255 -if $10 -map {$10-1} -endif

#@gimp Sierpinski triangle : gimp_sierpinski, gimp_sierpinski(1)
#@gimp : Recursions = int(6,0,10)
#@gimp : 1st X-coord = float(50,0,100)
#@gimp : 1st Y-coord = float(0,0,100)
#@gimp : 2nd X-coord = float(0,0,100)
#@gimp : 2nd Y-coord = float(100,0,100)
#@gimp : 3rd X-coord = float(100,0,100)
#@gimp : 3rd Y-coord = float(100,0,100)
#@gimp : Color = color(128,128,128)
#@gimp : Opacity = float(1,0,1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_sierpinski :
  -repeat @# -l[$>] -split_opacity -l[0]
    100%,100% -sierpinski[-1] ${1-7}
    --fc[-2] $8,$9,$10 -j[0] [-1],0,0,0,0,$11,[-2],255 -rm[-2,-1]
  -endl -a c -endl -done

#@gimp Snowflake : gimp_snowflake, gimp_snowflake(1)
#@gimp : Recursions = int(3,0,5)
#@gimp : 1st X-coord = float(20,0,100)
#@gimp : 1st Y-coord = float(70,0,100)
#@gimp : 2nd X-coord = float(80,0,100)
#@gimp : 2nd Y-coord = float(70,0,100)
#@gimp : 3rd X-coord = float(50,0,100)
#@gimp : 3rd Y-coord = float(10,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : Color = color(128,128,128)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_snowflake :
  -repeat @# -l[$>] -split_opacity -l[0]
    -snowflake ${1-11}
  -endl -a c -endl -done

#@gimp Superformula : gimp_superformula, gimp_superformula(1)
#@gimp : Resolution = int(4096,2,8192)
#@gimp : sep = separator()
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : sep = separator()
#@gimp : m = int(8,1,32)
#@gimp : n1 = float(1,-32,32)
#@gimp : n2 = float(5,-32,32)
#@gimp : n3 = float(8,-32,32)
#@gimp : sep = separator()
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : sep = separator()
#@gimp : Thickness = float(3,0,50)
#@gimp : Color = color(128,255,128,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/04/18</i>.</small>")
gimp_superformula :
  -repeat @# -l[$>] -to_rgba
    {w},{h}
    -f3d {0.5*max(w,h)/tan($4*pi/360)}
    -superformula3d $1,${4-7}
    -r3d[-1] 0,0,1,$10 -r3d[-1] 0,1,0,$9 -r3d[-1] 1,0,0,$8
    -*3d[-1] {0.5*$2*@{-2,w}},{0.5*$3*@{-2,h}}
    -col3d[-1] 1 -object3d[-2] [-1],50%,50%,0,1,1,0,0 -rm[-1]
    -distance[-1] 1 -gt[-1] $11% -*[-2] [-1] -eq[-1] 0
    -r[-1] 100%,100%,1,4
    -sh[-1] 0,0 -*[-1] $12 -rm[-1]
    -sh[-1] 1,1 -*[-1] $13 -rm[-1]
    -sh[-1] 2,2 -*[-1] $14 -rm[-1]
    -sh[-1] 3,3 -*[-1] $15 -rm[-1]
    -+[-2,-1]
  -endl -done

#@gimp _<b>Sequences</b>
#-----------------------


# gimp_animate_preview : _command,_parameters1,_parameters2,_compute_half={ 0 | 1 },_width>=0,_height>=0
# Generate a preview with start/end rendering of an animation.
gimp_animate_preview : -skip ${4=1},${5=0},${6=$5}
  -repeat @#
    -if $5 width=$5 -else width={w} -endif
    -if $6 height=$6 -else height={h} -endif
    -if $4 -s[-1] x,2 -else [-1] -endif
    -$1[-2] $2 -$1[-1] $3   # Assume this is a 1->1 filter.
    -r[-2,-1] {max(w,@{-2,w})},{max(h,@{-2,h})},1,100%,3
    -if {!$4} -columns[-2] 0,50% -columns[-1] 50%,100% -endif
    -a[-2,-1] x -r[-1] $width,$height,1,100%,2 -drgba[-1]
    -line[-1] 50%,0,50%,100%,1,0,0,0,255
    -text_outline[-1] "Start",1,0,13,1,1,255 -text_outline[-1] "End",{w-23},{h-16},13,1,1,255
  -mv[-1] 0 -done

#@gimp 3d elevation [animated] : gimp_animate_elevation3d, gimp_animate_elevation3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Factor = float(100,-1000,1000)
#@gimp : Smoothness = float(1,0,10)
#@gimp : Width = _int(1024,8,4096)
#@gimp : Height = _int(1024,8,4096)
#@gimp : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,1440)
#@gimp : Y-angle = float(0,0,1440)
#@gimp : Z-angle = float(360,0,1440)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_elevation3d :
  -if $3 filename="$4/gmic_elevation3d.png" -else filename="" -endif
  -_gimp_elevation3d ${5-6}
  -animate gimp_render3d,"${7-8},${10-19},$9",\
                         "${7-8},${20-29},$9",$1,$2,@{-quote\ $filename}

gimp_animate_elevation3d_preview :
  w={w} h={h}
  -_gimp_elevation3d ${5-6}
  -gimp_animate_preview gimp_render3d,$w","$h",${10-19},$9",\
                                      $w","$h",${20-29},$9",0,$w,$h

#@gimp 3d extrusion [animated] : gimp_animate_extrude3d, gimp_animate_extrude3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Depth = float(10,1,256)
#@gimp : Resolution = int(512,1,1024)
#@gimp : Smoothness = float(0.6,0,3)
#@gimp : Width = _int(1024,8,4096)
#@gimp : Height = _int(1024,8,4096)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = float(0.8,0,3)
#@gimp : X-angle = float(35,0,1440)
#@gimp : Y-angle = float(360,0,1440)
#@gimp : Z-angle = float(0,0,1440)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_extrude3d :
  -if $3 filename="$4/gmic_extrude3d.png" -else filename="" -endif
  -_gimp_extrude3d ${5-7}
  -animate gimp_render3d,"${8-9},${11-20},$10",\
                         "${8-9},${21-30},$10",$1,$2,@{-quote\ $filename}

gimp_animate_extrude3d_preview :
  w={w} h={h}
  -_gimp_extrude3d ${5-7}
  -gimp_animate_preview gimp_render3d,$w","$h",${11-20},$10",\
                                      $w","$h",${21-30},$10",0,$w,$h

#@gimp 3d image object [animated] : gimp_animate_imageobject3d, gimp_animate_imageobject3d_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gimp : Width = _int(1024,1,4096)
#@gimp : Height = _int(1024,1,4096)
#@gimp : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = float(0.5,0,3)
#@gimp : X-angle = float(57,0,1440)
#@gimp : Y-angle = float(401,0,1440)
#@gimp : Z-angle = float(21,0,1440)
#@gimp : FOV = float(45,1,90)
#@gimp : X-light = float(0,-100,100)
#@gimp : Y-light = float(0,-100,100)
#@gimp : Z-light = float(-100,-100,0)
#@gimp : Specular lightness = float(0.5,0,1)
#@gimp : Specular shininess = float(0.7,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_imageobject3d :
  -if $3 filename="$4/gmic_imageobject3d.png" -else filename="" -endif
  -_gimp_imageobject3d "_",$5
  -animate gimp_render3d,"${6-7},${9-18},$8",\
                         "${6-7},${19-28},$8",$1,$2,@{-quote\ $filename}

gimp_animate_imageobject3d_preview :
  w={w} h={h}
  -_gimp_imageobject3d "_preview_",$5
  -gimp_animate_preview gimp_render3d,$w","$h",${9-18},$8",\
                                      $w","$h",${19-28},$8",0,$w,$h

#@gimp 3d text pointcloud : gimp_text_pointcloud3d, gimp_text_pointcloud3d_preview
#@gimp : Frames = _int(64,1,256)
#@gimp : 1st text = text("G'MIC")
#@gimp : 2nd text = text("Rocks!")
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(200,220,255)
#@gimp : Background = color(255,255,255,255)
#@gimp : X-shadow= float(2,0,10)
#@gimp : Y-shadow= float(2,0,10)
#@gimp : Shadow smoothness = float(1,0,5)
#@gimp : Stationary frames = _int(19,1,32)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/09/01</i>.</small>")
gimp_text_pointcloud3d :
  W={w} H={h} M={round(1.5*max(w,h))} -rm
  -text_pointcloud3d "$2","$3",$4
  -col3d[-1] ${5-7} -*3d[-1] {0.7*$M}
  -f3d 4000 -db3d 0 -m3d
  -repeat $1
    -rprogress {60*$>/$1}
    angle={$>*360/$1}
    --r3d[0] 1,0,1,$angle
    $M,$M,1,3,-1 -object3d[-1] [-2],50%,50%,0,1 -rm[-2]
  -done
  -rm[0] -a z -autocrop -1 -to_rgba -s z -replace_color 0,0,-1,-1,-1,255,0,0,0,0
  -if $11 N=@# -repeat @# -l[$>] -rprogress {60+40*$>/$N}
    -i[0] 100%,100%,1,4 -fc[0] ${8-11} --channels[-1] 3,3 --negative[-1] -b[-2,-1] $14% -to_rgba[-1]
    -j[0] [-1],$12%,$13%,0,0,1,[-2],255 -rm[-2,-1] -blend alpha
  -endl -done -endif
  -if {$W>$H} -r2dx $W -else -r2dy $H -endif
  -if {$15>1}
    -i[{int($1/2)}] [{int($1/2)}]x{$15-1}
    -i[0] [0]x{$15-1}
  -endif

gimp_text_pointcloud3d_preview :
  -gimp_text_pointcloud3d 4,"$2","$3",$4,${5-7},${8-11},${12-14},1 -drgba
  -frame 1,1,0 -append_tiles 2,2

#@gimp 3d tiles : gimp_transition3d, gimp_transition3d_preview(0)
#@gimp : Inter-frames = _int(10,3,100)
#@gimp : X-tiles = int(8,1,64)
#@gimp : Y-tiles = int(8,1,64)
#@gimp : X-rotation = text("1")
#@gimp : Y-rotation = text("1")
#@gimp : Z-rotation = text("0")
#@gimp : Focale = float(800,100,2000)
#@gimp : Enable antialiasing = bool(1)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/08/13</i>.</small>")
gimp_transition3d :
  -f3d $7
  -transition3d $1,$2,$3,"$4","$5","$6",$8

gimp_transition3d_preview :
  -f3d $7
  -if {@#==1} -return -endif
  -k[0,1] -transition3d 4,$2,$3,"$4","$5","$6",$8
  -k[1,2]
  -r[0] 50%,100%,1,100%,0
  -r[1] 50%,100%,1,100%,0,0,1
  -a x
  -line 50%,0,50%,100%,1,0,0,0,255

#@gimp Plasma transition : gimp_transition_plasma, gimp_transition_plasma_preview(0)
#@gimp : Frames = _int(30,2,100)
#@gimp : Scale = int(5,0,10)
#@gimp : Smoothness = float(0.5,0,4)
#@gimp : sep = separator(), note = note{"<small><b>Note:</b>
#@gimp : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/11/09</i>.</small>")
gimp_transition_plasma :
  -transition_plasma $1,$2,$3%

gimp_transition_plasma_preview :
  -if {@#==1} -return -endif
  -k[0,1] -transition_plasma 6,$2,$3% -k[1--2] -frame 1,1,0 -append_tiles ,

#@gimp B&amp;W pencil [animated] : gimp_animate_pencilbw, gimp_animate_pencilbw_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Pencil type = float(2.3,0,5)
#@gimp : Amplitude = float(100,0,200)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_pencilbw :
  -if $3 filename="$4/gmic_pencilbw.png" -else filename="" -endif
  -animate pencilbw,"${5-6}",\
                    "${7-8}",$1,$2,@{-quote\ $filename}

gimp_animate_pencilbw_preview :
  -gimp_animate_preview pencilbw,"${5-6}",\
                                 "${7-8}"

#@gimp B&amp;W stencil [animated] : gimp_animate_stencilbw, gimp_animate_stencilbw_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(10,0,30)
#@gimp : Smoothness = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(10,0,30)
#@gimp : Smoothness = float(20,0,30)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_stencilbw :
  -if $3 filename="$4/gmic_stencilbw.png" -else filename="" -endif
  -animate stencilbw,"${5-6}",\
                     "${7-8}",$1,$2,@{-quote\ $filename}

gimp_animate_stencilbw_preview :
  -gimp_animate_preview stencilbw,"${5-6}",\
                                  "${7-8}"

#@gimp Cartoon [animated] : gimp_animate_cartoon, gimp_animate_cartoon_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Color quantization = int(4,2,256)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0.5,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(3,0,2)
#@gimp : Sharpening = float(200,0,400)
#@gimp : Edge threshold = float(10,1,30)
#@gimp : Edge thickness = float(0.1,0,1)
#@gimp : Color strength = float(1.5,0,3)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_cartoon :
  -if $3 filename="$4/gmic_cartoon.png" -else filename="" -endif
  -animate cartoon,"${6-10},$5",\
                   "${11-15},$5",$1,$2,@{-quote\ $filename}

gimp_animate_cartoon_preview :
  -gimp_animate_preview cartoon,"${6-10},$5",\
                                "${11-15},$5"

#@gimp Edges [animated] : gimp_animate_edges, gimp_animate_edges_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output frames = _bool(1)
#@gimp : Output files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Negative colors = bool(0)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(10,0,30)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Smoothness = float(0,0,10)
#@gimp : Edge threshold = float(30,0,30)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_edges :
  -if $3 filename="$4/gmic_edges.png" -else filename="" -endif
  -animate gimp_edges,"${6-7},$5",\
                      "${8-9},$5",$1,$2,@{-quote\ $filename}

gimp_animate_edges_preview :
  -gimp_animate_preview gimp_edges,"${6-7},$5",\
                                   "${8-9},$5"

#@gimp Edges on fire : gimp_fire_edges, gimp_fire_edges_preview(0)
#@gimp : Edges = float(0.7,0,3)
#@gimp : Attenuation = float(0.25,0,1)
#@gimp : Smoothness = float(0.5,0,5)
#@gimp : Threshold = float(25,0,100)
#@gimp : sep = separator()
#@gimp : Number of frames = _int(20,1,999)
#@gimp : Starting frame = int(20,0,199)
#@gimp : Frame skip = _int(0,0,20)
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/07/06</i>.</small>")
gimp_fire_edges :
  -fire_edges ${1-7} -rv

gimp_fire_edges_preview :
  -gimp_split_preview "-fire_edges $1,$2,$3,$4,1,$6,0",$-1

#@gimp Lava lamp : gimp_lavalampbw, gimp_lavalampbw_preview(0)
#@gimp : Number of key-frames = _int(3,2,50)
#@gimp : Number of inter-frames = _int(30,2,100)
#@gimp : Smooth looping = _bool(1)
#@gimp : sep = separator()
#@gimp : Resolution = float(20,1,100)
#@gimp : Size = float(2,0,30)
#@gimp : Smoothness = _float(0.01,0,1)
#@gimp : Transparent background = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/07/06</i>.</small>")
gimp_lavalampbw :
  -if {!@#} (255;100^64;16^128;0) -r[-1] 512,512,1,3,3 -endif
  -repeat @# -l[$<]
    w={w} h={h}
    --r $4%,$4%,1,1,0 [-1]x{$1-1} -rand[^0] 0,1 -stencil[^0] $5,0
    -if $3 [1] -endif
    -morph[^0] $2,$6,0
    -stencil[^0] $5,0
    -r[^0] $w,$h,1,1,3 -b[^0] 10 -ge[^0] 50% -*[^0] 255
    -r[^0] 100%,100%,1,4 -j[^0] [0] -rm[0]
    -if $3 -rm[-1] -endif
  -endl -done
  -if {!$7} -repeat @# -l[$>] -split_opacity -n[-1] 0,1 -*[^-1] [-1] -rm[-1] -endl -done -endif

gimp_lavalampbw_preview :
  -gimp_lavalampbw 2,2,1,$4,$5,$6,$7 -k[0]

#@gimp Lissajous [animated] : gimp_animate_lissajous, gimp_animate_lissajous_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : sep = separator()
#@gimp : note = note{"<b>Starting parameters :</b>"}
#@gimp : Resolution = int(4096,2,8192)
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : Z-size = float(3,1,10)
#@gimp : X-multiplier = float(8,0,32)
#@gimp : Y-multiplier = float(7,0,32)
#@gimp : Z-multiplier = float(0,0,32)
#@gimp : X-offset = float(0,0,1)
#@gimp : Y-offset = float(0,0,1)
#@gimp : Z-offset = float(0,0,1)
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : Thickness = float(0,0,50)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator()
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Resolution = int(4096,2,8192)
#@gimp : X-size = float(0.9,0,2)
#@gimp : Y-size = float(0.9,0,2)
#@gimp : Z-size = float(3,1,10)
#@gimp : X-multiplier = float(8,0,32)
#@gimp : Y-multiplier = float(7,0,32)
#@gimp : Z-multiplier = float(0,0,32)
#@gimp : X-offset = float(0,0,1)
#@gimp : Y-offset = float(0,0,1)
#@gimp : Z-offset = float(0,0,1)
#@gimp : X-angle = float(0,0,360)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Z-angle = float(0,0,360)
#@gimp : Thickness = float(0,0,50)
#@gimp : Color = color(255,255,255,255)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/04/18</i>.</small>")
gimp_animate_lissajous :
  -if $3 filename="$4/gmic_lissajous.png" -else filename="" -endif
  -animate gimp_lissajous,"${5-22}",\
                          "${23-40}",$1,$2,@{-quote\ $filename}

gimp_animate_lissajous_preview :
  -gimp_animate_preview gimp_lissajous,"${5-22}",\
                                       "${23-40}",0

#@gimp Morphological filter [animated] : gimp_animate_morpho, gimp_animate_morpho_preview(0)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Global parameters :</b>"}
#@gimp : Action = choice("Erosion","Dilation","Opening","Closing",
#@gimp : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gimp : Invert colors = bool(false)
#@gimp : Shape = choice(0,"Square","Octagonal","Circular")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Size = int(5,1,100)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Size = int(50,2,100)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_morpho :
  -if $3 filename="$4/gmic_morpho.png" -else filename="" -endif
  -animate gimp_morpho,"$5,$8,$6,$7,0,1",\
                       "$5,$9,$6,$7,0,1",$1,$2,@{-quote\ $filename}

gimp_animate_morpho_preview :
  -gimp_animate_preview gimp_morpho,"$5,$8,$6,$7,0,1",\
                                    "$5,$9,$6,$7,0,1"

#@gimp Rodilius [animated] : gimp_animate_rodilius, gimp_animate_rodilius_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : Color mode = choice(1,"Darker","Lighter")
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(10,0,30)
#@gimp : Thickness = float(10,0,100)
#@gimp : Sharpness = float(300,0,1000)
#@gimp : Orientations = int(5,2,20)
#@gimp : Offset = float(0,0,180)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(10,0,30)
#@gimp : Thickness = float(10,0,100)
#@gimp : Sharpness = float(300,0,1000)
#@gimp : Orientations = int(5,2,20)
#@gimp : Offset = float(180,0,180)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_rodilius :
  -if $3 filename="$4/gmic_rodilius.png" -else filename="" -endif
  -animate rodilius,"${6-10},$5",\
                    "${11-15},$5",$1,$2,@{-quote\ $filename}

gimp_animate_rodilius_preview :
  -gimp_animate_preview rodilius,"${6-10},$5",\
                                 "${11-15},$5"

#@gimp Soft glow [animated] : gimp_animate_glow, gimp_animate_glow_preview(1)
#@gimp : Frames = _int(10,2,100)
#@gimp : Output as frames = _bool(1)
#@gimp : Output as files = _bool(0)
#@gimp : Output folder = _folder()
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(0,0,8)
#@gimp : note = note{"\n<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(3,0,8)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_animate_glow :
  -if $3 filename="$4/gmic_glow.png" -else filename="" -endif
  -animate glow,"$5",\
                "$6",$1,$2,@{-quote\ $filename}

gimp_animate_glow_preview :
  -gimp_animate_preview glow,"$5",\
                             "$6"

#@gimp _<b>Spectral filters</b>
#------------------------------

#@gimp Bandpass : gimp_bandpass, gimp_bandpass_preview(0)
#@gimp : Low frequency = float(0,0,100)
#@gimp : High frequency = float(100,0,100)
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Value range = choice(1,"Cut","Normalize")
#@gimp : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_bandpass :
  -apply_channels "-bandpass $1%,$2%",$3,$4

gimp_bandpass_preview :
  -gimp_split_preview "-gimp_bandpass $*",$-1

#@gimp Fourier analysis : gimp_display_fft, gimp_display_fft(1)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_display_fft :
  -to_rgb -display_fft

#@gimp Fourier transform : gimp_fourier, gimp_fourier_preview(1)
#@gimp : Transform = choice(0,"Direct","Inverse")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_fourier :
  -if $1 -fft82float -c 0,255
  -else -float2fft8
  -endif

gimp_fourier_preview :
  -if $1 -gimp_no_preview 0
  -else -dfft
  -endif

#@gimp Fourier watermark : gimp_watermark_fourier, _none_
#@gimp : Text = text{"(c) G'MIC"}
#@gimp : Size = int(57,13,128)
#@gimp : sep = separator()
#@gimp : note = note("<small><b>Note: </b> To make the watermark visible afterwards, use the 'Fourier Analysis' filter. </small>")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_watermark_fourier :
  -watermark_fourier "$1",$2 -c 0,255

#@gimp _<b>Various</b>
#----------------------

#@gimp Custom code (local) : gimp_custom_code, gimp_custom_code_preview(0)
#@gimp : Code = text(1,"-repeat @# -l[$>]\n\n  -to_rgb\n  --deform 20\n  -blend_edges 3\n\n-endl -done\n\n\n")
#@gimp : sep = separator()
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note: </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC custom commands and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.sourceforge.net/reference.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/06/14</i>.</small>")

#@gimp Custom code (global) : gimp_custom_code, gimp_custom_code_preview(1)
#@gimp : Code = text(1,"-repeat @# -l[$>]\n\n  -to_rgb\n  --deform 20\n  -blend_edges 3\n\n-endl -done\n\n\n")
#@gimp : sep = separator()
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gimp : Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical")
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note: </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC custom commands and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.sourceforge.net/reference.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/06/14</i>.</small>")
gimp_custom_code : -skip "${1=-skip ,}"
  -m "_gimp_custom_code_start : $1"
  -if {$3>0}
    -apply_channels "-_gimp_custom_code_start",$3,$2
  -else
    -_gimp_custom_code
    -if $2 -n 0,255 -else -c 0,255 -endif
  -endif
  -uncommand _gimp_custom_code_start

gimp_custom_code_preview : -skip "${1=-skip ,}"
  _gcp_arg="$1"
  -gimp_split_preview "-gimp_custom_code $_gcp_arg,${2--2}",$-1

_gimp_custom_code :
  -_gimp_custom_code_start

#@gimp Do nothing : gimp_do_nothing, gimp_do_nothing
#@gimp : note = note("<b>Note</b> : This filters does nothing on the image. Use it to manipulate layers in conjunction with the input/output options of the G'MIC plug-in.")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_do_nothing :

#@gimp GREYC Poker Tour : gimp_gpt, gimp_no_preview
#@gimp : Score type = _choice(0,"All-times","Last 50 sessions","Last 25 sessions","Last 10 sessions","Last tournament 50","Last tournament 25","Last tournament 10")
#@gimp : sep = separator(), note = note{"<b>Note</b> : This filters renders and displays the current score board for the <b>GPT (GREYC Poker Tour)</b>,
#@gimp : a small and local poker tournament organized in our research lab."};
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/03/27</i>.</small>")
gimp_gpt :
  -gpt ,@{-_gimp_gpt$1}

_gimp_gpt0 : -u 0
_gimp_gpt1 : -u 50
_gimp_gpt2 : -u 25
_gimp_gpt3 : -u 10
_gimp_gpt4 : -u -50
_gimp_gpt5 : -u -25
_gimp_gpt6 : -u -10

#@gimp Histogram analysis : _none_, gimp_display_histogram(1)
#@gimp : Clusters = int(256,2,256)
#@gimp : Monochrome = bool(0)
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_display_histogram :
  -to_rgb -if $2 -luminance -endif
  -repeat @#
    -display_histogram[-1] {w},{h},$1,0,255
  -mv[-1] 0 -done

#@gimp Import data : gimp_import_image, gimp_no_preview
#@gimp : Filename = file()
#@gimp : Normalize = bool(1)
#@gimp : note = note{"\n<small><b>Note: </b>
#@gimp : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gimp : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG (requires FFMPEG installed), ...</i>
#@gimp : </small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2010/12/29</i>.</small>")
gimp_import_image :
  -rm -i "$1" -s z -if $2 -n 0,255 -else -c 0,255 -endif

#@gimp Solve maze : gimp_solve_maze, gimp_solve_maze_preview(1)
#@gimp : Starting X-coord = float(5,0,100)
#@gimp : Starting Y-coord = float(5,0,100)
#@gimp : Ending X-coord = float(95,0,100)
#@gimp : Endind Y-coord = float(95,0,100)
#@gimp : Smoothness = float(0.1,0,1)
#@gimp : Thickness = int(3,1,10)
#@gimp : Color = color(255,0,0)
#@gimp : Maze type = choice("Dark walls","White walls")
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2011/09/01</i>.</small>")
gimp_solve_maze :
  -repeat @#
    --norm[-1] -ge[-1] 50%
    -if {!$10} -negative[-1] -endif
    -*[-1] 255 --b[-1] $5% -*[-2] 1e10 -+[-2,-1]
    -minimal_path[-1] $1%,$2%,0,$3%,$4%,0
    -pointcloud[-1] 0 -dilate[-1] $6 -r[-1] [-2],[-2],1,1,0
    -to_rgba[-1]
    -replace_color[-1] 0,0,1,1,1,255,${7-9},255
    -replace_color[-1] 0,0,0,0,0,255,0,0,0,0
    -ellipse[-1] $1%,$2%,5,5,0,1,${7-9},255
    -ellipse[-1] $3%,$4%,5,5,0,1,${7-9},255
    -rv[-2,-1]
  -mv[-2,-1] 0 -done

gimp_solve_maze_preview :
  -drgba
  -line $1%,$2%,$3%,$4%,1,0xCCCCCCCC,${7-9}
  -ellipse $1%,$2%,3,3,0,1,${7-9}
  -ellipse $1%,$2%,3,3,0,1,0x1,0
  -ellipse $3%,$4%,3,3,0,1,${7-9}
  -ellipse $3%,$4%,3,3,0,1,0x1,0

#-------------------------------------
#
# Define menu entries for
# the G'MIC online web service.
#
#-------------------------------------

#@gmicol <i>About</i>
#--------------------

#@gmicol G'MIC Online : _none_, gmicol_logo_en
#@gmicol : note = note{"
#@gmicol : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic for <b>I</b>mage <b>C</b>omputing <b>O</b>n-<b>L</b>ine)</span>\n\nis proposed to you by"}
#@gmicol : note = link("S&#233;bastien Fourey","http://foureys.users.greyc.fr/")
#@gmicol : note = link("David Tschumperl&#233;","http://tschumperle.users.greyc.fr/")
#@gmicol : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gmicol : note = note{"
#@gmicol : This web-service is based on our software <b>G'MIC</b> available at:"}
#@gmicol : note = link("http://gmic.sourceforge.net/")
#@gmicol : note = note{"Colorpickers and sliders widgets are provided by the <b>DHTMLX</b> project:"}
#@gmicol : note = link("http://www.dhtmlx.com")
#@gmicol : sep = separator()
#@gmicol : note = note{"<b>G'MIC</b> is also available as a free plug-in for the image retouching software <b>GIMP</b>. Download it to get more filters
#@gmicol : and features than in the online version, at:"}
#@gmicol : note = link{"The G'MIC plug-in for GIMP","http://gmic.sourceforge.net/gimp.shtml"}
#@gmicol : sep = separator(), note = note("<small>Authors: <i>S&#233;bastien Fourey, David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")
gmicol_logo_en :
  -gimp_logo "    - Online -"

#@gmicol clone("Contributors")

#@gmicol _<b>Arrays &amp; tiles</b>
#----------------------------------

#@gmicol Array [faded] : gimp_array_fade, gimp_array_fade_preview(1)
#@gmicol : X-tiles = int(2,1,10)
#@gmicol : Y-tiles = int(2,1,10)
#@gmicol : X-offset = float(0,0,100)
#@gmicol : Y-offset = float(0,0,100)
#@gmicol : Fade start = float(80,1,100)
#@gmicol : Fade end = float(90,1,100)
#@gmicol : Mirror = choice("None","x-axis","y-axis","xy-axes")
#@gmicol : Size = _choice("Shrink", "Expand")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")

#@gmicol clone("Array [mirrored]")
#@gmicol clone("Array [random]")
#@gmicol clone("Array [regular]")
#@gmicol clone("Chessboard")
#@gmicol : thumbnail_parameters = 16,16,0,0,0,0.5,0,0,0,255,255,255,255,255

#@gmicol clone("Dices")
#@gmicol clone("Grid")
#@gmicol clone("Puzzle")
#@gmicol clone("Taquin")
#@gmicol clone("Tileable rotation")
#@gmicol clone("Tiled rotation")
#@gmicol clone("Tiled normalization")
#@gmicol clone("Tiled random shifts")
#@gmicol clone("Tiled parameterization")
#@gmicol clone("Tiled isolation")
#@gmicol : thumbnail_parameters = 10,10,10,10,1,1

#@gmicol _<b>Artistic</b>
#------------------------

#@gmicol clone("Bokeh")
#@gmicol clone("Cartoon")
#@gmicol clone("Cubism")
#@gmicol clone("Ellipsionism")
#@gmicol clone("Felt pen")
#@gmicol clone("Hope poster")
#@gmicol clone("Kuwahara")
#@gmicol clone("Lylejk's painting")
#@gmicol clone("Painting")
#@gmicol clone("Pen drawing")
#@gmicol clone("Polygonize")
#@gmicol clone("Poster edges")
#@gmicol clone("Rodilius")
#@gmicol clone("Warhol")
#@gmicol clone("Whirl drawing")

#@gmicol _<b>Basics</b>
#----------------------

#@gmicol Adjust colors : gmicol_adjust_colors, gmicol_adjust_colors_preview
#@gmicol : Contrast = float(1,0,3)
#@gmicol : Brightness = float(0,-1,1)
#@gmicol : Gamma = float(0,-1.2,1.2)
#@gmicol : Hue = float(0,0,360)
#@gmicol : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/23</i>.</small>")
#@gmicol : thumbnail_parameters = 1.8,0,0,50
gmicol_adjust_colors :
  -repeat @# -l[$>]
    avg={ia} -- $avg -* $1 -+ $avg
    -+ {$2*256}
    -if {$3!=1} -apply_gamma {10^$3} -endif
    -if {$4%360}
      -to_colormode {max(3,s)+1-s%2} -split_opacity -l[0]
        -rgb2hsv -sh 0,0 -+[-1] $4 -%[-1] 360 -rm[-1] -hsv2rgb
      -endl
    -a c -endif
  -endl -done -c 0,255

gmicol_adjust_colors_preview :
  -gimp_split_preview "-gmicol_adjust_colors $*",$-1

#@gmicol Autocrop : autocrop, autocrop
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/25</i>.</small>")

#@gmicol Crop : gmicol_crop, gmicol_crop_preview
#@gmicol : Left coordinate = float(25,0,100)
#@gmicol : Up coordinate = float(25,0,100)
#@gmicol : Right coordinate = float(75,0,100)
#@gmicol : Bottom coordinate = float(75,0,100)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/18</i>.</small>")
gmicol_crop :
  -crop $1%,$2%,$3%,$4%

gmicol_crop_preview :
  -rectangle $1%,$2%,$3%,$4%,0.5,128
  -rectangle $1%,$2%,$3%,$4%,1,0xFFFFFFFF,0
  -circle $1%,$2%,3,1,0,255,0 -circle $1%,$2%,3,1,0xFFFFFFFF,0
  -circle $3%,$2%,3,1,0,255,0 -circle $3%,$2%,3,1,0xFFFFFFFF,0
  -circle $3%,$4%,3,1,0,255,0 -circle $3%,$4%,3,1,0xFFFFFFFF,0
  -circle $1%,$4%,3,1,0,255,0 -circle $1%,$4%,3,1,0xFFFFFFFF,0

#@gmicol Equalize : gmicol_equalize, gmicol_equalize_preview
#@gmicol : Channel(s) = choice(3,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gmicol : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/18</i>.</small>")
gmicol_equalize :
  -apply_channels "-equalize 256,0,255",$1,1

gmicol_equalize_preview :
  -gimp_split_preview "-gmicol_equalize $*",$-1

#@gmicol Flip : gmicol_flip, gmicol_flip
#@gmicol : Type = choice("Horizontal","Vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/23</i>.</small>")
gmicol_flip :
  -if $1 -mirror y -else -mirror x -endif

#@gmicol Histogram : gmicol_histogram, gmicol_histogram_preview
#@gmicol : Levels = int(128,1,256)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/18</i>.</small>")
#@gmicol : thumbnail_parameters = 32
gmicol_histogram :
  -to_rgb -dh 640,480,$1

gmicol_histogram_preview :
  -to_rgb -dh 320,240,$1

#@gmicol Negative : negative, negative
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/23</i>.</small>")

#@gmicol Resize : gmicol_resize, _none_
#@gmicol : Type = choice("Ratio in %","Prescribed width","Prescribed height")
#@gmicol : Ratio in % = float(50,0,300)
#@gmicol : Prescribed width = int(256,8,1280)
#@gmicol : Prescribed height = int(256,8,1280)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/23</i>.</small>")
gmicol_resize :
  -if {$1==0}
    -resize $2%,$2%,1,100%,6
  -elif {$1==1}
    -resize2dx $3,6
  -else
    -resize2dy $4,6
  -endif
  -c 0,255

#@gmicol Rotate : gmicol_rotate, gmicol_rotate
#@gmicol : Angle = float(30,0,359)
#@gmicol : Stick to nearest 90 deg. = bool(0)
#@gmicol : Boundary = choice("Transparent","Nearest","Repeat")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/23</i>.</small>")
gmicol_rotate :
  -if $2
    -rotate {90*round($1/90)},0,0
  -else
    -to_rgba -rotate $1,1,$3
  -endif

#@gmicol _<b>Black &amp; white</b>
#---------------------------------

#@gmicol clone("Black &amp; white")
#@gmicol clone("B&amp;W stencil")
#@gmicol clone("Charcoal")
#@gmicol clone("Colorize [with colormap]")
#@gmicol clone("Dithering")
#@gmicol clone("Hard sketch")
#@gmicol clone("Hough sketch")
#@gmicol clone("Ink wash")
#@gmicol clone("Multi-layer etch")
#@gmicol clone("Pencil")
#@gmicol clone("Pencil portrait")
#@gmicol clone("Sketch")
#@gmicol clone("Stamp")
#@gmicol clone("Threshold etch")

#@gmicol _<b>Colors</b>
#----------------------

#@gmicol clone("Abstraction")
#@gmicol clone("Boost-fade")
#@gmicol : thumbnail_parameters = 10

#@gmicol clone("Channel processing")
#@gmicol clone("CMYK tone")
#@gmicol clone("Colormap")
#@gmicol clone("Color balance")
#@gmicol clone("Color temperature")
#@gmicol clone("Curves")

#@gmicol Curves [RGB]
#@gmicol clone("Red")
#@gmicol clone("Green")
#@gmicol clone("Blue")
#@gmicol _

#@gmicol Curves [YCbCr]
#@gmicol clone("Luminance")
#@gmicol clone("Blue chrominance")
#@gmicol clone("Red chrominance")
#@gmicol _

#@gmicol Curves [Lab]
#@gmicol clone("Lightness")
#@gmicol clone("A-color")
#@gmicol clone("B-color")
#@gmicol _

#@gmicol clone("Detect skin")
#@gmicol clone("Equalize HSV")
#@gmicol clone("HSL adjustment")
#@gmicol clone("HSV select")
#@gmicol clone("Infrared simulation")
#@gmicol clone("Metallic look")
#@gmicol clone("Mixer [RGB]")
#@gmicol clone("Mixer [YCbCr]")
#@gmicol clone("Mixer [HSV]")
#@gmicol clone("Mixer [Lab]")
#@gmicol clone("Mixer [CMYK]")
#@gmicol clone("Replace color")
#@gmicol clone("RGB tone")
#@gmicol clone("Select color")
#@gmicol clone("Sepia")
#@gmicol clone("Tone presets")
#@gmicol clone("User-defined")
#@gmicol clone("Vintage style")
#@gmicol clone("Zone system")

#@gmicol _<b>Contours</b>
#------------------------

#@gmicol clone("Convolve")
#@gmicol clone("Curvature")
#@gmicol clone("Difference of gaussians")
#@gmicol clone("Distance transform")
#@gmicol clone("Edges")
#@gmicol clone("Edges offsets")
#@gmicol clone("Gradient norm")
#@gmicol clone("Gradient RGB")
#@gmicol clone("Isophotes")
#@gmicol clone("Laplacian")
#@gmicol clone("Local orientation")
#@gmicol clone("Morphological filter")
#@gmicol clone("Segmentation")
#@gmicol clone("Skeleton")
#@gmicol clone("Thin edges")

#@gmicol _<b>Deformations</b>
#----------------------------

#@gmicol clone("Cartesian transform")
#@gmicol clone("Circle transform")
#@gmicol clone("Euclidean - polar")
#@gmicol clone("Fish-eye")
#@gmicol clone("Flower")
#@gmicol clone("Kaleidoscope [blended]")
#@gmicol clone("Kaleidoscope [polar]")
#@gmicol clone("Kaleidoscope [symmetry]")
#@gmicol clone("Perspective")
#@gmicol clone("Polar transform")
#@gmicol clone("Raindrops")
#@gmicol clone("Random")
#@gmicol clone("Ripple")
#@gmicol clone("Reflection")
#@gmicol clone("Sphere")
#@gmicol clone("Symmetrize")
#@gmicol clone("Textured glass")
#@gmicol clone("Twirl")
#@gmicol clone("Water")
#@gmicol clone("Wave")
#@gmicol clone("Wind")
#@gmicol clone("Zoom")

#@gmicol _<b>Degradations</b>
#----------------------------

#@gmicol clone("Blur [angular]")
#@gmicol clone("Blur [gaussian]")
#@gmicol clone("Blur [glow]")
#@gmicol clone("Blur [linear]")
#@gmicol clone("Blur [radial]")
#@gmicol clone("Lomo")
#@gmicol clone("Noise [additive]")
#@gmicol clone("Noise [spread]")
#@gmicol clone("Old-movie stripes")
#@gmicol clone("Oldschool 8bits")
#@gmicol clone("Random shade stripes")
#@gmicol clone("Tilt shift")
#@gmicol clone("Visible watermark")

#@gmicol _<b>Details</b>
#-----------------------

#@gmicol clone("Details equalizer")
#@gmicol clone("Freaky details")
#@gmicol clone("Local contrast enhancement")
#@gmicol clone("Local normalization")
#@gmicol clone("Local variance normalization")
#@gmicol clone("Sharpen [deblur]")
#@gmicol clone("Sharpen [gold-meinel]")
#@gmicol clone("Sharpen [inverse diffusion]")
#@gmicol clone("Sharpen [octave sharpening]")
#@gmicol clone("Sharpen [richardson-lucy]")
#@gmicol clone("Sharpen [shock filters]")
#@gmicol clone("Sharpen [unsharp mask]")
#@gmicol clone("Simple local contrast")
#@gmicol clone("Texture enhance")
#@gmicol clone("Tone mapping")
#@gmicol clone("Tone mapping [fast]")
#@gmicol clone("Yag effect")

#@gmicol _<b>Film emulation</b>
#------------------------------

#@gmicol clone("B&amp;W films")
#@gmicol clone("Grain")
#@gmicol clone("Instant [consumer]")
#@gmicol clone("Instant [pro]")
#@gmicol clone("Negative [color]")
#@gmicol clone("Negative [new]")
#@gmicol clone("Negative [old]")
#@gmicol clone("Other effects")
#@gmicol clone("Slide [color]")
#@gmicol clone("B&amp;W films - collage")
#@gmicol clone("Instant - collage [consumer]")
#@gmicol clone("Instant - collage [pro]")
#@gmicol clone("Negative - collage [color]")
#@gmicol clone("Negative - collage [new]")
#@gmicol clone("Negative - collage [old]")
#@gmicol clone("Other effects - collage")
#@gmicol clone("Slide - collage [color]")

#@gmicol _<b>Frames</b>
#-----------------------

#@gmicol clone("Droste")
#@gmicol clone("Frame [cube]")

#@gmicol clone("Frame [fuzzy]")
#@gmicol : thumbnail_parameters = 60,60,10,1,255,255,255,255

#@gmicol clone("Frame [painting]")
#@gmicol clone("Frame [pattern]")
#@gmicol clone("Frame [regular]")
#@gmicol clone("Frame [round]")
#@gmicol clone("Old photograph")
#@gmicol clone("Polaroid")
#@gmicol clone("Tunnel")
#@gmicol clone("Vignette")

#@gmicol _<b>Lights &amp; Shadows</b>
#------------------------------------

#@gmicol clone("Burn")
#@gmicol clone("Contrast swiss mask")
#@gmicol clone("Drop shadow")
#@gmicol clone("Drop shadow 3d")
#@gmicol clone("Equalize shadow")
#@gmicol clone("Light glow")
#@gmicol clone("Light patch")
#@gmicol clone("Light rays")
#@gmicol clone("Relief light")
#@gmicol clone("Shadow patch")

#@gmicol _<b>Patterns</b>
#------------------------

#@gmicol clone("Bayer filter")
#@gmicol clone("Box fitting")
#@gmicol clone("Canvas")
#@gmicol clone("Canvas texture")
#@gmicol clone("Cracks")
#@gmicol clone("Halftone")
#@gmicol clone("Hearts")
#@gmicol clone("Lava")
#@gmicol clone("Marble")
#@gmicol clone("Mineral mosaic")
#@gmicol clone("Mosaic")
#@gmicol clone("Op art")
#@gmicol clone("Paper texture")
#@gmicol clone("Plaid")
#@gmicol clone("Sponge")
#@gmicol clone("Stained glass")
#@gmicol clone("Stencil")
#@gmicol clone("Strip")
#@gmicol clone("Tetris")
#@gmicol clone("Turbulence")
#@gmicol clone("Weave")
#@gmicol clone("Whirls")

#@gmicol _<b>Rendering</b>
#-------------------------

#@gmicol clone("3d colored object")
#@gmicol clone("3d elevation")
#@gmicol clone("3d extrusion")
#@gmicol clone("3d image object")
#@gmicol clone("3d lathing")
#@gmicol clone("3d random objects")
#@gmicol clone("Ball")
#@gmicol clone("Cupid")
#@gmicol clone("Equation plot [parametric]")
#@gmicol clone("Equation plot [y=f(x)]")
#@gmicol clone("Gradient [corners]")
#@gmicol clone("Gradient [custom shape]")
#@gmicol clone("Gradient [linear]")
#@gmicol clone("Gradient [radial]")
#@gmicol clone("Heart")
#@gmicol clone("Lissajous")
#@gmicol clone("Mandelbrot-julia sets")
#@gmicol clone("Maze")
#@gmicol clone("Plasma")
#@gmicol clone("Polka dots")
#@gmicol clone("Quick copyright")
#@gmicol clone("Rainbow")
#@gmicol clone("Random color ellipses")

#@gmicol RGB distribution : gmicol_rgb_distribution, gmicol_rgb_distribution_preview
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/19</i>.</small>")
_gmicol_rgb_distribution :
  -distribution3d -colorcube3d -p3d[-1] 1 -+3d
  -repeat 4
    --snapshot3d[0] $1,0.9,255
    -r3d[0] 0,1,0.2,90
  -done
  -rm[0] -autocrop -- 255
  -r @{-max_wh},1,3,0,0,0.5,0.5 -+ 255 -frame 5,5,255 -frame 1,1,0 -append_tiles ,

gmicol_rgb_distribution :
  -_gmicol_rgb_distribution 512

gmicol_rgb_distribution_preview :
  -_gmicol_rgb_distribution 320

#@gmicol clone("Rorschach")
#@gmicol clone("Seamless turbulence")
#@gmicol clone("Shade bobs")
#@gmicol clone("Sierpinski triangle")
#@gmicol clone("Snowflake")
#@gmicol clone("Spiral")
#@gmicol clone("Stars")
#@gmicol clone("Superformula")
#@gmicol clone("Truchet")

#@gmicol _<b>Repair</b>
#----------------------

#@gmicol clone("Bayer reconstruction")
#@gmicol clone("Deinterlace")
#@gmicol clone("Inpaint [diffusion]")
#@gmicol clone("Inpaint [patch-based]")
#@gmicol clone("Inpaint [solidify]")
#@gmicol clone("Red-eye attenuation")
#@gmicol clone("Remove hot pixels")
#@gmicol clone("Smooth [anisotropic]")
#@gmicol clone("Smooth [bilateral]")
#@gmicol clone("Smooth [diffusion]")
#@gmicol clone("Smooth [mean-curvature]")
#@gmicol clone("Smooth [median]")
#@gmicol clone("Smooth [patch-based]")
#@gmicol clone("Smooth [selective gaussian]")
#@gmicol clone("Smooth [skin]")
#@gmicol clone("Smooth [thin brush]")
#@gmicol clone("Smooth [total variation]")
#@gmicol clone("Smooth [wavelets]")
#@gmicol clone("Unstrip")
#@gmicol clone("Upscale [diffusion]")
#@gmicol clone("Upscale [scale2x]")

#@gmicol _<b>Sequences</b>
#-------------------------

#@gmicol 3d elevation : gmicol_animate_elevation3d, gmicol_animate_elevation3d_preview(1)
#@gmicol : Frames = _int(10,2,72)
#@gmicol : note = note{"\n<b>Global parameters :</b>"}
#@gmicol : Factor = float(100,-1000,1000)
#@gmicol : Smoothness = float(1,0,10)
#@gmicol : Width = _int(256,8,512)
#@gmicol : Height = _int(256,8,512)
#@gmicol : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gmicol : note = note{"\n<b>Starting parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,360)
#@gmicol : Y-angle = float(0,0,360)
#@gmicol : Z-angle = float(0,0,360)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : note = note{"\n<b>Ending parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,1440)
#@gmicol : Y-angle = float(0,0,1440)
#@gmicol : Z-angle = float(360,0,1440)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")
gmicol_animate_elevation3d :
  -_gimp_elevation3d ${2-3}
  -animate gimp_render3d,"${4-5},${7-16},$6",\
                         "${4-5},${17-26},$6",$1
  -o $_output.gif,10
  -rm

gmicol_animate_elevation3d_preview :
  -gimp_animate_elevation3d_preview $1,1,0,\"\",${2--1}

#@gmicol 3d extrusion : gmicol_animate_extrude3d, gmicol_animate_extrude3d_preview(1)
#@gmicol : Frames = _int(4,2,20)
#@gmicol : note = note{"\n<b>Global parameters :</b>"}
#@gmicol : Depth = float(10,1,256)
#@gmicol : Resolution = int(512,1,1024)
#@gmicol : Smoothness = float(0.6,0,3)
#@gmicol : Width = _int(128,8,256)
#@gmicol : Height = _int(128,8,256)
#@gmicol : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gmicol : note = note{"\n<b>Starting parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,360)
#@gmicol : Y-angle = float(0,0,360)
#@gmicol : Z-angle = float(0,0,360)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : note = note{"\n<b>Ending parameters :</b>"}
#@gmicol : Size = float(0.8,0,3)
#@gmicol : X-angle = float(35,0,1440)
#@gmicol : Y-angle = float(360,0,1440)
#@gmicol : Z-angle = float(0,0,1440)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")
gmicol_animate_extrude3d :
  -gimp_animate_extrude3d $1,1,0,\"\",${2--1}

gmicol_animate_extrude3d_preview :
  -gimp_animate_extrude3d_preview $1,1,0,\"\",${2--1}

#@gmicol 3d image object : gmicol_animate_imageobject3d, gmicol_animate_imageobject3d_preview(1)
#@gmicol : Frames = _int(4,2,20)
#@gmicol : note = note{"\n<b>Global parameters :</b>"}
#@gmicol : Type = choice{1,"Plane","Cube","Pyramid","Sphere","Torus","Gyroid","Weird","Cup","Rubik"}
#@gmicol : Width = _int(128,1,256)
#@gmicol : Height = _int(128,1,256)
#@gmicol : Rendering = choice(4,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gmicol : note = note{"\n<b>Starting parameters :</b>"}
#@gmicol : Size = float(0.5,0,3)
#@gmicol : X-angle = float(57,0,360)
#@gmicol : Y-angle = float(41,0,360)
#@gmicol : Z-angle = float(21,0,360)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : note = note{"\n<b>Ending parameters :</b>"}
#@gmicol : Size = float(0.5,0,3)
#@gmicol : X-angle = float(57,0,1440)
#@gmicol : Y-angle = float(401,0,1440)
#@gmicol : Z-angle = float(21,0,1440)
#@gmicol : FOV = float(45,1,90)
#@gmicol : X-light = float(0,-100,100)
#@gmicol : Y-light = float(0,-100,100)
#@gmicol : Z-light = float(-100,-100,0)
#@gmicol : Specular lightness = float(0.5,0,1)
#@gmicol : Specular shininess = float(0.7,0,3)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")
gmicol_animate_imageobject3d :
  -gimp_animate_imageobject3d $1,1,0,\"\",${2--1}

gmicol_animate_imageobject3d_preview :
  -gimp_animate_imageobject3d_preview $1,1,0,\"\",${2--1}

#@gmicol 3d text pointcloud : gimp_text_pointcloud3d, gimp_text_pointcloud3d_preview
#@gmicol : Frames = _int(9,1,20)
#@gmicol : 1st text = text("G'MIC")
#@gmicol : 2nd text = text("Rocks!")
#@gmicol : Smoothness = float(1,0,5)
#@gmicol : Color = color(200,220,255)
#@gmicol : Background = color(255,255,255,255)
#@gmicol : X-shadow= float(2,0,10)
#@gmicol : Y-shadow= float(2,0,10)
#@gmicol : Shadow smoothness = float(1,0,5)
#@gmicol : Stationary frames = _int(1,1,32)
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")

#@gmicol Edges on fire : gimp_fire_edges, gimp_fire_edges_preview(0)
#@gmicol : Edges = float(0.7,0,3)
#@gmicol : Attenuation = float(0.25,0,1)
#@gmicol : Smoothness = float(0.5,0,5)
#@gmicol : Threshold = float(25,0,100)
#@gmicol : sep = separator()
#@gmicol : Number of frames = _int(9,2,20)
#@gmicol : Starting frame = int(5,0,199)
#@gmicol : Frame skip = _int(0,0,20)
#@gmicol : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gmicol : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>2012/10/11</i>.</small>")

#@gmicol Lava lamp : gimp_lavalampbw, gimp_lavalampbw_preview(0)
#@gmicol : Number of key-frames = _int(3,2,50)
#@gmicol : Number of inter-frames = _int(3,2,100)
#@gmicol : Smooth looping = _bool(1)
#@gmicol : sep = separator()
#@gmicol : Resolution = float(20,1,100)
#@gmicol : Size = float(2,0,30)
#@gmicol : Smoothness = _float(0.01,0,1)
#@gmicol : Transparent background = bool(0)

#@gmicol _<b>Spectral filters</b>
#--------------------------------

#@gmicol clone("Bandpass")
#@gmicol clone("Fourier analysis")
#@gmicol clone("Fourier transform")
#@gmicol clone("Fourier watermark")

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
